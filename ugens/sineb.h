/* sineb -- unit generator for arco
 *
 * generated by f2a.py
 */

/*------------- BEGIN FAUST PREAMBLE -------------*/

/* ------------------------------------------------------------
author: "RBD"
name: "sineb"
version: "1.0"
Code generated with Faust 2.37.3 (https://faust.grame.fr)
Compilation options: -lang cpp -os0 -light -es 1 -single -ftz 0
------------------------------------------------------------ */

#ifndef  __Sineb_H__
#define  __Sineb_H__

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 

#include <algorithm>
#include <cmath>
#include <cstdint>
#include <math.h>

static float ftbl0SinebSIG0[65536];

#ifndef FAUSTCLASS 
#define FAUSTCLASS Sineb
#endif

#ifdef __APPLE__ 
#define exp10f __exp10f
#define exp10 __exp10
#endif

#if defined(_WIN32)
#define RESTRICT __restrict
#else
#define RESTRICT __restrict__
#endif

#define FAUST_INT_CONTROLS 0
#define FAUST_REAL_CONTROLS 2
/*-------------- END FAUST PREAMBLE --------------*/

extern const char *Sineb_name;

class Sineb : public Ugen {
public:
    struct Sineb_state {
        float fRec1[2];
        int iVec0[2];
        int iRec0[2];
    };
    Vec<Sineb_state> states;
    void (Sineb::*run_channel)(Sineb_state *state);

    Ugen_ptr freq;
    int freq_stride;
    Sample_ptr freq_samps;

    Ugen_ptr amp;
    int amp_stride;
    Sample_ptr amp_samps;

    float fConst0;

    Sineb(int id, int nchans, Ugen_ptr freq_, Ugen_ptr amp_) : Ugen(id, 'b', nchans) {
        freq = freq_;
        amp = amp_;
        states.init(chans);
        fConst0 = (1.0f / std::min<float>(192000.0f, std::max<float>(1.0f, float(AR))));

        // initialize channel states
        for (int i = 0; i < chans; i++) {
            for (int l2 = 0; (l2 < 2); l2 = (l2 + 1)) {
                states[i].fRec1[l2] = 0.0f;
            }
        }

        init_freq(freq);
        init_amp(amp);
    }

    ~Sineb() {
        freq->unref();
        amp->unref();
    }

    const char *classname() { return Sineb_name; }

    void print_sources(int indent, bool print) {
        freq->print_tree(indent, print, "freq");
        amp->print_tree(indent, print, "amp");
    }

    void repl_freq(Ugen_ptr inp) {
        freq->unref();
        init_freq(inp);
    }

    void repl_amp(Ugen_ptr inp) {
        amp->unref();
        init_amp(inp);
    }

    void set_freq(int chan, float f) {
        assert(freq->rate == 'c');
        freq->output[chan] = f;
    }

    void set_amp(int chan, float f) {
        assert(amp->rate == 'c');
        amp->output[chan] = f;
    }

    void init_freq(Ugen_ptr ugen) { init_param(ugen, freq, freq_stride); }

    void init_amp(Ugen_ptr ugen) { init_param(ugen, amp, amp_stride); }

    void real_run() {
        freq_samps = freq->run(current_block); // update input
        amp_samps = amp->run(current_block); // update input
        Sineb_state *state = &states[0];
        for (int i = 0; i < chans; i++) {
            state->fRec1[0] = (*freq_samps + (state->fRec1[1] - std::floor((*freq_samps + state->fRec1[1]))));
            *out_samps = FAUSTFLOAT((*amp_samps * ftbl0SinebSIG0[int((65536.0f * state->fRec1[0]))]));
            state->fRec1[1] = state->fRec1[0];
            state++;
            freq_samps += freq_stride;
            amp_samps += amp_stride;
        }
    }
};
#endif
