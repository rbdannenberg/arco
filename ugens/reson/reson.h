/* reson -- unit generator for arco
 *
 * generated by f2a.py
 */

/*------------- BEGIN FAUST PREAMBLE -------------*/

/* ------------------------------------------------------------
name: "reson"
Code generated with Faust 2.75.7 (https://faust.grame.fr)
Compilation options: -lang cpp -light -ct 1 -cn Reson -es 1 -mcd 16 -mdd 1024 -mdy 33 -single -ftz 0
------------------------------------------------------------ */

#ifndef  __Reson_H__
#define  __Reson_H__

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 

#include <algorithm>
#include <cmath>
#include <cstdint>
#include <math.h>

#ifndef FAUSTCLASS 
#define FAUSTCLASS Reson
#endif

#ifdef __APPLE__ 
#define exp10f __exp10f
#define exp10 __exp10
#endif

#if defined(_WIN32)
#define RESTRICT __restrict
#else
#define RESTRICT __restrict__
#endif

static float Reson_faustpower2_f(float value) {
    return value * value;
}
/*-------------- END FAUST PREAMBLE --------------*/

extern const char *Reson_name;

class Reson : public Ugen {
public:
    struct Reson_state {
        float fRec0[3];
    };
    Vec<Reson_state> states;
    void (Reson::*run_channel)(Reson_state *state);

    Ugen_ptr input;
    int input_stride;
    Sample_ptr input_samps;

    Ugen_ptr center;
    int center_stride;
    Sample_ptr center_samps;

    Ugen_ptr q;
    int q_stride;
    Sample_ptr q_samps;

    float fConst0;

    Reson(int id, int nchans, Ugen_ptr input_, Ugen_ptr center_, Ugen_ptr q_) :
            Ugen(id, 'a', nchans) {
        input = input_;
        center = center_;
        q = q_;
        flags = CAN_TERMINATE;
        states.set_size(chans);
        fConst0 = 3.1415927f / std::min<float>(1.92e+05f, std::max<float>(1.0f, float(AR)));
        init_input(input);
        init_center(center);
        init_q(q);
        run_channel = (void (Reson::*)(Reson_state *)) 0;
        update_run_channel();
    }

    ~Reson() {
        input->unref();
        center->unref();
        q->unref();
    }

    const char *classname() { return Reson_name; }

    void initialize_channel_states() {
        for (int i = 0; i < chans; i++) {
            for (int l0 = 0; l0 < 3; l0 = l0 + 1) {
                states[i].fRec0[l0] = 0.0f;
            }
        }
    }

    void update_run_channel() {
        // initialize run_channel based on input types
        void (Reson::*new_run_channel)(Reson_state *state);
        if (input->rate == 'b') {
            input = new Upsample(-1, input->chans, input);
        }
        if (center->rate == 'a') {
            if (q->rate == 'a') {
                new_run_channel = &Reson::chan_aaa_a;
            } else {
                new_run_channel = &Reson::chan_aab_a;
            }
        } else {
            if (q->rate == 'a') {
                new_run_channel = &Reson::chan_aba_a;
            } else {
                new_run_channel = &Reson::chan_abb_a;
            }
        }
        if (new_run_channel != run_channel) {
            initialize_channel_states();
            run_channel = new_run_channel;
        }
    }

    void print_sources(int indent, bool print_flag) {
        input->print_tree(indent, print_flag, "input");
        center->print_tree(indent, print_flag, "center");
        q->print_tree(indent, print_flag, "q");
    }

    void repl_input(Ugen_ptr ugen) {
        input->unref();
        init_input(ugen);
        update_run_channel();
    }

    void repl_center(Ugen_ptr ugen) {
        center->unref();
        init_center(ugen);
        update_run_channel();
    }

    void repl_q(Ugen_ptr ugen) {
        q->unref();
        init_q(ugen);
        update_run_channel();
    }

    void set_input(int chan, float f) {
        input->const_set(chan, f, "Reson::set_input");
    }

    void set_center(int chan, float f) {
        center->const_set(chan, f, "Reson::set_center");
    }

    void set_q(int chan, float f) {
        q->const_set(chan, f, "Reson::set_q");
    }

    void init_input(Ugen_ptr ugen) { init_param(ugen, input, &input_stride); }

    void init_center(Ugen_ptr ugen) { init_param(ugen, center, &center_stride); }

    void init_q(Ugen_ptr ugen) { init_param(ugen, q, &q_stride); }

    void chan_abb_a(Reson_state *state) {
        FAUSTFLOAT* input0 = input_samps;
        FAUSTFLOAT* output0 = out_samps;
        float fSlow0 = std::tan(fConst0 * std::max<float>(float(center_samps[0]), 0.1f));
        float fSlow1 = 1.0f / fSlow0;
        float fSlow2 = 1.0f / std::max<float>(float(q_samps[0]), 0.1f);
        float fSlow3 = 1.0f / ((fSlow1 + fSlow2) / fSlow0 + 1.0f);
        float fSlow4 = (fSlow1 - fSlow2) / fSlow0 + 1.0f;
        float fSlow5 = 2.0f * (1.0f - 1.0f / Reson_faustpower2_f(fSlow0));
        for (int i0 = 0; i0 < BL; i0 = i0 + 1) {
            state->fRec0[0] = float(input0[i0]) - fSlow3 * (fSlow4 * state->fRec0[2] + fSlow5 * state->fRec0[1]);
            output0[i0] = FAUSTFLOAT(fSlow3 * (state->fRec0[2] + 2.0f * state->fRec0[1] + state->fRec0[0]));
            state->fRec0[2] = state->fRec0[1];
            state->fRec0[1] = state->fRec0[0];
        }
    }

    void chan_aba_a(Reson_state *state) {
        FAUSTFLOAT* input0 = input_samps;
        FAUSTFLOAT* input1 = q_samps;
        FAUSTFLOAT* output0 = out_samps;
        float fSlow0 = std::tan(fConst0 * std::max<float>(float(center_samps[0]), 0.1f));
        float fSlow1 = 1.0f / fSlow0;
        float fSlow2 = 2.0f * (1.0f - 1.0f / Reson_faustpower2_f(fSlow0));
        for (int i0 = 0; i0 < BL; i0 = i0 + 1) {
            float fTemp0 = 1.0f / std::max<float>(float(input1[i0]), 0.1f);
            float fTemp1 = fSlow1 * (fSlow1 + fTemp0) + 1.0f;
            state->fRec0[0] = float(input0[i0]) - (state->fRec0[2] * (fSlow1 * (fSlow1 - fTemp0) + 1.0f) + fSlow2 * state->fRec0[1]) / fTemp1;
            output0[i0] = FAUSTFLOAT((2.0f * state->fRec0[1] + state->fRec0[0] + state->fRec0[2]) / fTemp1);
            state->fRec0[2] = state->fRec0[1];
            state->fRec0[1] = state->fRec0[0];
        }
    }

    void chan_aab_a(Reson_state *state) {
        FAUSTFLOAT* input0 = input_samps;
        FAUSTFLOAT* input1 = center_samps;
        FAUSTFLOAT* output0 = out_samps;
        float fSlow0 = 1.0f / std::max<float>(float(q_samps[0]), 0.1f);
        for (int i0 = 0; i0 < BL; i0 = i0 + 1) {
            float fTemp0 = std::tan(fConst0 * std::max<float>(float(input1[i0]), 0.1f));
            float fTemp1 = 1.0f / fTemp0;
            float fTemp2 = (fSlow0 + fTemp1) / fTemp0 + 1.0f;
            state->fRec0[0] = float(input0[i0]) - (state->fRec0[2] * ((fTemp1 - fSlow0) / fTemp0 + 1.0f) + 2.0f * state->fRec0[1] * (1.0f - 1.0f / Reson_faustpower2_f(fTemp0))) / fTemp2;
            output0[i0] = FAUSTFLOAT((2.0f * state->fRec0[1] + state->fRec0[0] + state->fRec0[2]) / fTemp2);
            state->fRec0[2] = state->fRec0[1];
            state->fRec0[1] = state->fRec0[0];
        }
    }

    void chan_aaa_a(Reson_state *state) {
        FAUSTFLOAT* input0 = input_samps;
        FAUSTFLOAT* input1 = center_samps;
        FAUSTFLOAT* input2 = q_samps;
        FAUSTFLOAT* output0 = out_samps;
        for (int i0 = 0; i0 < BL; i0 = i0 + 1) {
            float fTemp0 = std::tan(fConst0 * std::max<float>(float(input1[i0]), 0.1f));
            float fTemp1 = 1.0f / fTemp0;
            float fTemp2 = 1.0f / std::max<float>(float(input2[i0]), 0.1f);
            float fTemp3 = (fTemp2 + fTemp1) / fTemp0 + 1.0f;
            state->fRec0[0] = float(input0[i0]) - (state->fRec0[2] * ((fTemp1 - fTemp2) / fTemp0 + 1.0f) + 2.0f * state->fRec0[1] * (1.0f - 1.0f / Reson_faustpower2_f(fTemp0))) / fTemp3;
            output0[i0] = FAUSTFLOAT((state->fRec0[2] + state->fRec0[0] + 2.0f * state->fRec0[1]) / fTemp3);
            state->fRec0[2] = state->fRec0[1];
            state->fRec0[1] = state->fRec0[0];
        }
    }

    void real_run() {
        input_samps = input->run(current_block);  // update input
        center_samps = center->run(current_block);  // update input
        q_samps = q->run(current_block);  // update input
        if (((input->flags) & TERMINATED) &&
            (flags & CAN_TERMINATE)) {
            terminate(ACTION_TERM);
        }
        Reson_state *state = &states[0];
        for (int i = 0; i < chans; i++) {
            (this->*run_channel)(state);
            state++;
            out_samps += BL;
            input_samps += input_stride;
            center_samps += center_stride;
            q_samps += q_stride;
        }
    }
};
#endif
