/* resonb -- unit generator for arco
 *
 * generated by f2a.py
 */

/*------------- BEGIN FAUST PREAMBLE -------------*/

/* ------------------------------------------------------------
name: "resonb"
Code generated with Faust 2.37.3 (https://faust.grame.fr)
Compilation options: -lang cpp -os0 -light -es 1 -single -ftz 0
------------------------------------------------------------ */

#ifndef  __Resonb_H__
#define  __Resonb_H__

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 

#include <algorithm>
#include <cmath>
#include <cstdint>
#include <math.h>

static float Resonb_faustpower2_f(float value) {
    return (value * value);
}

#ifndef FAUSTCLASS 
#define FAUSTCLASS Resonb
#endif

#ifdef __APPLE__ 
#define exp10f __exp10f
#define exp10 __exp10
#endif

#if defined(_WIN32)
#define RESTRICT __restrict
#else
#define RESTRICT __restrict__
#endif

#define FAUST_INT_CONTROLS 0
#define FAUST_REAL_CONTROLS 7
/*-------------- END FAUST PREAMBLE --------------*/

extern const char *Resonb_name;

class Resonb : public Ugen {
public:
    struct Resonb_state {
        float fRec0[3];
    };
    Vec<Resonb_state> states;
    void (Resonb::*run_channel)(Resonb_state *state);

    Ugen_ptr snd;
    int snd_stride;
    Sample_ptr snd_samps;

    Ugen_ptr center;
    int center_stride;
    Sample_ptr center_samps;

    Ugen_ptr q;
    int q_stride;
    Sample_ptr q_samps;

    float fConst0;

    Resonb(int id, int nchans, Ugen_ptr snd_, Ugen_ptr center_, Ugen_ptr q_) : Ugen(id, 'b', nchans) {
        snd = snd_;
        center = center_;
        q = q_;
        states.init(chans);
        fConst0 = (3.14159274f / std::min<float>(192000.0f, std::max<float>(1.0f, float(AR))));

        // initialize channel states
        for (int i = 0; i < chans; i++) {
            for (int l0 = 0; (l0 < 3); l0 = (l0 + 1)) {
                states[i].fRec0[l0] = 0.0f;
            }
        }

        init_snd(snd);
        init_center(center);
        init_q(q);
    }

    ~Resonb() {
        snd->unref();
        center->unref();
        q->unref();
    }

    const char *classname() { return Resonb_name; }

    void print_sources(int indent, bool print) {
        snd->print_tree(indent, print, "snd");
        center->print_tree(indent, print, "center");
        q->print_tree(indent, print, "q");
    }

    void repl_snd(Ugen_ptr inp) {
        snd->unref();
        init_snd(inp);
    }

    void repl_center(Ugen_ptr inp) {
        center->unref();
        init_center(inp);
    }

    void repl_q(Ugen_ptr inp) {
        q->unref();
        init_q(inp);
    }

    void set_snd(int chan, float f) {
        assert(snd->rate == 'c');
        snd->output[chan] = f;
    }

    void set_center(int chan, float f) {
        assert(center->rate == 'c');
        center->output[chan] = f;
    }

    void set_q(int chan, float f) {
        assert(q->rate == 'c');
        q->output[chan] = f;
    }

    void init_snd(Ugen_ptr ugen) { init_param(ugen, snd, snd_stride); }

    void init_center(Ugen_ptr ugen) { init_param(ugen, center, center_stride); }

    void init_q(Ugen_ptr ugen) { init_param(ugen, q, q_stride); }

    void real_run() {
        snd_samps = snd->run(current_block); // update input
        center_samps = center->run(current_block); // update input
        q_samps = q->run(current_block); // update input
        Resonb_state *state = &states[0];
        for (int i = 0; i < chans; i++) {
            state->fRec0[0] = (fControl[4] - (fControl[3] * ((fControl[5] * state->fRec0[2]) + (fControl[6] * state->fRec0[1]))));
            *out_samps = FAUSTFLOAT((fControl[3] * (state->fRec0[2] + (state->fRec0[0] + (2.0f * state->fRec0[1])))));
            state->fRec0[2] = state->fRec0[1];
            state->fRec0[1] = state->fRec0[0];
            state++;
            snd_samps += snd_stride;
            center_samps += center_stride;
            q_samps += q_stride;
        }
    }
};
#endif
