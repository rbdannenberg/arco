/* lowpass -- unit generator for arco
 *
 * generated by f2a.py
 */

/*------------- BEGIN FAUST PREAMBLE -------------*/

/* ------------------------------------------------------------
name: "lowpass"
Code generated with Faust 2.59.6 (https://faust.grame.fr)
Compilation options: -lang cpp -light -ct 1 -cn Lowpass -es 1 -mcd 16 -single -ftz 0
------------------------------------------------------------ */

#ifndef  __Lowpass_H__
#define  __Lowpass_H__

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 

#include <algorithm>
#include <cmath>
#include <cstdint>
#include <math.h>

#ifndef FAUSTCLASS 
#define FAUSTCLASS Lowpass
#endif

#ifdef __APPLE__ 
#define exp10f __exp10f
#define exp10 __exp10
#endif

#if defined(_WIN32)
#define RESTRICT __restrict
#else
#define RESTRICT __restrict__
#endif
/*-------------- END FAUST PREAMBLE --------------*/

extern const char *Lowpass_name;

class Lowpass : public Ugen {
public:
    struct Lowpass_state {
        FAUSTFLOAT fEntry0;
        float fVec0[2];
        float fRec0[2];
    };
    Vec<Lowpass_state> states;
    void (Lowpass::*run_channel)(Lowpass_state *state);

    Ugen_ptr snd;
    int snd_stride;
    Sample_ptr snd_samps;

    Ugen_ptr cutoff;
    int cutoff_stride;
    Sample_ptr cutoff_samps;

    float fConst0;

    Lowpass(int id, int nchans, Ugen_ptr snd_, Ugen_ptr cutoff_) :
            Ugen(id, 'a', nchans) {
        snd = snd_;
        cutoff = cutoff_;
        flags = CAN_TERMINATE;
        states.set_size(chans);
        fConst0 = 3.1415927f / std::min<float>(1.92e+05f, std::max<float>(1.0f, float(AR)));
        init_snd(snd);
        init_cutoff(cutoff);
        run_channel = (void (Lowpass::*)(Lowpass_state *)) 0;
        update_run_channel();
    }

    ~Lowpass() {
        snd->unref();
        cutoff->unref();
    }

    const char *classname() { return Lowpass_name; }

    void initialize_channel_states() {
        for (int i = 0; i < chans; i++) {
            for (int l0 = 0; l0 < 2; l0 = l0 + 1) {
                states[i].fVec0[l0] = 0.0f;
            }
            for (int l1 = 0; l1 < 2; l1 = l1 + 1) {
                states[i].fRec0[l1] = 0.0f;
            }
        }
    }

    void update_run_channel() {
        // initialize run_channel based on input types
        void (Lowpass::*new_run_channel)(Lowpass_state *state);
            if (snd->rate == 'b') {
                snd = new Upsample(-1, snd->chans, snd);
            }
            if (cutoff->rate == 'a') {
                new_run_channel = &Lowpass::chan_aa_a;
            } else {
                new_run_channel = &Lowpass::chan_ab_a;
            }
        if (new_run_channel != run_channel) {
            initialize_channel_states();
            run_channel = new_run_channel;
        }
    }

    void print_sources(int indent, bool print_flag) {
        snd->print_tree(indent, print_flag, "snd");
        cutoff->print_tree(indent, print_flag, "cutoff");
    }

    void repl_snd(Ugen_ptr ugen) {
        snd->unref();
        init_snd(ugen);
        update_run_channel();
    }

    void repl_cutoff(Ugen_ptr ugen) {
        cutoff->unref();
        init_cutoff(ugen);
        update_run_channel();
    }

    void set_snd(int chan, float f) {
        snd->const_set(chan, f, "Lowpass::set_snd");
    }

    void set_cutoff(int chan, float f) {
        cutoff->const_set(chan, f, "Lowpass::set_cutoff");
    }

    void init_snd(Ugen_ptr ugen) { init_param(ugen, snd, &snd_stride); }

    void init_cutoff(Ugen_ptr ugen) { init_param(ugen, cutoff, &cutoff_stride); }

    void chan_ab_a(Lowpass_state *state) {
        FAUSTFLOAT* input0 = snd_samps;
        FAUSTFLOAT* output0 = out_samps;
        float fSlow0 = 1.0f / std::tan(fConst0 * float(cutoff_samps[0]));
        float fSlow1 = 1.0f / (fSlow0 + 1.0f);
        float fSlow2 = 1.0f - fSlow0;
        for (int i0 = 0; i0 < BL; i0 = i0 + 1) {
            float fTemp0 = float(input0[i0]);
            state->fVec0[0] = fTemp0;
            state->fRec0[0] = 0.0f - fSlow1 * (fSlow2 * state->fRec0[1] - (fTemp0 + state->fVec0[1]));
            output0[i0] = FAUSTFLOAT(state->fRec0[0]);
            state->fVec0[1] = state->fVec0[0];
            state->fRec0[1] = state->fRec0[0];
        }
    }

    void chan_aa_a(Lowpass_state *state) {
        FAUSTFLOAT* input0 = snd_samps;
        FAUSTFLOAT* output0 = out_samps;
        float fSlow0 = 1.0f / std::tan(fConst0 * float(cutoff_samps[0]));
        float fSlow1 = 1.0f / (fSlow0 + 1.0f);
        float fSlow2 = 1.0f - fSlow0;
        for (int i0 = 0; i0 < BL; i0 = i0 + 1) {
            float fTemp0 = float(input0[i0]);
            state->fVec0[0] = fTemp0;
            state->fRec0[0] = 0.0f - fSlow1 * (fSlow2 * state->fRec0[1] - (fTemp0 + state->fVec0[1]));
            output0[i0] = FAUSTFLOAT(state->fRec0[0]);
            state->fVec0[1] = state->fVec0[0];
            state->fRec0[1] = state->fRec0[0];
        }
    }

    void real_run() {
        snd_samps = snd->run(current_block);  // update input
        cutoff_samps = cutoff->run(current_block);  // update input
        if (((snd->flags) & TERMINATED) &&
            (flags & CAN_TERMINATE)) {
            terminate();
        }
        Lowpass_state *state = &states[0];
        for (int i = 0; i < chans; i++) {
            (this->*run_channel)(state);
            state++;
            out_samps += BL;
            snd_samps += snd_stride;
            cutoff_samps += cutoff_stride;
        }
    }
};
#endif
