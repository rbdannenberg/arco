/* lowpassb -- unit generator for arco
 *
 * generated by f2a.py
 */

/*------------- BEGIN FAUST PREAMBLE -------------*/

/* ------------------------------------------------------------
name: "lowpassb"
Code generated with Faust 2.75.7 (https://faust.grame.fr)
Compilation options: -lang cpp -os -light -ct 1 -cn Lowpassb -es 1 -mcd 16 -mdd 1024 -mdy 33 -single -ftz 0
------------------------------------------------------------ */

#ifndef  __Lowpassb_H__
#define  __Lowpassb_H__

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 

#include <algorithm>
#include <cmath>
#include <cstdint>
#include <math.h>

#ifndef FAUSTCLASS 
#define FAUSTCLASS Lowpassb
#endif

#ifdef __APPLE__ 
#define exp10f __exp10f
#define exp10 __exp10
#endif

#if defined(_WIN32)
#define RESTRICT __restrict
#else
#define RESTRICT __restrict__
#endif
/*-------------- END FAUST PREAMBLE --------------*/

extern const char *Lowpassb_name;

class Lowpassb : public Ugen {
public:
    struct Lowpassb_state {
        FAUSTFLOAT fEntry0;
        FAUSTFLOAT fEntry1;
        float fVec0[2];
        float fRec0[2];
    };
    Vec<Lowpassb_state> states;
    void (Lowpassb::*run_channel)(Lowpassb_state *state);

    Ugen_ptr input;
    int input_stride;
    Sample_ptr input_samps;

    Ugen_ptr cutoff;
    int cutoff_stride;
    Sample_ptr cutoff_samps;

    float fConst0;

    Lowpassb(int id, int nchans, Ugen_ptr input_, Ugen_ptr cutoff_) :
            Ugen(id, 'b', nchans) {
        input = input_;
        cutoff = cutoff_;
        flags = CAN_TERMINATE;
        states.set_size(chans);
        fConst0 = 3.1415927f / std::min<float>(1.92e+05f, std::max<float>(1.0f, float(BR)));
        init_input(input);
        init_cutoff(cutoff);
    }

    ~Lowpassb() {
        input->unref();
        cutoff->unref();
    }

    const char *classname() { return Lowpassb_name; }

    void initialize_channel_states() {
        for (int i = 0; i < chans; i++) {
            for (int l0 = 0; l0 < 2; l0 = l0 + 1) {
                states[i].fVec0[l0] = 0.0f;
            }
            for (int l1 = 0; l1 < 2; l1 = l1 + 1) {
                states[i].fRec0[l1] = 0.0f;
            }
        }
    }

    void print_sources(int indent, bool print_flag) {
        input->print_tree(indent, print_flag, "input");
        cutoff->print_tree(indent, print_flag, "cutoff");
    }

    void repl_input(Ugen_ptr ugen) {
        input->unref();
        init_input(ugen);
    }

    void repl_cutoff(Ugen_ptr ugen) {
        cutoff->unref();
        init_cutoff(ugen);
    }

    void set_input(int chan, float f) {
        input->const_set(chan, f, "Lowpassb::set_input");
    }

    void set_cutoff(int chan, float f) {
        cutoff->const_set(chan, f, "Lowpassb::set_cutoff");
    }

    void init_input(Ugen_ptr ugen) { init_param(ugen, input, &input_stride); }

    void init_cutoff(Ugen_ptr ugen) { init_param(ugen, cutoff, &cutoff_stride); }

    void real_run() {
        input_samps = input->run(current_block);  // update input
        cutoff_samps = cutoff->run(current_block);  // update input
        if (((input->flags) & TERMINATED) &&
            (flags & CAN_TERMINATE)) {
            terminate();
        }
        Lowpassb_state *state = &states[0];
        for (int i = 0; i < chans; i++) {
            float fSlow0 = 1.0f / std::tan(fConst0 * float(cutoff_samps[0]));
            float fSlow1 = 1.0f / (fSlow0 + 1.0f);
            float fSlow2 = 1.0f - fSlow0;
            float fSlow3 = float(input_samps[0]);
            state->fVec0[0] = fSlow3;
            state->fRec0[0] = -(fSlow1 * (fSlow2 * state->fRec0[1] - (fSlow3 + state->fVec0[1])));
            out_samps[0] = FAUSTFLOAT(state->fRec0[0]);
            state->fVec0[1] = state->fVec0[0];
            state->fRec0[1] = state->fRec0[0];
    
            state++;
            out_samps++;
            input_samps += input_stride;
            cutoff_samps += cutoff_stride;
        }
    }
};
#endif
