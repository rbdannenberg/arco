/* noisegate -- unit generator for arco
 *
 * generated by f2a.py
 */

/*------------- BEGIN FAUST PREAMBLE -------------*/

/* ------------------------------------------------------------
name: "noisegate"
Code generated with Faust 2.75.7 (https://faust.grame.fr)
Compilation options: -lang cpp -light -ct 1 -cn Noisegate -es 1 -mcd 16 -mdd 1024 -mdy 33 -single -ftz 0
------------------------------------------------------------ */

#ifndef  __Noisegate_H__
#define  __Noisegate_H__

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 

#include <algorithm>
#include <cmath>
#include <cstdint>
#include <math.h>

#ifndef FAUSTCLASS 
#define FAUSTCLASS Noisegate
#endif

#ifdef __APPLE__ 
#define exp10f __exp10f
#define exp10 __exp10
#endif

#if defined(_WIN32)
#define RESTRICT __restrict
#else
#define RESTRICT __restrict__
#endif
/*-------------- END FAUST PREAMBLE --------------*/

extern const char *Noisegate_name;

class Noisegate : public Ugen {
public:
    struct Noisegate_state {
        FAUSTFLOAT fEntry0;
        FAUSTFLOAT fEntry1;
        float fRec1[2];
        FAUSTFLOAT fEntry2;
        int iVec0[2];
        FAUSTFLOAT fEntry3;
        int iRec2[2];
        float fRec0[2];
    };
    Vec<Noisegate_state> states;
    void (Noisegate::*run_channel)(Noisegate_state *state);

    Ugen_ptr input;
    int input_stride;
    Sample_ptr input_samps;

    Ugen_ptr threshold;
    int threshold_stride;
    Sample_ptr threshold_samps;

    Ugen_ptr attack;
    int attack_stride;
    Sample_ptr attack_samps;

    Ugen_ptr hold;
    int hold_stride;
    Sample_ptr hold_samps;

    Ugen_ptr release;
    int release_stride;
    Sample_ptr release_samps;

    float fConst0;
    float fConst1;

    Noisegate(int id, int nchans, Ugen_ptr input_, Ugen_ptr threshold_, Ugen_ptr attack_, Ugen_ptr hold_, Ugen_ptr release_) :
            Ugen(id, 'a', nchans) {
        input = input_;
        threshold = threshold_;
        attack = attack_;
        hold = hold_;
        release = release_;
        flags = CAN_TERMINATE;
        states.set_size(chans);
        fConst0 = std::min<float>(1.92e+05f, std::max<float>(1.0f, float(AR)));
        fConst1 = 1.0f / fConst0;
        init_input(input);
        init_threshold(threshold);
        init_attack(attack);
        init_hold(hold);
        init_release(release);
        run_channel = (void (Noisegate::*)(Noisegate_state *)) 0;
        update_run_channel();
    }

    ~Noisegate() {
        input->unref();
        threshold->unref();
        attack->unref();
        hold->unref();
        release->unref();
    }

    const char *classname() { return Noisegate_name; }

    void initialize_channel_states() {
        for (int i = 0; i < chans; i++) {
            for (int l0 = 0; l0 < 2; l0 = l0 + 1) {
                states[i].fRec1[l0] = 0.0f;
            }
            for (int l1 = 0; l1 < 2; l1 = l1 + 1) {
                states[i].iVec0[l1] = 0;
            }
            for (int l2 = 0; l2 < 2; l2 = l2 + 1) {
                states[i].iRec2[l2] = 0;
            }
            for (int l3 = 0; l3 < 2; l3 = l3 + 1) {
                states[i].fRec0[l3] = 0.0f;
            }
        }
    }

    void update_run_channel() {
        // initialize run_channel based on input types
        void (Noisegate::*new_run_channel)(Noisegate_state *state);
        if (input->rate == 'b') {
            input = new Upsample(-1, input->chans, input);
        }
        if (threshold->rate == 'a') {
            threshold = new Dnsampleb(-1, threshold->chans, threshold, LOWPASS500);
        }
        if (attack->rate == 'a') {
            attack = new Dnsampleb(-1, attack->chans, attack, LOWPASS500);
        }
        if (hold->rate == 'a') {
            hold = new Dnsampleb(-1, hold->chans, hold, LOWPASS500);
        }
        if (release->rate == 'a') {
            release = new Dnsampleb(-1, release->chans, release, LOWPASS500);
        }
        new_run_channel = &Noisegate::chan_abbbb_a;
        run_channel = new_run_channel;
    }

    void print_sources(int indent, bool print_flag) {
        input->print_tree(indent, print_flag, "input");
        threshold->print_tree(indent, print_flag, "threshold");
        attack->print_tree(indent, print_flag, "attack");
        hold->print_tree(indent, print_flag, "hold");
        release->print_tree(indent, print_flag, "release");
    }

    void repl_input(Ugen_ptr ugen) {
        input->unref();
        init_input(ugen);
        update_run_channel();
    }

    void repl_threshold(Ugen_ptr ugen) {
        threshold->unref();
        init_threshold(ugen);
        update_run_channel();
    }

    void repl_attack(Ugen_ptr ugen) {
        attack->unref();
        init_attack(ugen);
        update_run_channel();
    }

    void repl_hold(Ugen_ptr ugen) {
        hold->unref();
        init_hold(ugen);
        update_run_channel();
    }

    void repl_release(Ugen_ptr ugen) {
        release->unref();
        init_release(ugen);
        update_run_channel();
    }

    void set_input(int chan, float f) {
        input->const_set(chan, f, "Noisegate::set_input");
    }

    void set_threshold(int chan, float f) {
        threshold->const_set(chan, f, "Noisegate::set_threshold");
    }

    void set_attack(int chan, float f) {
        attack->const_set(chan, f, "Noisegate::set_attack");
    }

    void set_hold(int chan, float f) {
        hold->const_set(chan, f, "Noisegate::set_hold");
    }

    void set_release(int chan, float f) {
        release->const_set(chan, f, "Noisegate::set_release");
    }

    void init_input(Ugen_ptr ugen) { init_param(ugen, input, &input_stride); }

    void init_threshold(Ugen_ptr ugen) { init_param(ugen, threshold, &threshold_stride); }

    void init_attack(Ugen_ptr ugen) { init_param(ugen, attack, &attack_stride); }

    void init_hold(Ugen_ptr ugen) { init_param(ugen, hold, &hold_stride); }

    void init_release(Ugen_ptr ugen) { init_param(ugen, release, &release_stride); }

    void chan_abbbb_a(Noisegate_state *state) {
        FAUSTFLOAT* input0 = input_samps;
        FAUSTFLOAT* output0 = out_samps;
        float fSlow0 = float(attack_samps[0]);
        float fSlow1 = float(release_samps[0]);
        float fSlow2 = std::min<float>(fSlow0, fSlow1);
        int iSlow3 = std::fabs(fSlow2) < 1.1920929e-07f;
        float fSlow4 = ((iSlow3) ? 0.0f : std::exp(-(fConst1 / ((iSlow3) ? 1.0f : fSlow2))));
        float fSlow5 = 1.0f - fSlow4;
        float fSlow6 = std::pow(1e+01f, std::log10(std::max<float>(float(threshold_samps[0]), 1e-06f)));
        int iSlow7 = int(fConst0 * float(hold_samps[0]));
        int iSlow8 = std::fabs(fSlow1) < 1.1920929e-07f;
        float fSlow9 = ((iSlow8) ? 0.0f : std::exp(-(fConst1 / ((iSlow8) ? 1.0f : fSlow1))));
        int iSlow10 = std::fabs(fSlow0) < 1.1920929e-07f;
        float fSlow11 = ((iSlow10) ? 0.0f : std::exp(-(fConst1 / ((iSlow10) ? 1.0f : fSlow0))));
        for (int i0 = 0; i0 < BL; i0 = i0 + 1) {
            float fTemp0 = float(input0[i0]);
            state->fRec1[0] = fSlow5 * std::fabs(fTemp0) + state->fRec1[1] * fSlow4;
            int iTemp1 = state->fRec1[0] > fSlow6;
            state->iVec0[0] = iTemp1;
            state->iRec2[0] = std::max<int>(iSlow7 * (iTemp1 < state->iVec0[1]), state->iRec2[1] + -1);
            float fTemp2 = std::fabs(std::max<float>(float(iTemp1), float(state->iRec2[0] > 0)));
            float fTemp3 = ((fTemp2 > state->fRec0[1]) ? fSlow11 : fSlow9);
            state->fRec0[0] = fTemp2 * (1.0f - fTemp3) + state->fRec0[1] * fTemp3;
            output0[i0] = FAUSTFLOAT(state->fRec0[0] * fTemp0);
            state->fRec1[1] = state->fRec1[0];
            state->iVec0[1] = state->iVec0[0];
            state->iRec2[1] = state->iRec2[0];
            state->fRec0[1] = state->fRec0[0];
        }
    }

    void real_run() {
        input_samps = input->run(current_block);  // update input
        threshold_samps = threshold->run(current_block);  // update input
        attack_samps = attack->run(current_block);  // update input
        hold_samps = hold->run(current_block);  // update input
        release_samps = release->run(current_block);  // update input
        Noisegate_state *state = states.get_array();
        for (int i = 0; i < chans; i++) {
            (this->*run_channel)(state);
            state++;
            out_samps += BL;
            input_samps += input_stride;
            threshold_samps += threshold_stride;
            attack_samps += attack_stride;
            hold_samps += hold_stride;
            release_samps += release_stride;
        }
    }
};
#endif
