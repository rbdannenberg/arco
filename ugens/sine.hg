/* sine -- unit generator for arco */
 *
 * generated by f2a.py
 */

class Sine : public Ugen {
public:
    struct Sine_state {
        float fRec1[2];
    };
    Vec<Sine_state> states;

    Ugen_ptr freq;
    int freq_stride;
    Sample_ptr freq_samps;

    Ugen_ptr amp;
    int amp_stride;
    Sample_ptr amp_samps;

    Sine(int id, int nchans, int f, int a) : Ugen(id, 'a', nchans) {
        init_freq(ugen_table[freq]);
        init_amp(ugen_table[amp]);
        states.init(chans * BL);
        for (int i = 0; i < chans; i++) {
            for (int l2 = 0; (l2 < 2); l2 = (l2 + 1)) {
                state[i].fRec1[l2] = 0.0f;
            }
        }
    };

    ~Sine() {
        freq->unref();
        amp->unref();
    };

    const char *name() { return "Sine"; }

    void print_sources(int indent, bool print0 {
        freq->print_tree(indent, print, "freq");
        amp->print_tree(indent, print, "amp");
    };

    void repl_freq(Ugen_ptr inp) {
        freq->unref();
        init_freq(inp);
    };

    void repl_amp(Ugen_ptr inp) {
        amp->unref();
        init_amp(inp);
    };

    void set_freq(int chan, float f) {
        assert(freq->rate == 'c');
        freq->output[chan] = f
    };

    void set_amp(int chan, float f) {
        assert(amp->rate == 'c');
        amp->output[chan] = f
    };

    void init_freq(Ugen_ptr ugen) { init_parm(ugen, freq, freq_stride); }

    void init_amp(Ugen_ptr ugen) { init_parm(ugen, amp, amp_stride); }

    static void class_init() {
        SineSIG0* sig0 = newSineSIG0();
        sig0->instanceInitSineSIG0(AR);
        sig0->fillSineSIG0(65536, ftbl0SineSIG0);
        deleteSineSIG0(sig0);
    }

    void chan_bb_a(Sine_state *state) {
        FAUSTFLOAT* output0 = out_samps;
        float fSlow0 = float(*amp_samps);
        float amp_incr = (fSlow0 - state->amp_prev) * BL_RECIP;
        float fSlow1 = (fConst0 * float(*freq_samps));
        for (int i0 = 0; (i0 < count); i0 = (i0 + 1)) {
            state->amp_prev += amp_incr;
            state->fRec1[0] = (fSlow1 + (state->fRec1[1] -
                                      std::floor((fSlow1 + state->fRec1[1]))));
            output0[i0] = FAUSTFLOAT((state->amp_prev *
                            ftbl0SineSIG0[int((65536.0f * state->fRec1[0]))]));
            state->fRec1[1] = state->fRec1[0];
        }
        
    }

    void chan_aa_a(Sine_state *state) {
        FAUSTFLOAT* input0 = *freq_samps;
        FAUSTFLOAT* input1 = *amp_samps;
        FAUSTFLOAT* output0 = out_samps;
        for (int i0 = 0; (i0 < count); i0 = (i0 + 1)) {
            float fTemp0 = (state->fRec1[1] + (fConst0 * float(input0[i0])));
            state->fRec1[0] = (fTemp0 - std::floor(fTemp0));
            output0[i0] = FAUSTFLOAT((float(input1[i0]) * ftbl0SineSIG0[int((65536.0f * state->fRec1[0]))]));
            state->fRec1[1] = state->fRec1[0];
        }
    }

    void real_run() {
        freq_samps = freq->run(block_count); // update input
        amp_samps = amp->run(block_count); // update input
        Sine_state *state = &states[0];
        for (int i = 0; i < chans; i++) {
            (this->*run_channel)(state);
            state++;
            freq_samps += freq_stride;
            amp_samps += amp_stride;
        };
    };
};
