/* overdrive -- unit generator for arco
 *
 * generated by f2a.py
 */

/*------------- BEGIN FAUST PREAMBLE -------------*/

/* ------------------------------------------------------------
name: "overdrive"
Code generated with Faust 2.75.7 (https://faust.grame.fr)
Compilation options: -lang cpp -light -ct 1 -cn Overdrive -es 1 -mcd 16 -mdd 1024 -mdy 33 -single -ftz 0
------------------------------------------------------------ */

#ifndef  __Overdrive_H__
#define  __Overdrive_H__

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 

#include <algorithm>
#include <cmath>
#include <cstdint>
#include <math.h>

#ifndef FAUSTCLASS 
#define FAUSTCLASS Overdrive
#endif

#ifdef __APPLE__ 
#define exp10f __exp10f
#define exp10 __exp10
#endif

#if defined(_WIN32)
#define RESTRICT __restrict
#else
#define RESTRICT __restrict__
#endif

static float Overdrive_faustpower2_f(float value) {
    return value * value;
}
/*-------------- END FAUST PREAMBLE --------------*/

extern const char *Overdrive_name;

class Overdrive : public Ugen {
public:
    struct Overdrive_state {
        FAUSTFLOAT fEntry0;
        FAUSTFLOAT fEntry1;
        FAUSTFLOAT fEntry2;
        float fVec0[2];
        float fRec1[2];
        float fVec1[2];
        float fRec0[2];
    };
    Vec<Overdrive_state> states;
    void (Overdrive::*run_channel)(Overdrive_state *state);

    Ugen_ptr snd;
    int snd_stride;
    Sample_ptr snd_samps;

    Ugen_ptr gain;
    int gain_stride;
    Sample_ptr gain_samps;

    Ugen_ptr tone;
    int tone_stride;
    Sample_ptr tone_samps;

    Ugen_ptr volume;
    int volume_stride;
    Sample_ptr volume_samps;

    float fConst0;
    float fConst1;
    float fConst2;
    float fConst3;
    float fConst4;

    Overdrive(int id, Ugen_ptr snd_, Ugen_ptr gain_, Ugen_ptr tone_, Ugen_ptr volume_) :
            Ugen(id, 'a', 2) {
        snd = snd_;
        gain = gain_;
        tone = tone_;
        volume = volume_;
        flags = CAN_TERMINATE;
        states.set_size(chans);
        fConst0 = std::min<float>(1.92e+05f, std::max<float>(1.0f, float(AR)));
        fConst1 = 3.1415927f / fConst0;
        fConst2 = 1.0f / std::tan(2261.9468f / fConst0);
        fConst3 = 1.0f / (fConst2 + 1.0f);
        fConst4 = 1.0f - fConst2;
        init_snd(snd);
        init_gain(gain);
        init_tone(tone);
        init_volume(volume);
        run_channel = (void (Overdrive::*)(Overdrive_state *)) 0;
        update_run_channel();
    }

    ~Overdrive() {
        snd->unref();
        gain->unref();
        tone->unref();
        volume->unref();
    }

    const char *classname() { return Overdrive_name; }

    void initialize_channel_states() {
        for (int i = 0; i < chans; i++) {
            for (int l0 = 0; l0 < 2; l0 = l0 + 1) {
                states[i].fVec0[l0] = 0.0f;
            }
            for (int l1 = 0; l1 < 2; l1 = l1 + 1) {
                states[i].fRec1[l1] = 0.0f;
            }
            for (int l2 = 0; l2 < 2; l2 = l2 + 1) {
                states[i].fVec1[l2] = 0.0f;
            }
            for (int l3 = 0; l3 < 2; l3 = l3 + 1) {
                states[i].fRec0[l3] = 0.0f;
            }
        }
    }

    void update_run_channel() {
        // initialize run_channel based on input types
        void (Overdrive::*new_run_channel)(Overdrive_state *state);
        if (snd->rate == 'b') {
            snd = new Upsample(-1, snd->chans, snd);
        }
        if (gain->rate == 'a') {
            gain = new Dnsampleb(-1, gain->chans, gain, LOWPASS500);
        }
        if (tone->rate == 'a') {
            tone = new Dnsampleb(-1, tone->chans, tone, LOWPASS500);
        }
        if (volume->rate == 'a') {
            volume = new Dnsampleb(-1, volume->chans, volume, LOWPASS500);
        }
        new_run_channel = &Overdrive::chan_abbb_a;
        run_channel = new_run_channel;
    }

    void print_sources(int indent, bool print_flag) {
        snd->print_tree(indent, print_flag, "snd");
        gain->print_tree(indent, print_flag, "gain");
        tone->print_tree(indent, print_flag, "tone");
        volume->print_tree(indent, print_flag, "volume");
    }

    void repl_snd(Ugen_ptr ugen) {
        snd->unref();
        init_snd(ugen);
        update_run_channel();
    }

    void repl_gain(Ugen_ptr ugen) {
        gain->unref();
        init_gain(ugen);
        update_run_channel();
    }

    void repl_tone(Ugen_ptr ugen) {
        tone->unref();
        init_tone(ugen);
        update_run_channel();
    }

    void repl_volume(Ugen_ptr ugen) {
        volume->unref();
        init_volume(ugen);
        update_run_channel();
    }

    void set_snd(int chan, float f) {
        snd->const_set(chan, f, "Overdrive::set_snd");
    }

    void set_gain(int chan, float f) {
        gain->const_set(chan, f, "Overdrive::set_gain");
    }

    void set_tone(int chan, float f) {
        tone->const_set(chan, f, "Overdrive::set_tone");
    }

    void set_volume(int chan, float f) {
        volume->const_set(chan, f, "Overdrive::set_volume");
    }

    void init_snd(Ugen_ptr ugen) { init_param(ugen, snd, &snd_stride); }

    void init_gain(Ugen_ptr ugen) { init_param(ugen, gain, NULL); }

    void init_tone(Ugen_ptr ugen) { init_param(ugen, tone, NULL); }

    void init_volume(Ugen_ptr ugen) { init_param(ugen, volume, NULL); }

    void chan_abbb_a(Overdrive_state *state) {
        FAUSTFLOAT* input0 = snd_samps;
        FAUSTFLOAT* input1 = snd_samps + snd_stride;
        FAUSTFLOAT* output0 = out_samps;
        FAUSTFLOAT* output1 = out_samps + BL;
        float fSlow0 = std::pow(1e+01f, 2.0f * (float(volume_samps[0]) + -1.0f));
        float fSlow1 = 1.0f / std::tan(fConst1 * (4.15e+03f * float(tone_samps[0]) + 3.5e+02f));
        float fSlow2 = 1.0f / (fSlow1 + 1.0f);
        float fSlow3 = 1.0f - fSlow1;
        float fSlow4 = std::pow(1e+01f, 2.0f * float(gain_samps[0]));
        for (int i0 = 0; i0 < BL; i0 = i0 + 1) {
            float fTemp0 = float(input0[i0]) + float(input1[i0]);
            state->fVec0[0] = fTemp0;
            state->fRec1[0] = -(fConst3 * (fConst4 * state->fRec1[1] - fConst2 * (fTemp0 - state->fVec0[1])));
            float fTemp1 = std::max<float>(-1.0f, std::min<float>(1.0f, fSlow4 * state->fRec1[0]));
            float fTemp2 = fTemp1 * (1.0f - 0.33333334f * Overdrive_faustpower2_f(fTemp1));
            state->fVec1[0] = fTemp2;
            state->fRec0[0] = -(fSlow2 * (fSlow3 * state->fRec0[1] - (fTemp2 + state->fVec1[1])));
            float fTemp3 = fSlow0 * state->fRec0[0];
            output0[i0] = FAUSTFLOAT(fTemp3);
            output1[i0] = FAUSTFLOAT(fTemp3);
            state->fVec0[1] = state->fVec0[0];
            state->fRec1[1] = state->fRec1[0];
            state->fVec1[1] = state->fVec1[0];
            state->fRec0[1] = state->fRec0[0];
        }
    }

    void real_run() {
        snd_samps = snd->run(current_block);  // update input
        gain_samps = gain->run(current_block);  // update input
        tone_samps = tone->run(current_block);  // update input
        volume_samps = volume->run(current_block);  // update input
        Overdrive_state *state = &states[0];
        (this->*run_channel)(state);
    }
};
#endif
