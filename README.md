# arco4 - sound synthesis engine and framework

## Roger B. Dannenberg
reorganized April 2022, linux port May 2022

See design.md for technical design discussions/plans

## Contents
- Directories
- Dependencies
- CMake Overview
- Installation on Ubuntu Linux
- Unit Generators

## Directories
- apps -- applications where you can build customized versions of Arco servers with or without Serpent.
- arco -- the Arco main synthesis engine code
- preproc -- preprocessors written in Python to translate Arco's .ugen files, which add some annotations to FAUST source, into to FAUST .dsp files. Also runs FAUST, manipulates the output to create Arco unit generators.
- serpent -- shared code for building Serpent interpreter combined with Arco synthesis engine running in separate thread with an O2 shared memory interface.
- server -- builds a command-line application acting as an O2 server with
Arco synthesis engine running in a separater thread with an O2 shared memory interface. This should really just contain the shared code, and actual server instances should be built in the apps directory so that they can have custom code.
- ugens -- Arco unit generators implemented in .ugen files and translated by a combination of FAUST and preprocessors to Arco unit generators.

## Dependencies
- SNDFILE_LIB is from libsndfile
- OGGLIB is OGG library used by libsndfile
- FLACLIB is FLAC library used by libsndfile
- VORBIS_LIB and VORBISENC_LIB libraries used by libsndfile
- PORTAUDIO_LIB is PortAudio library
- O2_DBG_LIB and O2_OPT_LIB are O2 library
- WxWidgets is used by wxserpent

## CMake Overview

To build Arco, you need some other programs: O2, PortAudio, PortMidi, and
Serpent. You also need some libraries, described below.

Some things you *have* to build from sources. Others you may be able
to find precompiled and install them. The things you *have* to
install, should all be in the same directory (I use my home directory,
so I have /home/rbd/o2, /home/rbd/portaudio, /home/rbd/portmidi,
/home/rbd/serpent, and /home/rbd/arco4.) The directory names `o2`,
`portaudio`, `portmidi`, and `serpent` must be lower case and spelled
the same so that Arco CMake files can find them.

This directory with the Arco repo clone can be named anything (I
currently call it arco4), so we'll call it `ARCODIR` in the instructions
that follow.

Master CMakeLists.txt is in ARCODIR/apps/*, e.g. see ARCODIR/apps/test/CMakeLists.txt which builds a Serpent application
with Arco embedded. It includes:
- ARCODIR/apps/test/CMakeLists.txt
  - ARCODIR/serpent/arco4.cmakeinclude, which includes
    - ARCODIR/arco/CMakeLists.txt to build arco (mostly dsp) library
    - serpent/wxs/wxs.cmakeinclude to build wxserpent
      - serpent/src/CMakeLists.txt to build srplib library for wxserpent

Similarly, we have ARCODIR/apps/basic/CMakeLists.txt to build a
stand-alone Arco server. It includes:
- ARCODIR/apps/basic/CMakeLists.txt
  - ARCODIR/server/CMakeLists.txt, which includes
    - ARCODIR/arco/CMakeLists.txt to build arco (mostly dsp) library

To customize the set of unit generators in Arco applications,
`ARCODIR/arco/` contains `dspsources.cmakeinclude` which depends on
`dspmanifest.txt` in the same directory. `dspsources.cmakeinclude`
is created by `makedspmakefile.py`, which also creates `dspmakefile`.  `makedspmakefile.py` is run when CMake generates the project.
To make sure sources are in place, building the project first
runs `make` on `dspmakefile`, which is responsible for creating `.h`
and `.cpp` source files referenced in `dspsources.cmakeinclude`. The
source files are generated by a sequence of scripts, starting with
`u2f.py` to create FAUST programs from Arco's unit generator
description files, then running `f2a.py` to convert FAUST source files
to Arco source files, and finally building O2 interfaces by running
`o2idc.py`.

We build a separate library for each application because
the application includes the entire library (as opposed to including
only the referenced functions. That is because the functions are put
into the O2 method table at runtime when each unit generator runs its
initialization code, which the linker does know about.

## Installation on Ubuntu Linux

These instructions are not the only possible installation procedure,
but they describe what I did.

- if you don't have CMake (`ccmake` is the command line program), see https://askubuntu.com/questions/355565/how-do-i-install-the-latest-version-of-cmake-from-the-command-line
- clone and build serpent from SourceForge (serpent project: https://sourceforge.net/projects/serpent, see serpent/doc/ for installation guides -- I have not gotten wxWidgets to work without building from sources using the command lines in the guides)
- clone and build o2 from github.com/rbdannenberg/
- clone github.com/rbdannenberg/arco. My cloned repo is in
  arco4, but we'll call it ARCODIR (see note above).
- install portaudio (on Linux: libportaudio19-dev)
- install Avahi (on Linux: lib-avahi-client-dev)
- install libsndfile (note: on Ubuntu 20, the libsndfile1-dev install will not
     be usable unless you figure out how to link to log_finite and a bunch of
     other symbols. These come from vorbis, a dependency of libsndfile.
     Therefore, I compiled my own.)
  - get v1.1.0 Source code (zip) from
      https://github.com/libsndfile/libsndfile/releases
  - extract to the same directory containing ARCODIR (e.g. your home directory)
  - `mv libsndfile-1.1.0 to libsndfile`
  - `cd libsndfile`
  - `ccmake .`
  - configure (type `c` then `e`)
  - set BUILD_EXAMPLES=OFF, BUILD_PROGRAMS=OFF,CMAKE_BUILD_TYPE=DEBUG
  - set INSTALL_MANPAGES=OFF, ENABLE_EXTERNAL_LIBS=OFF (this eliminates
      the vorbis problem)
  - configure with new settings (type `c`)
  - generate (type `g`) (this should quit cmake and return to shell)
  - `make`
  - you should end up with libsndfile.a in your current directory
- cd ARCODIR/apps/test
- ccmake .
- Use ccmake's `c` (configure) command to process files and offer
  options to set. Then set them as follows:
  - set CMAKE_BUILD_TYPE = Debug
  - set HAVE_WX_PACKAGE = OFF
  - set USE_GLCANVAS = ON
  - set USE_MIDI = ON
  - set USE_NETWORK = ON
  - set USE_STATIC_LIBS = ON
  - leave OFF: USE_PROC, USE_SHFILE, USE_ZEROMQ, WXS_STDOUT_WINDOW
  - set WX_BASE_PATH to your top wxWidgets path, e.g. /home/rbd/wxWidgets; there should be wx-build inside this directory
- Use ccmake's `c` (configure) and `g` (generate) commands to create a Makefile (or Xcode project)
- make (or build with Xcode)
- `source ../common/setpath.sh` to set SERPENTPATH (must be done once unless you switch or restart Terminal)
- ./daserpent (on Linux) or Debug/daserpent.app/Contents/MacOS/daserpent (on MacOS)
- run the program: `./daserpent` (for "digital audio serpent")
- you should see a list of audio devices in some text like this:
```
O2 message: calling host_openaggr to handle /host/openaggr
0 - ALSA : HDA Intel HDMI: 0 (hw:0,3) (0 ins, 8 outs)
O2 message: calling host_openaggr to handle /host/openaggr
1 - ALSA : HDA Intel HDMI: 1 (hw:0,7) (0 ins, 8 outs)
O2 message: calling host_openaggr to handle /host/openaggr
...
```
and somewhere, a message like: `--> opening this device, id 5`. If not,
find the device you want to open, find a unique substring, and modify
the serpent line in init.srp:
```
    if find(info, "Aggregate") >= 0 or find(info, "Analog") >= 0:
```
As of this writing, this hack wires in a search for the desired device,
which is the Aggregate device on MacOS (so you have to create an
Aggregate device in Audio Midi Setup), or the Analog device on Linux.
You can change either of these, but it's better to just insert
another test case for another string. Ultimately, the plan was to
gather the devices, build a menu, let the user choose a device, and
save the device in preferences.
- You should hear smooth electronic tones with random pitch and random timing.

# Unit Generators
## General Design
### Unit Generators and Multi-Channel

Every UG has:
- `rate`: `'a'`, `'b'`, or `'c'`
- `chans`: number of channels
- `block`: block count, intially -1. Updated to current block number by `run(block)`
- `output`: a vector of Samples. 
  - A-rate output has one audio block per channel, flattened to an array of length `chans * BLOCK_LEN`. 
  - B-rate output has `chans` samples.
- `states`: a vector of `chans` structures, where each structure contains all
   the state for one channel of the unit generator
- *C-rate parameters*: for each C-rate parameter, there is a vector of 
  length `chans` to store it.
- *A-rate/B-rate parameters*: for each A- or B-rate parameter, there is a source pointer of type `Ugen *` and a pointer to the Ugen's output vector.

Computation basically involves a loop to compute each channel while updating input
and output pointers.

Inputs must have either 1 channel or the same number of channels as the Ugen. If 1 channel, the same channel is used for each channel of the Ugen.
- audio rate input
  - 1 channel: *param*_stride = -BL
  - *n* channel: *param*_stride = 0 // next channel is where previous one ends
- block rate input
  - 1 channel: *param*_stride = 0
  - *n* channel: *param*_stride = 1 // 1 sample per channel
- constant rate input
  - 1 channel: *param*_stride = 0
  - *n* channel: *param*_stride = 1 // 1 sample per channel

### Messages
Every Unit Generator is reference counted and shadowed by the creator.

Each class of Ugen has a top-level node in the address space, and each
parameter is a sub-node. Most messages take an ID as a parameter to identify the ugen instance. This avoids updating the addresses with many entries when we add a ugen instance. We could route all messages to one place and decode without using O2 address mapping, e.g. the object ID could be in the address and we could use the ID as an index to find the object, but it's easier to use O2 address decoding and message dispatching to specific handlers, and passing the ID as parameter is a bit easier than using string manipulation to put the ID into the address string.
````
/arco/fmosc/freq
````

So IDs are passed as parameters and decoded with a simple array lookup. We
require the controlling process manage the IDs's.

To create a Ugen:
````
/arco/fmosc/new ID chans input1 input2 ...
````
where inputs are ID's for other UGens or 0 for C-rate input (to be followed by a message to initialize the values).

To release a Ugen, free the ID, but the ugen is actually deleted only when all references to it are deleted. When a Ugen is deleted, its references are also deleted, which may cause other Ugens to be deleted.
````
/arco/free ID
````

To change a parameter, there are two possibilities. A constant (a Ugen of class Const)
can be updated with a new value. A constant can have multiple channels (so it can be
seen as a vector of floats), so the update includes a channel. You can update a
constant directly using:
```
/arco/const/set ID chan float
```
But you can also free the Const Ugen after it has been assigned as the input to
some other Ugen. Since the refcount is greater than 1, releasing the ID does not
delete the constant, and some Ugen holds the reference. But every Ugen has
commands to follow the reference to the Const object and set a value:
````
/arco/fmosc/set_freq ID chan float
````
This message only works if the current input is a Const and is recommended because the client can free its direct reference to the Const object. Also, it seems more direct to set an *input* parameter of the ugen as opposed to an *output* parameter of a Const.

However, if the Const is shared by other ugens, setting the *input* of one of those ugens changes the input of other ugens. In that case, it is better to treat the Const object as a shared variable and set the Const object directly.

If the current input is A-rate or B-rate, you can *replace* the input
(and also unref the current one) by using a replace command:
```
/arco/fmosc/repl_freq ID freqID
```
where freqID is the ID of the replacement input.

## mult
`/arco/mult/new id chans x1 x2` - Create a new multiplier.

`/arco/mult/repl_x1 id x1_id` - Set input x1 to object with id `x1_id`.

`/arco/mult/set_x1 id chan x1` - Set channel `chan` of input to float value `x1`.

`/arco/mult/repl_x2 id x2_id` - Set input x2 to object with id `x2_id`.

`/arco/mult/set_x2 id chan x2` - Set channel `chan` of input to float value `x2`.

## mix
`/arco/mix/new id chans` - Create a new mixer with `chans` output channels.

`/arco/mix/ins id input gain` - Insert an input to the mixer.

`/arco/mix/rem id input` - Remove an input from the mixer.

`/arco/repl_gain id inp gain_id` - Set the gain for input `inp` to
object with id `gain_id`.

`/arco/set_gain id inp gain` - Set the gain for input `inp` to the
float value `gain`.


## sine
`/arco/sine/new id chans freq amp` - Create a new sine oscillator.

`/arco/sine/repl_freq id freq_id' - Set frequency to object with id `freq_id`.

`/arco/sine/set_freq id chan freq` - Set frequency of channel `chan` to 
float value `freq`.

`/arco/sine/repl_amp id amp_id' - Set amplitude to object with id `freq_id`.

`/arco/sine/set_amp id chan amp` - Set amplitude of channel `chan` to 
float value `amp`.

## pwl
`/arco/pwl/new id` - Create a new piece-wise linear generator with audio output. `id` is the object id.

`/arco/pwl/env id d0 y0 d1 y1 ... dn-1 [yn-1]` - set the envelope or function shape for object with id. All remaining parameters are floats, alternating segment durations (in samples) and segment final values. The envelope starts at the current output value and ends at yn-1 (defaults to 0).

`/arco/pwl/start id` - starts object with id.

`/arco/pwl/decay id dur` - decay from the current value of object with id to zero in `dur` samples.

## delay
`/arco/delay/new id chans inp dur fb maxdur` - Create a new delay generator with audio input and output. `id` is the object id. `maxdur` is the maximum duration (this much space is allocated).

`/arco/delay/set_max id dur` - Reallocates delay memory for a maximum duration of `dur`.

`/arco/delay/repl_dur id dur_id` - Set duration input to object with id `dur_id`.

`/arco/delay/set_dur id dur` - Set duration to a float value `dur`.

`/arco/delay/repl_fb id fb_id` - Set feedback to object with id `fb_id`.

`/arco/delay/set_fb id fb` - Set feedback to float value `fb`.


## reson
`/arco/reson/new id chans center bandwidth` - Create a new reson filte with `center` frequency and `bandwidth` control inputs, audio input and audio output.

`/arco/reson/repl_center id center_id` - Set center frequency to object with id `center_id`.

`/arco/reson/set_center id chan center_id` - Set center frequency of channel
`chan` to float value `center_id`.

`/arco/reson/repl_bandwidth id bandwidth_id` - Set bandwidth to object with id `bandwidth_id`.

`/arco/reson/set_bandwidth id chan bandwidth_id` - Set bandwidth of channel
`chan` to float value `bandwidth_id`.

