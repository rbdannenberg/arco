# faust to Arco translation
#
# Roger B. Dannenberg
# Jan 2022

"""
Assumes you have a Faust source files, e.g., sine_aa_a.dsp,
which is all audio parameters and output.  If there are no 
parameters, append an underscore anyway, e.g. 
"whitenoise__a.dsp" has zero inputs and one output.

Pass the lower-cased class name on the command line, e.g. 
"py f2a.py sine".

Underscores are not allowed in the main unit generator name.
Everything after the first "_" is called the *signature* and 
is not part of the class name.

The program will search for sine_*.dsp with different combinations of 
input rates, e.g. sine_ba_a.dsp would take a block-rate (or constant)
and an audio-rate and produce an audio-rate. You can add as many 
combinations as you want, but due to the exponential growth of 
combinations, e.g. aaaa, aaab, aaba, aabb, abaa, ..., it is allowed
for the list to be incomplete. At runtime, when a Ugen is instantiated,
either all inputs are b-rate or c-rate and the output is b-rate, or 
Arco will upsample *every* non-initializer input if a perfect match
is not found.

A parameter may be for initialization only, e.g. the initial phase
of an oscillator. These parameters are marked with "c", and if a
parameter is marked "c" for one .dsp file, it should be "c" in all.

Unit generators are either a-rate or b-rate, but not both. To
indicate the fixed output type, append "_a" or "_b" to the file name,
e.g. "sine_aa_a.dsp" or "lfo_bb_b.dsp".  In the case of b-rate-only
output, there should only be one .dsp file, e.g. "lfo_bb_b.dsp" or
"lfo_bc_b.dsp".  To get a choice of output rates, you must make
two Ugen classes, e.g. Sine and Lfo.  The output rate is a class
property.

If the output is "a", there should be one file with no "b" in the 
signature, and there may be other files where one or more "a" inputs
are changed to "b".

If the output is "b", there should be only one .dsp file for the
class, and it should have no "a" inputs.

Summary of input types:
---------------------------------------------
Signature................ a     b        c
Rate required by input... a     b or c   c
Update method generated.. yes   yes      no
---------------------------------------------
Note that only one type has a "c-rate" output, and that is a
Const unit generator, which can be updated *before* providing
it as input to a c-rate input of another Ugen.

The main .dsp file is translated twice using:
    faust -light -cn Sine sine_aa_a.dsp -o sine_aa_a.fh
The first creates an audio rate inner loop. The second is block-rate
("one sample" or -os in Faust terminology) used for block-rate output.
Others are processed once using something like:
    faust -light -cn Sine sine_ab.dsp -o sine_ab_a.fh

Faust keeps track of parameters but does not put them in a specific
order. The main (at least) .dsp file should have a declaration like:
    declare description "Sine(amp, freq) - Sine Ugen for Arco"
where parameters are named in order, and anything after the parameter
list is ignored to allow for a description.

Any b-rate (also serving as c-rate) input should be defined like this:
    freq = nentry("freq", 440, 1, 10000, 1);
The quoted name should match the parameter name.

Faust parameter interpolation is either a first-order filter or a
sample-rate algorithm that allocates a 64K-sample delay line just
to look back one block-length, but the whole point of interpolation
is to keep everything in registers in the inner loop. f2a.py will
insert fast, compact linear interpolation if you declare a b-rate
parameter as interpolated using:
    declare interpolated "amp";
or in general:
    declare interpolated "p1, p2, p3"; // commas are optional
"""

# TODO: 
#       add channel methods
#       convert interpolated variables
#       make b-rate variables into Arco inputs
#       make initialization constants only update at intialization

import os
import sys
import glob
from pathlib import Path

def generate_arco_cpp(classname, param_info, rate, outf):
    global fsrc, initializer_code
    print("/*", classname.lower(),  "-- unit generator for arco", file=outf)
    print(" *\n * generated by f2a.py\n */\n", file=outf)
    print('#include "arcougen.h"', file=outf)
    cnlc = classname.lower()
    print('#include "' + cnlc + '.h"\n', file=outf)
    print("const char *" + classname + '_name = "' + classname + '";\n',
          file=outf)

    inputs = ""
    for p in param_info:
        inputs += ", int32 " + p[0]
    print("/* O2SM INTERFACE: /arco/" + cnlc + "/new",
          "int32 id, int32 chans" + inputs + ";\n */", file=outf)
    print("void arco_" + cnlc + "_new(O2SM_HANDLER_ARGS)\n{", file=outf)
    print("    // begin unpack message (machine-generated):", file=outf)
    print("    // end unpack message\n", file=outf)
    parameters = ""
    for p in param_info:
        print("    ANY_UGEN_FROM_ID(" + p[0] + "_ugen," + p[0] + ",",
              '"arco_' + cnlc + '_new");', file=outf)
        parameters += ", " + p[0] + "_ugen"
    print("\n    new", classname + "(id, chans" + parameters + ");", file=outf)
    print("}\n\n", file=outf)
    
    for p in param_info:
        print("/* O2SM INTERFACE: /arco/" + cnlc + "/repl_" + p[0],
              "int32 id, int32", p[0] + "_id;\n */", file=outf)
        print('static void arco_' + cnlc + '_repl_' + p[0] +
              '(O2SM_HANDLER_ARGS)\n{', file=outf)
        print("    // begin unpack message (machine-generated):", file=outf)
        print("    // end unpack message\n", file=outf)
        
        print("    UGEN_FROM_ID(" + classname + ",", cnlc + ", id,",
              '"arco_' + cnlc + '_repl_' + p[0] + '");', file=outf)
        print("    ANY_UGEN_FROM_ID(" + p[0] + ",", p[0] + "_id,",
              '"arco_' + cnlc + '_repl_' + p[0] + '");', file=outf)
        print("    " + cnlc + "->repl_" + p[0] + "(" + p[0] + ");\n}\n\n",
              file=outf)

        print("/* O2SM INTERFACE: /arco/" + cnlc + "/set_" + p[0],
              "int32 id, int32 chan, float val;\n */", file=outf)
        print('static void arco_' + cnlc + '_set_' + p[0] +
              '(O2SM_HANDLER_ARGS)\n{', file=outf)
        print("    // begin unpack message (machine-generated):", file=outf)
        print("    // end unpack message\n", file=outf)
        print("    UGEN_FROM_ID(" + classname + ",", cnlc + ", id,",
              '"arco_' + cnlc + '_repl_' + p[0] + '");', file=outf)
        print("    " + cnlc + "->set_" + p[0] + "(chan, val);\n}\n\n",
              file=outf)

    print("static void", cnlc + "_init()\n{", file=outf)
    print("    // O2SM INTERFACE INITIALIZATION: (machine generated)",
          file=outf)
    print('    o2sm_method_new("/arco/' + cnlc + \
           '/new", "ii' + "i" * len(param_info) + '", arco_' + cnlc + \
           "_new, NULL, true, true);", file=outf)
    for p in param_info:
        print('    o2sm_method_new("/arco/' + cnlc + '/repl_' + p[0] + \
              '", "ii, arco_' + cnlc + '_repl_' + p[0] + 
              ', NULL, true, true);', file=outf)
        print('    o2sm_method_new("/arco/' + cnlc + '/set_' + p[0] + \
              '", "if, arco_set_' + p[0] + ', NULL, true, true);', file=outf)
    print("    // END INTERFACE INITIALIZATION", file=outf)

    print(initializer_code, file=outf)
    print("}\n", file=outf)

    print("Initializer", cnlc + "_init_obj(" + cnlc + "_init);", file=outf)

    return


def find_matching_brace(fsrc, loc):
    """
    Find the first unmatched close brace after loc. (fsrc[loc] is ignored)
    This function does not consider brace characters can be quoted.
    """
    loc += 1
    loc_open = fsrc.find("{", loc)
    loc_close = fsrc.find("}", loc)
    if loc_open >= 0 and loc_open < loc_close:  # contains nested {...}
        # recursion: search for matching close brace after loc_open,
        # then search for a close brace
        loc2 = find_matching_brace(fsrc, loc_open)
        if loc2 < 0: return -1
        return find_matching_brace(fsrc, loc2)
    elif loc_close >= 0:
        return loc_close
    else:
        return -1


def extract_method(classname, methodname, src):
    """
    Extract the method from classname
    Algorithm: 
       find classname,
       find methodname, 
       find first "{" after methodname
       find its match; 
       find end of line;
       find beginning of line before methodname;
       extract the method.        
    Return: method as string or None if error occurs
    """
    loc = src.find("class " + classname)
    if loc < 0:
        print("Error: extract_method could not find class", classname)
        return None
    loc = src.find(" " + methodname + "(", loc)
    if loc < 0:
        print('Error: could not find "' + methodname + '"')
        return None
    loc2 = src.find("{", loc)
    if loc2 < 0:
        print("Error: could not find body of classInit")
        return None
    loc2 = find_matching_brace(src, loc2)
    if loc2 < 0: return None
    # capture to end of line (move loc2 just after newline)
    while loc2 < len(src) and src[loc2 - 1] != '\n':
        loc2 += 1
    # capture from beginning of line:
    while loc > 0 and src[loc] != '\n':
        loc -= 1
    return src[loc + 1 : loc2]


def generate_initializer_code(impl, classname, outf):
    global initializer_code
    # find classInit method
    class_init = extract_method(classname, "classInit", impl)
    if class_init == None: return
    # print("---------classInit method:\n" + class_init + "-------")
    loc = class_init.find("(")
    if loc < 0:
        print('Error: could not find "static void classInit("')
        return True
    loc2 = class_init.find(")", loc)
    if loc2 < 0:
        print("Error: could not find ')' after \"static void classInit(\"")
        return True

    # remove int sample_rate parameter:
    class_init = class_init[0 : loc + 1] + class_init[loc2 : ]

    # replace sample_rate with AR
    class_init = class_init.replace("sample_rate", "AR")

    # remove first line (method declaration) and last line (close brace):
    class_init = class_init.split("\n")
    print("class_init", class_init)
    class_init[0] = "\n    // class initialization code from faust:"
    # reduce indentation by 4 spaces (except for first line):
    for i in range(len(class_init)):
        if class_init[i].find("    ") == 0:  # make sure we only remove spaces
            class_init[i] = class_init[i][4 : ]
    initializer_code = "\n".join(class_init[0 : -2])
    print("initializer_code", initializer_code)

    # replace classInit:
    #class_init = class_init.replace("classInit", "class_init")
    #print("---------revised classInit method:\n" + class_init + "-------")

    # write to .h file:
    #print(class_init, file=outf)

    # make initializer to run class_init when Ugens are intialized:
    #initializer_code = "Initializer " + classname.lower() + "_init_obj(" + \
    #                   classname + "::class_init);\n"
    return False


def line_start(s, loc):
    """Find location of beginning of line containing loc"""
    while loc > 0 and s[loc - 1] != "\n":
        loc -= 1;
    return loc


def line_next(s, loc):
    """Find location of beginning of line after loc"""
    while (loc < len(s) - 1 and s[loc - 1] != "\n") or \
          (loc == 0 and len(s) > 0):
        loc += 1;
    return loc


def skip_to_non_space(s, loc):
    """advance loc to next non-space in s"""
    while loc < len(s) and s[loc].isspace():
        loc += 1
    return loc


def skip_to_space(s, loc):
    """advance loc to next space in s"""
    while loc < len(s) and not s[loc].isspace():
        loc += 1
    return loc

    
def skip_token(s, loc):
    """skip to non-space, skip to space, skip to non_space"""
    return skip_to_non_space(s, skip_to_space(s, skip_to_non_space(s, loc)))


def get_token(s, loc):
    """return the space-delineated token starting at loc"""
    endloc = skip_to_space(s, skip_to_non_space(s, loc))
    return s[loc : endloc]


def string_insert(s, insert, loc):
    """return s with insert inserted at loc"""
    print("string_insert loc", loc)
    return s[0 : loc] + insert + s[loc : ]


def insert_interpolation(body, var):
    """Transform body to interpolate var, return None on error"""
    print("insert_interpolation of", var)
    loc = body.find("*" + var + "_samps");
    if loc < 0:
        print("Error: could not find interpolated", var, "in faust code")
        print("Body is -------\n" + body + "\n--------------")
        return None
    # back up to beginning of line:
    loc = line_start(body, loc)
    loc = skip_token(body, loc)
    faust_name = get_token(body, loc)
    loc = line_next(body, loc)
    incr_decls = "        Sample " + var + "_incr = (" + \
            faust_name + " - state->" + var + "_prev) * BL_RECIP;\n" + \
            "        Sample " + var + "_prev = state->" + var + "_prev;\n" + \
            "        state->" + var + "_prev = " + faust_name + ";\n"
            
    body = string_insert(body, incr_decls, loc)
    loc = body.find("for (int", loc)
    loc = line_next(body, loc)
    body = string_insert(body,
            "            " + var + "_prev += " + var + "_incr;\n", loc)
    body = body[0 : loc] + \
           body[loc : ].replace(faust_name, var + "_prev")
    return body


def find_b_rate_parameter_faust_names(classname, param_info, src):
    """ find b-rate parameter faust names from buildUserInterface
    method. For each parameter found, add an extra element to
    the corresponding parameter in param_info to the element
    will look like [parameter_name, interpolated?, faust_name]
    """
    bui = extract_method(classname, "buildUserInterface", src)
    if bui == None: return True
    bui = bui.split("\n")
    printed_something = False
    for line in bui:
        loc = line.find("addNumEntry(")
        if loc >= 0:  # ... "amp", &fEntry0, ...
            args = line[loc + len("addNumEntry(") + 1 : ].split(",")
            print("line =", line, "args =", args)
            printed_something = True
            arco_name = args[0][0 : -1]  # remove trailing quote
            faust_name = args[1].strip()[1 : ]  # remove leading &
            for p in param_info:  # make parameter[][2] be faust name
                if p[0] == arco_name:
                    p.append(faust_name)
                    break;
    if printed_something:  # print a separator for readability
        print("------\n")


def generate_channel_method(fhfile, classname, instvars, param_info, src, rate):
    """Generate and return one channel method. Return True on error
    The method is returned in 5 parts:
        the declaration
        the body
        the close brackets "}  }"
    so that it can be used as is, or it can be used as inline
    statements in real_run for b-rate unit generators that have only
    one channel method and don't need indirection of (this->*run_channel)(...)
    """
    param_types = fhfile[1][ : -2]  # e.g. ab_a -> ab
    print("------compute method for " + fhfile[2])

    # full copy to avoid side effecting the original param_info list
    param_info = [p.copy() for p in param_info]
    if 'b' in param_types or 'c' in param_types:  # update param_info
        find_b_rate_parameter_faust_names(classname, param_info, src)
    compute = extract_method(classname, "compute", src)
    print(compute + "-----")
    if compute == None: return True
    compute = compute.replace("\t", "    ")
    print("param_info", repr(param_info))
    rslt = ["    void chan" + fhfile[1] + "(" + classname + "_state *state) {"]
    compute = compute.split("\n")[1 : -2]

    # lines are separated; remove the line that gets output0
    foundit = None
    for i, line in enumerate(compute):
        if line.find("FAUSTFLOAT* output0 = ") >= 0:
            foundit = i
            break;
    if foundit != None:
        print("found output0, deleting", compute[foundit], "line", foundit)
        del compute[foundit]
    compute = "\n".join(compute)
    if rate == 'a':
        # change output0[i0] to *out_samps++;
        compute = compute.replace("output0[i0]", "*out_samps++");
    else:  # change outputs[0] = ... to *out_samps = ...
        compute = compute.replace("outputs[0]", "*out_samps")

    # change count to BL
    compute = compute.replace("count", "BL")

    # change each inputs[n] to <param>_samps:
    # careful: n is the number of the a-rate input, so if inputs are ba,
    #   n will be 0 for the 2nd parameter
    i = 0
    for param in param_info:
        arco_name = param[0] + "_samps"
        if len(param) > 2:
            faust_name = param[2]  # b-rate fEntry0, fEntry1, etc.
            arco_name = "*" + arco_name  # substitute with float
        else:
            faust_name = "inputs[" + str(i) + "]"  # a-rate inputs[0], ...
            i += 1  # increment only for each a-rate parameter
        print("replace", faust_name, arco_name)  # substitute address of block
        compute = compute.replace(faust_name, arco_name)
        # also replace fControl[i] with arco_name
        if faust_name.find("fEntry") == 0:
            faust_control_var = "fControl[" + faust_name[6 : ] + "]"
            print("replace", faust_control_var, arco_name)
            compute = compute.replace(faust_control_var, arco_name)

    # change each instvar to state->instvar
    for iv in instvars:
        if not iv.isconst:
            compute = compute.replace(iv.name, "state->" + iv.name)

    # add code for interpolated parameters
    print("add code for interpolation, param_info is", param_info)
    for i, p in enumerate(param_info):
        if p[1] and fhfile[1][1 + i] != 'a':  # interpolated flag and b-rate
            compute = insert_interpolation(compute, p[0])
            if compute == None: return True

    print("------final compute method for " + fhfile[2] + "\n" + compute +\
          "-----")
    rslt.append(compute)
    rslt.append("    }\n")
    return rslt


def generate_channel_methods(fhfiles, classname, instvars, param_info, rate,
                             outf):
    """Return True on error"""
    for fhfile in fhfiles:
        with open(fhfile[2], "r") as inf:
            cm = generate_channel_method(fhfile, classname, instvars,
                                         param_info, inf.read(), rate)
            if cm == True:
                return True
            for cmpart in cm:
                print(cmpart, file=outf)
    return False


class Vardecl:
    def __init__(self, type, isconst):
        self.type = type
        self.isconst = isconst
        self.arrayspec = ""

    def __str__(self):
        return "<Vardecl: " + self.type + " " + self.name + \
               " " + self.arrayspec + " " + str(self.isconst) + ">"

    def __repr__(self):
        return str(self)


def find_class_declaration(classname, fimpl):
    """Return the location of the class declaration"""
    loc = fimpl.find("class " + classname + " ")
    if loc < 0:
        loc = fimpl.find("class " + classname + ":")
        if loc < 0:
            print("Error: find_private_variables could not find class",
                  classname)
            return None
    return loc


def find_private_variables(fimpl, classname):
    """
    Find the private variables in the declaration of classname.
    remove fsampleRate, fConst*
    Return: list of dictionaries with type, name, arrayspec, e.g. 
              [{"type": "float", "name": "fRec1", "arraylen": "2"}, 
               {"type": "float", "name": "f2", "arraylen": ""}, ...]
            or return None on error.
    """
    loc = find_class_declaration(classname, fimpl)
    if loc == None: return None
    loc = fimpl.find("private:", loc)
    if loc < 0:
        print('Error: find_private_variables could not find "private:"')
        return None
    loc2 = fimpl.find("public:", loc)
    if loc < 0:
        print('Error: find_private_variables could not find "public:"',
              'after "private:"')
        return None
    privates = fimpl[loc + len("private:") : loc2].strip().split("\n")
    rslt = []
    for p in privates:
        if p.find("fSampleRate") < 0:
            decl = p.strip().split()  # [type, var;]
            # initialize with type and const
            instvar = Vardecl(decl[0], p.find("fConst") >= 0)
            bracket = decl[1].find("[")
            if bracket < 0:
                instvar.name = decl[1][0 : -1]  # remove semicolon
            else:
                instvar.name = decl[1][0 : bracket]  # remove semicolon
                instvar.arrayspec = decl[1][bracket + 1 : -2]
            rslt.append(instvar)
    print("private variables:", repr(rslt))
    return rslt


def generate_state_struct(classname, param_info, outf):
    global fimpl
    print("    struct", classname + "_state {", file=outf)
    # find private variables which include Faust instance variables
    privates = find_private_variables(fimpl, classname)
    find_b_rate_parameter_faust_names(classname, param_info, fimpl)
    if privates == None:
        return True
    b_rate_variables = [p[2] for p in param_info if len(p) > 2]
    print("b_rate_variables", b_rate_variables)
    # declare instance variables from Faust here:
    for p in privates:
        if not p.isconst and not p.name in b_rate_variables:
            arrayspec = "[" + p.arrayspec + "]" if p.arrayspec != "" else ""
            print("        " + p.type, p.name + arrayspec + ";", file=outf)

    # also declare a _prev variable for every interpolated parameter:
    print("gss param_info", param_info)
    for p in param_info:
        if p[1]:
            print("        float", p[0] + "_prev;", file=outf)

    print("    };", file=outf)
    print("    Vec<" + classname + "_state> states;", file=outf)
    print("    void (" + classname + "::*run_channel)(" + classname +
          "_state *state);\n", file=outf)
    return privates


def generate_state_init(classname, instvars, param_info, outf):
    """
    output loop body that initializes states[i], returns True if error
    """
    global fimpl
    clear_meth = extract_method(classname, "instanceClear", fimpl)
    if clear_meth == None: return True
    # indent for state loop
    clear_meth = ["    " + line for line in clear_meth.split("\n")]
    # remove the first line and last line:
    clear_meth = "\n".join(clear_meth[1 : -2])
    # note: clear_meth is missing newline at end
    # replace variable v with states[i].v
    for var in instvars:
        if not var.isconst:
            clear_meth = clear_meth.replace(var.name, "states[i]." + var.name)
    print("------ body of clear meth\n" + clear_meth + "------")
    print(clear_meth, file=outf)

    # initialize _prev variables whether we use them or not:
    for p in param_info:
        if p[1]:
            print("            states[i]." + p[0] + "_prev = 0.0f;", file=outf)
    return False


def initialize_constants(classname, instvars, outf):
    """
    output initializers for constants, returns True if error
    """
    global fimpl
    const_meth = extract_method(classname, "instanceConstants", fimpl)
    if const_meth == None: return True
    # remove first line and last line to get the body
    const_meth = const_meth.split("\n")[1 : -2]
    # remove the line that sets fSampleRate
    foundit = None
    for i, line in enumerate(const_meth):
        if line.find("fSampleRate = ") >= 0:
            print("found fSampleRate in", line)
            foundit = i
            break
    if foundit != None:
        del const_meth[foundit]
    const_meth = "\n".join(const_meth)
    const_meth = const_meth.replace("fSampleRate", "AR")
    print(const_meth + "\n", file=outf)


def generate_update_run_channel(classname, fhfiles, param_info, outf):
    print("    void update_run_channel() {", file=outf)
    print("        // initialize run_channel based on input types", file=outf)
    print("fhfiles:", fhfiles)
    need_else = False
    cond = ""
    for sig in fhfiles:
        if len(param_info) == 0:
            print("        run_channel = &chan_;", file=outf)
        else:
            cond += (" else " if need_else else "        ") + "if ("
            need_else = True  # after first if, we add "else if"

            need_and = False
            for i, p in enumerate(param_info):
                if need_and: cond += " && "
                need_and = True
                # compare rate == 'a' or rate != 'a' depending on signature:
                sigtest = ("== 'a'" if sig[1][1 + i] == 'a' else "!= 'a'")
                cond += p[0] + "->rate " + sigtest
            if cond != "":
                cond += ") {\n"
            cond += "            run_channel = &" + classname + \
                    "::chan" + sig[1] + ";\n        }"
    print(cond, file=outf)
    if cond != "":
        # fallback is upsample everything:
        print("        else {", file=outf)
        ind = "           "  # 11 spaces here + print will insert 1
        for i, p in enumerate(param_info):
            print(ind, "if (" + p[0] + "->rate != 'a') {", file=outf)
            print(ind, "    " + p[0] + " = new Upsample(-1, " + \
                                p[0] + "->chans, " + p[0] + ");", file=outf)
            print(ind, "}", file=outf)
        print(ind, "run_channel = &" + classname + "::chan_" + \
                   "a" * len(param_info) + "_a;",
              file=outf)
        print("        }", file=outf)
    print("    }\n", file=outf)
    

def generate_arco_h(classname, param_info, rate, fhfiles, outf):
    global fsrc, fimpl
    print("/*", classname.lower(),  "-- unit generator for arco", file=outf)
    print(" *\n * generated by f2a.py\n */\n", file=outf)
    print("/*------------- BEGIN FAUST PREAMBLE -------------*/\n", file=outf)
    loc = find_class_declaration(classname, fimpl)
    if loc == None: return
    while fimpl[loc - 1] == "\n":
        loc -= 1
    print(fimpl[0 : loc], file=outf)
    print("/*-------------- END FAUST PREAMBLE --------------*/\n", file=outf)

    print("extern const char *" + classname + "_name;\n", file=outf)

    print("class", classname, ": public Ugen {\npublic:", file=outf)

    parameters = [p[0] for p in param_info]

    instvars = generate_state_struct(classname, param_info, outf)
    if instvars == True: return

    for p in parameters:
        print("    Ugen_ptr", p + ";", file=outf)
        print("    int", p + "_stride;", file=outf)
        print("    Sample_ptr", p + "_samps;\n", file=outf)

    for iv in instvars:
        if iv.isconst:
            arrayspec = "[" + iv.arrayspec + "]" if iv.arrayspec != "" else ""
            print("    " + iv.type, iv.name + arrayspec + ";", file=outf)

    print("\n    " + classname + "(int id, int nchans", file=outf, end="")
    for p in parameters:
        print(", Ugen_ptr", p + "_", file=outf, end="")
    print(") : Ugen(id, '" + rate + "', nchans) {", file=outf)

    for p in parameters:
        print("        " + p + " = " + p + "_;", file=outf)

    # initialize states
    print("        states.init(chans);", file=outf)
    if initialize_constants(classname, instvars, outf): return 

    print("        // initialize channel states", file=outf)
    print("        for (int i = 0; i < chans; i++) {", file=outf)
    if generate_state_init(classname, instvars, param_info, outf): return
    print("        }\n", file=outf)

    # call init_<var> for every parameter
    for p in parameters:
        print("        init_" + p + "(" + p + ");", file=outf)
    if rate == 'a':
        print("        update_run_channel();", file=outf)
    print("    }\n", file=outf)

    print("    ~" + classname + "() {", file=outf)
    for p in parameters:
        print("        " + p + "->unref();", file=outf)
    print("    }\n", file=outf)

    # create name() method
    print("    const char *classname() { return " + classname + \
          "_name; }\n", file=outf)

    # create update_run_channel method to set the run_channel
    if rate == 'a':
        generate_update_run_channel(classname, fhfiles, param_info, outf)

    if len(parameters) > 0:
        print("    void print_sources(int indent, bool print) {", file=outf)
        for p in parameters:
            print("        " + p + '->print_tree(indent, print, "' + p + '");',
                  file=outf)
    print("    }\n", file=outf)

    for p in parameters:
        print("    void repl_" + p + "(Ugen_ptr inp) {", file=outf)
        print("        " + p + "->unref();", file=outf)
        print("        init_" + p + "(inp);", file=outf)
        if rate == 'a':
            print("        update_run_channel();", file=outf)
        print("    }\n", file=outf)

    for p in parameters:
        print("    void set_" + p + "(int chan, float f) {", file=outf)
        print("        assert(" + p + "->rate == 'c');", file=outf)
        print("        " + p + "->output[chan] = f;", file=outf)
        print("    }\n", file=outf)

    for p in parameters:
        print("    void init_" + p + "(Ugen_ptr ugen) { init_param(ugen,",
              p + ",", p + "_stride); }\n", file=outf)

    if generate_initializer_code(fimpl, classname, outf): return

    if rate == 'a':
        if generate_channel_methods(fhfiles, classname, instvars,
                                    param_info, rate, outf):
            return

    print("    void real_run() {", file=outf)
    for p in parameters:
        print("        " + p + "_samps =",
              p + "->run(current_block); // update input", file=outf)
    print("        " + classname + "_state *state = &states[0];", file=outf)
    print("        for (int i = 0; i < chans; i++) {", file=outf)
    if rate == 'a':
        print("            (this->*run_channel)(state);", file=outf)
    else:
        cm = generate_channel_method(fhfiles[0], classname, instvars,
                                     param_info, fimpl, rate)
        if cm == True:
            return
        # extract and indent the body of the compute function
        cm = ["    " + line for line in cm[1].split("\n")]
        print("\n".join(cm), file=outf)
    print("            state++;", file=outf)
    for p in parameters:
        print("            " + p + "_samps +=", p + "_stride;", file=outf)
    print("        }", file=outf)
    print("    }", file=outf)
    print("};", file=outf)
    print("#endif", file=outf)


def get_param_info(file, rate):
    global fsrc, fimpl  # main faust source file (.dsp) and implementation (.fh)
    """
    extract parameter names and interpolated status from file
    returns: [[p1, False], [p2, True], ...] where boolean indicates
        interpolation when the output is audio, or on error, True
    """
    with open(file) as f:
        fsrc = f.read()
    fsrc = fsrc.replace("\t", "    ")
    if rate == None:
        print("Error: no rate determined for", file)
        return True
    if rate == 'a':
        return get_params_a(fsrc)
    elif rate == 'b':
        return get_params_b(fsrc)
    else:
        print("Error: rate for", file, "is invalid (" + rate + ")")
        return True


def get_params_a(fsrc):
    """
    extract parameter names and interpolated status from file
    returns: [[p1, False], [p2, True], ...] where boolean indicates
        interpolation when the output is audio, or on error, True
    """
    loc = fsrc.find("process(")
    if loc < 0:
        loc = fsrc.find("process")
        if loc < 0:
            print('Error: could not find "process("')
            return True
        loc = skip_to_non_space(fsrc, loc + 7)  # search after "process"
        if fsrc[loc] != "=":
            print('Erorr: did not find "=" after "process"')
            return True
        params = ""
    else:
        loc2 = fsrc.find(")", loc)
        if loc2 < 0:
            print("Error: could not find ')' after \"process(\"")
            return True
        params = fsrc[loc + 8 : loc2]
        params = params.replace(",", " ").split()

    # now look for interpolated declaration
    interpolated = []
    loc = fsrc.find("declare interpolated")
    if loc >= 0:
        loc = fsrc.find('"', loc)  # first quote
        if loc < 0:
            print("Error: could not find string after declare interpolated")
            return True
        loc2 = fsrc.find('"', loc + 1)
        interpolated = fsrc[loc + 1 : loc2].replace(",", " ").split()
    print("interpolated", interpolated)

    # build result
    for i in range(len(params)):
        params[i] = [params[i], params[i] in interpolated]
    return params


def get_params_b(fsrc):
    """
    extract parameter names from block-rate-output file
    returns: [[p1, False], [p2, False], ...] where boolean indicates
        interpolation, so always False; return True on error
    """
    # find the nentries to get the parameter list
    loc = fsrc.find("nentry(")
    params = []
    while loc >= 0:
        loc = fsrc.find('"', loc)
        if loc < 0:
            print('Error: get_params_b did not find \'"\' after "nentry("')
            return True
        loc2 = fsrc.find('"', loc + 1)
        if loc2 < 0:
            print('Error: get_params_b did not find 2nd \'"\' after "nentry("')
            return True
        params.append([fsrc[loc + 1 : loc2], False])
        loc = fsrc.find("nentry(", loc2)
    return params


def run_faust(classname, file, outfile):
    """run the faust command to generate outfile"""
    blockrate = ""
    if file.find("b.dsp") >= 0:
        blockrate = "-os "  # one sample if b-rate
    print("In f2a.py, PATH=" + os.environ['PATH'])
    err = os.system("faust -light -cn " + classname + " " + blockrate +
                    file + " -o " + outfile)
    if err != 0:
        print("Error: quit because of error reported by Faust")
        return True
    else:
        print("     Transl1ation completed, generated ", outfile)
        return False


def main():
    global fsrc, fimpl
    # find files
    source = sys.argv[1]  # can pass "sine_aa_a.dsp" or just "sine"
    classname = source.split("_")[0] 
    files = glob.glob(classname + "_*.dsp")
    classnamelc = classname
    classname = classname.title()
    # fhfiles is a list: [[dspfile, signature, faustoutput],
    #                    [dspfile, signature, faustoutput], ...]
    #    where signature is like "ab_a"
    fhfiles = []
    main_file = None  # where to look for parameter definitions

    # translate files
    output_rate = None
    # this is used to check for consistent .dsp files
    top_signature = None  # has a's or b's combined with c's
    for file in files:
        print("**** Translating", file)
        # see if this is the audio-only version:
        path = Path(file)
        signature = str(path.with_suffix(""))[len(classname) : ]
        if output_rate and output_rate != signature[-1]:
            print("Error: output rate is", output_rate,
                  "but input file is", file)
            return
        output_rate = signature[-1]

        if not top_signature:
            top_signature = signature
        for i in range(len(signature)):
            if top_signature[i] == 'b' and signature[i] == 'a':
                top_signature = top_signature[ : i] + 'a' + \
                                top_signature[i + 1 : ]
            if top_signature[i] != 'c' and signature[i] == 'c':
                print("Error: top signature", top_signature,
                      "is not consistent with", file)
                return
        if "b" not in signature or "a" not in signature:
            main_file = file

        if output_rate == 'b' and "a" in signature:
            print("Error: output is b-rate, but input has audio:", file)
            return
        outfile = str(path.with_suffix(".fh"))
        fhfiles.append([file, signature, outfile])
        if run_faust(classname, file, outfile): return
            
    # find param_info
    print("main file: ", main_file, "top signature", top_signature)
    param_info = get_param_info(main_file, output_rate)
    if param_info == True: return
    print("Param_info:", param_info)

    # read main faust output file for use by translators:
    path = Path(main_file)
    main_impl = str(path.with_suffix(".fh"))
    print("main faust implemenation file:", main_impl)
    with open(main_impl, "r") as inp:
        fimpl = inp.read()
    fimpl = fimpl.replace("\t", "    ")

    # open and generate the Arco Ugen
    with open(classnamelc + ".h", "w") as outf:
        generate_arco_h(classname, param_info, output_rate, fhfiles, outf)
    with open(classnamelc + ".cpp", "w") as outf:
        generate_arco_cpp(classname, param_info, output_rate, outf)
    
main()
