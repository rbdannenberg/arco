# faust code generator - expands to b-rate and a-rate types
#
# Roger B. Dannenberg
# Jan 2022

"""
creates .dsp files for faust from simplified .dsp files, creating
various combinations of b-rate and a-rate parameters and output.

also writes .srp file for the unit generator
"""

import sys
import subprocess
import glob
import os
from params import Param, get_signatures
from implementation import prepare_implementation
    

WIN32 = (os.name == 'nt')
PY = "python" if WIN32 else "python3"

def has_upper(s):
    for c in s:
        if c.isupper():
            return True
    return False


def line_wrap(s, indent):
    """wrap a string s with indent spaces at the beginning of each line
    Assume this is a long parameter list with ", " separators where we
    can break lines.
    """
    result = ""
    while len(s) > 80:
        loc = s.rfind(", ", 0, 80)
        if loc < 0:
            loc = len(s)
        result += s[0 : loc + 1] + "\n" + " " * indent
        s = s[loc + 2 : ]
    result += s
    return result


def main():
    # find files
    if len(sys.argv) != 2:
        print(f"Usage: {PY} u2f.py classname[.ugen]")
        exit(-1)
    source = sys.argv[1]  # can pass "sine.ugen" or just "sine"
    if source.find(".") < 0:
        source += ".ugen"
    elif source.find(".ugen") < 0 or has_upper(source):
        print("Error: command line argument " + source + \
              " must be class name (lower case) with or without " + \
              ".ugen extension")
        return
    # now strip off .ugen because we need the directory name too
    classnamelc = source[ : -5]
    print("**** Cleaning out old sources")
    for f in glob.glob(classnamelc + "_*.dsp"):
        os.remove(f)
    for f in glob.glob(classnamelc + "_*.fh"):
        os.remove(f)
    # subprocess.run(["rm " + classnamelc + "_*.{dsp,fh}"], shell=True)
    print("**** Translating", source)
    with open(source, "r") as srcf:
        src = srcf.readlines()

    # a signature set is a list of Signatures
    signature_set = get_signatures(src)
    print("got signature set", signature_set)

    # find the FAUST line and the implementation that follows
    impl_text = None
    for i, line in enumerate(src):
        line = line.strip()
        if line == "FAUST":
            impl_text = src[i + 1 : ]
            break

    if impl_text == None:
        print("Error: did not find FAUST to begin implementation.")
        return
    classnames = []
    impl = prepare_implementation(impl_text)

    for s in signature_set:
        if not s:
            return  # error message already printed
        # check signatures for consistency with implementation
        s.check_signature(impl.param_names)
   
        # write .dsp file for each a and b type combination:
        expand_signature(s, [], impl)
        # gather up all classnames, e.g. ["sine", "sineb"] for later:
        if s.name in classnames:
            print("ERROR:", s[0], "signature is defined twice.")
            return
        else:
            classnames.append(s.name)

    ### create generate_class.sh (or .bat)
    shellfilename = "generate_" + classnamelc + (".bat" if WIN32 else ".sh")
    print("**** Generating", shellfilename)
    with open(shellfilename, "w") as genf:
        if not WIN32:
            print("#!/bin/sh", file=genf)
        print('echo "In', shellfilename, 'running', PY, 'path=$PATH"',
              file=genf)
        for cn in classnames:
            print(PY, "../../preproc/f2a.py", cn, file=genf)
        for cn in classnames:
            print(PY, "../../../o2/preproc/o2idc.py --nobackup", cn + ".cpp",
                  file=genf)
    ### create class.srp
    serpentfilename = classnamelc + ".srp"
    print("**** Generating", serpentfilename)
    with open(serpentfilename, "w") as srpf:
        print("#", serpentfilename, "- constructor implementation", file=srpf)
        print("#\n# (machine generated by u2f.py)\n", file=srpf)

        for (c, s) in zip(classnames, signature_set):
            print(c, s)
            decl = "def " + c + "("
            srpparams = ""
            typestring = ""
            for p in s.params:
                decl += (p.name + ", ")
                srpparams += ", '" + p.name + "', " + p.name
                typestring += "U"

            # allow optional chans parameter unless the inputs/outputs are
            # fixed because of specified channel count(s):
            if s.output.fixed:  # oops, we have an extra ", " at the end
                decl = decl[0 : -2] + "):"
            else:
                decl += "optional chans):"
            print(decl, file=srpf)

            # Generate valid parameter rate tests and error messages
            # Also generate list of channels for max function
            chans_list = "" if s.output.fixed else "1"
            for p in s.params:
                if p.abtype == 'a':
                    print("    if", p.name + ".rate != 'a':", file=srpf)
                    print('        print "ERROR:', "'" + p.name + \
                          "' input to Ugen '" + c + "'",
                          'must be audio rate"', file=srpf)
                    print("        return nil", file=srpf)
                elif p.abtype == 'b':
                    print("    if not isnumber(" + p.name + ") and",
                          p.name + ".rate != 'b':", file=srpf)
                    print('        print "ERROR:', "'" + p.name + \
                          "' input to Ugen '" + c + "'",
                          'must be block rate"', file=srpf)
                    print("        return nil", file=srpf)
                if p.fixed:
                    achans = p.name + ".chans"
                    if p.chans == 1:
                        chans_list += "    if " + achans + " != 1:\n"
                        chans_list += "        print \"ERROR: '" + p.name + \
                                "' input to Ugen '" + c + \
                                "' must be single channel\"\n"
                        chans_list += "        return nil\n"
                    else:
                        chans_list += "    if " + achans + " != 1 and " +\
                                achans + " != " + str(p.chans) + ":\n"
                        chans_list += "        print \"ERROR: '" + p.name + \
                                "' input to Ugen '" + c + \
                                "' must have 1 or " + str(p.chans) + \
                                ' channels"\n'
                        chans_list += "        return nil\n"
                else:
                    chans_list = "max_chans(" + chans_list + ", " + \
                                 p.name + ")"
            if s.output.fixed:
                print(chans_list, file=srpf)
            else:  # check each input for required specified channel count or 1
                print("    if not chans:", file=srpf)
                print("        chans = " + chans_list, file=srpf)
            ugen = f'    Ugen(create_ugen_id(), "{c}", chans, ' + \
                   f"'{s.output.abtype}', " + f'"{typestring}"{srpparams})'
            ugen = line_wrap(ugen, 9)
            print(ugen, file=srpf)
            print("", file=srpf)



def expand_signature(signature, params, impl):
    """
    recursively generate all permutations of parameters in params
    and write .dsp file.
    signature is the ugen signature includingi the list of parameters
        and their possible types
    params is a list of Param objects representing specific choices: 'a' or 'b'
    impl is an Implementation object with the FAUST implementation info

    The algorithm is recursive, appending each possible choice ('a' or 'b')
    to params and calling itself with a the extended params list. When the
    len(params) is len(signature.params), we have a full specification,
    so generate a .dsp file for it.
    """
    print("expand_signature", signature, params)
    if len(params) < len(signature.params):
        next_param = signature.params[len(params)]
        for typ in next_param.abtype:
            param = Param(typ, next_param)
            expand_signature(signature, params + [param], impl)
    else:  # base case: we have a specific signature to generate
        # first, get parameter names
        typestring = ''.join([p.abtype for p in params])
        outfile = signature.name + "_" + typestring + "_" + \
                  signature.output.abtype + ".dsp"
        with open(outfile, "w") as outf:
            print('declare name "' + signature.name + '";', file=outf)

            # insert control for each b-rate parameter
            print("base case: types", signature.params, "params", params)
            # for each element of types with N channels, process N params
            # the sum of channel counts must equal the length of params
            plist = ""
            i = 0
            for param in signature.params:
                print("param", param.abtype, "param.chans", param.chans)
                for j in range(param.chans):
                    if i >= len(impl.param_names):
                        print("ERROR: too many parameters in Arco signature\n"
                              "    compared to FAUST process() definition.\n"
                              "    Arco signature specifies", i)
                        return
                    if param.abtype == 'a':
                        plist = plist + ", " + impl.param_names[i]
                    else:
                        print(impl.param_names[i], '= nentry("' + \
                              impl.param_names[i] + \
                              '", 0, 0, 1, 0.1);', file=outf)
                    i += 1
            if i != len(impl.param_names):
                print("ERROR: too many parameters in FAUST process()\n"
                      "    definition compared to Arco signature.\n"
                      "    Arco signature specifies", i)
                return

            if 'b' in typestring:
                # blank line after nentry and before process
                print("", file=outf)

            processline = "process"
            # plist looks like ", freq, amp" so ignore the first 2 chars
            if plist != "":
                processline = processline + "(" + plist[2 : ] + ")"
            processline = processline + " " + impl.beyond_process

            for line in impl.before_lines:
                print(line, file=outf, end="")
            print(processline, file=outf, end="")
            for line in impl.after_lines:
                print(line, file=outf, end="")
            
main()
