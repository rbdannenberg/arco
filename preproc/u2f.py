# faust code generator - expands to b-rate and a-rate types
#
# Roger B. Dannenberg
# Jan 2022

"""
creates .dsp files for faust from simplified .dsp files, creating
various combinations of b-rate and a-rate parameters and output.

also writes .srp file for the unit generator
"""

import sys
import subprocess
import glob
import os
from params import Param, get_signatures
from implementation import prepare_implementation
    

WIN32 = (os.name == 'nt')
PY = "python" if WIN32 else "python3"

def has_upper(s):
    for c in s:
        if c.isupper():
            return True
    return False


def line_wrap(s, indent):
    """wrap a string s with indent spaces at the beginning of each line
    Assume this is a long parameter list with ", " separators where we
    can break lines.
    """
    result = ""
    while len(s) > 80:
        loc = s.rfind(", ", 0, 80)
        if loc < 0:
            loc = len(s)
        result += s[0 : loc + 1] + "\n" + " " * indent
        s = s[loc + 2 : ]
    result += s
    return result


def main():
    # find files
    if len(sys.argv) != 2:
        print(f"Usage: {PY} u2f.py classname[.ugen]")
        exit(-1)
    source = sys.argv[1]  # can pass "sine.ugen" or just "sine"
    if source.find(".") < 0:
        source += ".ugen"
    elif source.find(".ugen") < 0 or has_upper(source):
        print("Error: command line argument " + source + \
              " must be class name (lower case) with or without " + \
              ".ugen extension")
        return
    # now strip off .ugen because we need the directory name too
    classnamelc = source[ : -5]
    print("**** Cleaning out old sources")
    for f in glob.glob(classnamelc + "_*.dsp"):
        os.remove(f)
    for f in glob.glob(classnamelc + "_*.fh"):
        os.remove(f)
    # subprocess.run(["rm " + classnamelc + "_*.{dsp,fh}"], shell=True)
    print("**** Translating", source)
    with open(source, "r") as srcf:
        src = srcf.readlines()

    # a signature set is a list of Signatures
    signature_set = get_signatures(src)
    print("got signature set", signature_set)

    # find the FAUST line and the implementation that follows
    impl_text = None
    for i, line in enumerate(src):
        line = line.strip()
        if line == "FAUST":
            impl_text = src[i + 1 : ]
            break

    if impl_text == None:
        print("Error: did not find FAUST to begin implementation.")
        return
    classnames = []
    impl = prepare_implementation(impl_text)

    for s in signature_set:
        if not s:
            return  # error message already printed
        # check signatures for consistency with implementation
        s.check_signature(impl.param_names)
   
        # write .dsp file for each a and b type combination:
        expand_signature(s, [], impl)
        # gather up all classnames, e.g. ["sine", "sineb"] for later:
        if s.name in classnames:
            print("ERROR:", s[0], "signature is defined twice.")
            return
        else:
            classnames.append(s.name)

    ### create generate_class.sh (or .bat)
    shellfilename = "generate_" + classnamelc + (".bat" if WIN32 else ".sh")
    print("**** Generating", shellfilename)
    with open(shellfilename, "w") as genf:
        if not WIN32:
            print("#!/bin/sh", file=genf)
        print('echo "In', shellfilename, 'running', PY, 'path=$PATH"',
              file=genf)
        print(PY, "rm -f *.h *.cpp *.dsp *.fh")
        for cn in classnames:
            print(PY, "../../preproc/f2a.py", cn, file=genf)
        for cn in classnames:
            print(PY, "../../../o2/preproc/o2idc.py --nobackup", cn + ".cpp",
                  file=genf)
    ### create class.srp
    serpentfilename = classnamelc + ".srp"
    print("**** Generating", serpentfilename)
    with open(serpentfilename, "w") as srpf:
        print("#", serpentfilename, "- constructor implementation", file=srpf)
        print("#\n# (machine generated by u2f.py)\n", file=srpf)

        for (c, s) in zip(classnames, signature_set):
            print(c, s)
            decl = "def " + c + "("
            srpparams = ""
            typestring = ""
            for p in s.params:
                decl += (p.name + ", ")
                # This is a bit confusing. In .ugen files, 'c' means a
                # constant at instantiation, but FAUST does not
                # support structural changes at "instantiation", only
                # at compile time (e.g. if max delay is an Arco
                # parameter, FAUST does not allocate only that
                # amount. Instead, it allocates enough for >1 second
                # at 192K. It will only allocate according to max delay
                # if it is known at compile-time constant, e.g. 0.1.)
                # Therefore, although you can write 'c' in a .ugen file
                # FAUST treats it as 'b', but it is still interpreted
                # on the Arco side as a value that is not a signal, and
                # you can only change it with .set_attr(x) methods or
                # messages. It is a local instance variable rather than
                # a block-rate input.
                #
                # In Serpent, we use 'c' for the rate of Const even
                # though it looks like a 'b' rate to any consumer.
                # We also use 'f' (for "fixed" or "float") for parameters
                # that are "fixed" or "set" at instantiation time and
                # maybe are updateable using methods. The 'f' type is
                # needed to avoid confusion with Const which is c-rate.
                # Since we have some type checking to avoid connecting
                # an a-rate to a b-rate only input, but we want to
                # allow connecting a c-rate (Const) to a b-rate input,
                # we have to convert all the types here for Serpent:
                # "ab" becomes "abc", "b" becomes "bc". "c" becomes "f".
                # There should not be an "ac", "abc", or "bc" in the
                # .ugen file.
                # 
                # The O2 typestring becomes "U" for any signal denoted
                # in .ugen as "a", "b", or "ab", and it is "f" (float)
                # for any .ugen parameter with a "c" designation.
                #
                types = p.abtype
                if types == "ab":
                    types = "abc"
                elif types == "b":
                    types = "bc"
                srpparams += (", '" + p.name + "', " + p.name +
                              ', "' + types + '"')
                typestring += ("f" if p.abtype == 'c' else "U")

            # allow optional chans parameter unless the inputs/outputs are
            # fixed because of specified channel count(s):
            if s.output.fixed:  # oops, we have an extra ", " at the end
                decl = decl[0 : -2] + "):"
            else:
                decl += "optional chans):"
            print(decl, file=srpf)

            # Generate valid parameter rate tests and error messages
            # Also generate list of channels for max function
            chans_list = "" if s.output.fixed else "1"
            for p in s.params:
#                if p.abtype == 'a':
#                    print("    if", p.name + ".rate != 'a':", file=srpf)
#                    print('        print "ERROR:', "'" + p.name + \
#                          "' input to Ugen '" + c + "'",
#                          'must be audio rate"', file=srpf)
#                    print("        return nil", file=srpf)
#                elif p.abtype == 'b':
#                    print("    if not isnumber(" + p.name + ") and",
#                          p.name + ".rate == 'a':", file=srpf)
#                    print('        print "ERROR:', "'" + p.name + \
#                          "' input to Ugen '" + c + "'",
#                          'must be block rate"', file=srpf)
#                    print("        return nil", file=srpf)
                if p.fixed:
                    achans = p.name + ".chans"
                    if p.chans == 1:
                        chans_list += f"    if not isnumber({p.name}) and " + \
                                      f"{achans} != 1:\n"
                        chans_list += f"        print \"ERROR: '{p.name}' "+ \
                                "input to Ugen '{c}' must be single channel\"\n"
                        chans_list += "        return nil\n"
                    else:
                        chans_list += f"    if {achans} != 1 and " + \
                                      f"{achans} != {str(p.chans)}:\n"
                        chans_list += f"        print \"ERROR: '{p.name}' " + \
                                      f"input to Ugen '{c}' must have 1 or " + \
                                      f'{str(p.chans)} channels"\n'
                        chans_list += "        return nil\n"
                else:
                    chans_list = f"max_chans({chans_list}, {p.name})"
            if s.output.fixed:
                print(chans_list, file=srpf)
            else:  # check each input for required specified channel count or 1
                print("    if not chans:", file=srpf)
                print("        chans =", chans_list, file=srpf)
            omit_chans = ", omit_chans = true" if s.output.fixed else ""
            chans = s.output.chans if s.output.fixed else "chans"

            ugen = f'    Ugen(create_ugen_id(), "{c}", {chans}, ' + \
                   f"'{s.output.abtype}', " + \
                   f'"{typestring}"{omit_chans}{srpparams})'
            ugen = line_wrap(ugen, 9)
            print(ugen, file=srpf)
            print("", file=srpf)



def expand_signature(signature, params, impl):
    """
    recursively generate all permutations of parameters in params
    and write .dsp file.
    signature is the ugen signature includingi the list of parameters
        and their possible types
    params is a list of Param objects representing specific choices: 'a' or 'b'
    impl is an Implementation object with the FAUST implementation info

    The algorithm is recursive, appending each possible choice ('a' or 'b')
    to params and calling itself with a the extended params list. When the
    len(params) is len(signature.params), we have a full specification,
    so generate a .dsp file for it.

    Constant parameters ('c') are converted to 'b' parameters for Faust
    code generation.
    """
    print("expand_signature", signature, params)
    if len(params) < len(signature.params):
        next_param = signature.params[len(params)]
        for typ in next_param.abtype:
            param = Param(typ, next_param)
            expand_signature(signature, params + [param], impl)
    else:  # base case: we have a specific signature to generate
        # first, get parameter names
        typestring = ''.join([p.abtype for p in params])
        outfile = signature.name + "_" + typestring + "_" + \
                  signature.output.abtype + ".dsp"
        with open(outfile, "w") as outf:
            print('declare name "' + signature.name + '";', file=outf)

            # insert control for each b-rate parameter
            print("base case: types", signature.params, "params", params)
            # for each element of types with N channels, process N params
            # the sum of channel counts must equal the length of params
            plist = ""
            i = 0
            for param in params:
                print("param", param.abtype, "param.chans", param.chans)
                for j in range(param.chans):
                    if i >= len(impl.param_names):
                        print("ERROR: too many parameters in Arco signature\n"
                              "    compared to FAUST process() definition.\n"
                              "    Arco signature specifies", i)
                        return
                    print("******************", param.abtype, impl.param_names[i])
                    if param.abtype == 'a':
                        plist = plist + ", " + impl.param_names[i]
                    else:  # 'b' or 'c'
                        print(impl.param_names[i], '= nentry("' + \
                              impl.param_names[i] + \
                              '", 0, 0, 1, 0.1);', file=outf)
                    i += 1
            if i != len(impl.param_names):
                print("ERROR: too many parameters in FAUST process()\n"
                      "    definition compared to Arco signature.\n"
                      "    Arco signature specifies", i)
                return

            if 'b' in typestring or 'c' in typestring:
                # blank line after nentry and before process
                print("", file=outf)

            processline = "process"
            # plist looks like ", freq, amp" so ignore the first 2 chars
            if plist != "":
                processline = processline + "(" + plist[2 : ] + ")"
            processline = processline + " " + impl.beyond_process

            for line in impl.before_lines:
                print(line, file=outf, end="")
            print(processline, file=outf, end="")
            for line in impl.after_lines:
                print(line, file=outf, end="")
            
main()
