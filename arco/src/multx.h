/* multx -- unit generator for arco
 *
 * generated by f2a.py, extended by Roger B. Dannennberg
 * Nov 2023
 *
 * multx is a Mult with an initial value, so audo * blockrate
 * does not necessarily start with a ramp from zero.
 *
 * Only the second factor, x2, can be provided with an initial
 * value.
 */

#ifndef  __Multx_H__
#define  __Multx_H__

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 

extern const char *Multx_name;

class Multx : public Ugen {
public:
    struct Multx_state {
        Sample prev;
    };
    Vec<Multx_state> states;
    void (Multx::*run_channel)(Multx_state *state);

    Ugen_ptr x1;
    int x1_stride;
    Sample_ptr x1_samps;

    Ugen_ptr x2;
    int x2_stride;
    Sample_ptr x2_samps;


    Multx(int id, int nchans, Ugen_ptr x1_, Ugen_ptr x2_, float x2_init) :
            Ugen(id, 'a', nchans) {
        x1 = x1_;
        x2 = x2_;
        states.set_size(chans);

        init_x1(x1);
        init_x2(x2);
        update_run_channel();
        // normally, Arco Ugens reinitialize channel states whenever
        // a new input has a different rate, changing the run_channel
        // method. In this special case, reverting to the starting
        // value for x2 (x2_init) after some computation makes no
        // sense, so we only initialize state here at the beginning.
        initialize_channel_states(x2_init);
    }

    ~Multx() {
        x1->unref();
        x2->unref();
    }

    const char *classname() { return Multx_name; }

    void initialize_channel_states(float x2_init) {
        for (int i = 0; i < chans; i++) {

            states[i].prev = x2_init;
        }
    }

    void update_run_channel() {
        // initialize run_channel based on input types
        void (Multx::*new_run_channel)(Multx_state *state);
        if (x1->rate == 'a' && x2->rate == 'a') {
            run_channel = &Multx::chan_aa_a;
        } else if (x1->rate == 'a' && x2->rate != 'a') {
            run_channel = &Multx::chan_ab_a;
        } else if (x1->rate != 'a' && x2->rate == 'a') {
            run_channel = &Multx::chan_ba_a;
        } else if (x1->rate != 'a') {
            x1 = new Upsample(-1, x1->chans, x1);
            run_channel = &Multx::chan_ab_a;
        }
    }

    void print_sources(int indent, bool print_flag) {
        x1->print_tree(indent, print_flag, "x1");
        x2->print_tree(indent, print_flag, "x2");
    }

    void repl_x1(Ugen_ptr ugen) {
        x1->unref();
        init_x1(ugen);
        update_run_channel();
    }

    void repl_x2(Ugen_ptr ugen) {
        x2->unref();
        init_x2(ugen);
        update_run_channel();
    }

    void set_x1(int chan, float f) {
        x1->const_set(chan, f, "Multx::set_x1");
    }

    void set_x2(int chan, float f) {
        x2->const_set(chan, f, "Multx::set_x2");
    }

    void init_x1(Ugen_ptr ugen) { init_param(ugen, x1, x1_stride); }

    void init_x2(Ugen_ptr ugen) { init_param(ugen, x2, x2_stride); }

    void chan_aa_a(Multx_state *state) {
        for (int i = 0; i < BL; i++) {
            *out_samps++ = x1_samps[i] * x2_samps[i];
        }
    }

    void chan_ab_a(Multx_state *state) {
        float x2 = *x2_samps;
        Sample x2_incr = (x2 - state->prev) * BL_RECIP;
        Sample x2_fast = state->prev;
        state->prev = x2;
        for (int i = 0; i < BL; i++) {
            x2_fast += x2_incr;
            *out_samps++ = x2_fast * x1_samps[i];
        }
    }

    void chan_ba_a(Multx_state *state) {
        float x1 = *x1_samps;
        Sample x1_incr = (x1 - state->prev) * BL_RECIP;
        Sample x1_fast = state->prev;
        state->prev = x1;
        for (int i = 0; i < BL; i++) {
            x1_fast += x1_incr;
            *out_samps++ = x1_fast * x2_samps[i];
        }
    }

    void real_run() {
        x1_samps = x1->run(current_block); // update input
        x2_samps = x2->run(current_block); // update input
        Multx_state *state = &states[0];
        for (int i = 0; i < chans; i++) {
            (this->*run_channel)(state);
            state++;
            x1_samps += x1_stride;
            x2_samps += x2_stride;
        }
    }
};
#endif
