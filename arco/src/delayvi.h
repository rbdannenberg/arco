/* delayvi -- unit generator for arco
 *
 * generated by f2a.py
 */

/*------------- BEGIN FAUST PREAMBLE -------------*/

/* ------------------------------------------------------------
name: "delayvi"
Code generated with Faust 2.75.7 (https://faust.grame.fr)
Compilation options: -lang cpp -light -ct 1 -cn Delayvi -es 1 -mcd 16 -mdd 1024 -mdy 33 -single -ftz 0
------------------------------------------------------------ */

#ifndef  __Delayvi_H__
#define  __Delayvi_H__

#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 

#include <algorithm>
#include <cmath>
#include <cstdint>
#include <math.h>
#include "ffts_compat.h"  // for ilog2

#ifndef FAUSTCLASS 
#define FAUSTCLASS Delayvi
#endif

#ifdef __APPLE__ 
#define exp10f __exp10f
#define exp10 __exp10
#endif

#if defined(_WIN32)
#define RESTRICT __restrict
#else
#define RESTRICT __restrict__
#endif
/*-------------- END FAUST PREAMBLE --------------*/

extern const char *Delayvi_name;

class Delayvi : public Ugen {
public:
    struct Delayvi_state {
        int IOTA0;
        Sample *delay_buf;
        Sample delay_samps_prev;
    };
    Vec<Delayvi_state> states;
    void (Delayvi::*run_channel)(Delayvi_state *state);

    Ugen_ptr input;
    int input_stride;
    Sample_ptr input_samps;

    Ugen_ptr delay;
    int delay_stride;
    Sample_ptr delay_samps;

    float maxdelay;
    int delay_len;  // length of allocated delays

    Delayvi(int id, int nchans, Ugen_ptr input_, Ugen_ptr delay_, float maxdelay_) :
            Ugen(id, 'a', nchans) {
        input = input_;
        delay = delay_;
        maxdelay = maxdelay_;
        flags = CAN_TERMINATE;
        delay_len = std::ceil(maxdelay * AR);
        // round delay_len up to the next power of 2 if needed
        if ((delay_len & (delay_len - 1)) != 0) {
            delay_len = 1 << ilog2(delay_len);
        }
        states.set_size(chans);
        for (int i = 0; i < chans; i++) {
            states[i].delay_buf = O2_CALLOCNT(delay_len, Sample);
            states[i].delay_samps_prev = 0.0;
        }
        init_input(input);
        init_delay(delay);
        run_channel = (void (Delayvi::*)(Delayvi_state *)) 0;
        update_run_channel();
    }

    ~Delayvi() {
        input->unref();
        delay->unref();
        for (int i = 0; i < chans; i++) {
            O2_FREE(states[i].delay_buf);
            states[i].delay_buf = nullptr;
        }
    }

    const char *classname() { return Delayvi_name; }

    void initialize_channel_states() {
        // continue processing delays and leave signal in delay_buf
        ;
    }

    void update_run_channel() {
        // initialize run_channel based on input types
        void (Delayvi::*new_run_channel)(Delayvi_state *state);
        if (input->rate == 'b') {
            input = new Upsample(-1, input->chans, input);
        }
        if (delay->rate == 'a') {
            new_run_channel = &Delayvi::chan_aac_a;
        } else {
            new_run_channel = &Delayvi::chan_abc_a;
        }
        if (new_run_channel != run_channel) {
            initialize_channel_states();
            run_channel = new_run_channel;
        }
    }

    void print_sources(int indent, bool print_flag) {
        input->print_tree(indent, print_flag, "input");
        delay->print_tree(indent, print_flag, "delay");
    }

    void repl_input(Ugen_ptr ugen) {
        input->unref();
        init_input(ugen);
        update_run_channel();
    }

    void repl_delay(Ugen_ptr ugen) {
        delay->unref();
        init_delay(ugen);
        update_run_channel();
    }

    void set_input(int chan, float f) {
        input->const_set(chan, f, "Delayvi::set_input");
    }

    void set_delay(int chan, float f) {
        delay->const_set(chan, f, "Delayvi::set_delay");
    }

    void init_input(Ugen_ptr ugen) { init_param(ugen, input, &input_stride); }

    void init_delay(Ugen_ptr ugen) { init_param(ugen, delay, &delay_stride); }

    void chan_aac_a(Delayvi_state *state) {
        int index_mask = delay_len - 1;
        for (int i0 = 0; i0 < BL; i0 = i0 + 1) {
            float dly_cnt = AR * delay_samps[i0];  // delay measured in samples
            float dly_cnt_half = dly_cnt + -0.499995f;  // delay count minus 1/2
            float dly_cnt_1 = std::floor(dly_cnt_half);  // delay to oldest sample to use
            state->delay_buf[state->IOTA0 & index_mask] = input_samps[i0];
            int idly_cnt_1 = int(dly_cnt_half);
            float delta1 = dly_cnt + (-1.0f - dly_cnt_1);
            float delta2 = dly_cnt - dly_cnt_1;
            out_samps[i0] = FAUSTFLOAT((dly_cnt + (-2.0f - dly_cnt_1)) * (0.5f * state->delay_buf[(state->IOTA0 - int(std::min<float>(delay_len, float(std::max<int>(0, idly_cnt_1))))) & index_mask] * delta1 - delta2 * state->delay_buf[(state->IOTA0 - int(std::min<float>(delay_len, float(std::max<int>(0, idly_cnt_1 + 1))))) & index_mask]) + 0.5f * delta2 * delta1 * state->delay_buf[(state->IOTA0 - int(std::min<float>(delay_len, float(std::max<int>(0, idly_cnt_1 + 2))))) & index_mask]);
            state->IOTA0 = state->IOTA0 + 1;
        }
    }

    void chan_abc_a(Delayvi_state *state) {
        int index_mask = delay_len - 1;
        Sample delay_sig = *delay_samps;
        Sample delay_samps_fast = state->delay_samps_prev;
        Sample delay_samps_incr = (delay_sig - delay_samps_fast) * BL_RECIP;
        state->delay_samps_prev = delay_sig;
        for (int i0 = 0; i0 < BL; i0 = i0 + 1) {
            float dly_cnt = AR * delay_samps_fast;  // delay measured in samples
            delay_samps_fast += delay_samps_incr;
            float dly_cnt_half = dly_cnt + -0.499995f;  // delay count minus 1/2
            float dly_cnt_1 = std::floor(dly_cnt_half);  // delay to oldest sample to use
            state->delay_buf[state->IOTA0 & index_mask] = input_samps[i0];
            int idly_cnt_1 = int(dly_cnt_half);
            float delta1 = dly_cnt + (-1.0f - dly_cnt_1);
            float delta2 = dly_cnt - dly_cnt_1;
            out_samps[i0] = FAUSTFLOAT((dly_cnt + (-2.0f - dly_cnt_1)) * (0.5f * state->delay_buf[(state->IOTA0 - int(std::min<float>(delay_len, float(std::max<int>(0, idly_cnt_1))))) & index_mask] * delta1 - delta2 * state->delay_buf[(state->IOTA0 - int(std::min<float>(delay_len, float(std::max<int>(0, idly_cnt_1 + 1))))) & index_mask]) + 0.5f * delta2 * delta1 * state->delay_buf[(state->IOTA0 - int(std::min<float>(delay_len, float(std::max<int>(0, idly_cnt_1 + 2))))) & index_mask]);
            state->IOTA0 = state->IOTA0 + 1;
        }
    }

    void real_run() {
        input_samps = input->run(current_block);  // update input
        delay_samps = delay->run(current_block);  // update input
        if (((input->flags) & TERMINATED) &&
            (flags & CAN_TERMINATE)) {
            terminate(ACTION_TERM);
        }
        Delayvi_state *state = states.get_array();
        for (int i = 0; i < chans; i++) {
            (this->*run_channel)(state);
            state++;
            out_samps += BL;
            input_samps += input_stride;
            delay_samps += delay_stride;
        }
    }
};
#endif
