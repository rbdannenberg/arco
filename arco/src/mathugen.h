/* math -- unit generator for arco for binary math operations
 *
 * generated by f2a.py, modified by RBD
 */

#include <algorithm>
#include <cmath>
#include <cstdint>

#ifdef __APPLE__ 
#define exp10f __exp10f
#define exp10 __exp10
#endif

/*-------------- END FAUST PREAMBLE --------------*/

extern const char *Math_name;

typedef struct Math_state {
    int count;
    Sample prev;
    Sample hold;
} Math_state;

class Math;

extern void (Math::*run_aa_a[NUM_MATH_OPS])(Math_state *state);
extern void (Math::*run_ab_a[NUM_MATH_OPS])(Math_state *state);
extern void (Math::*run_ba_a[NUM_MATH_OPS])(Math_state *state);
extern void (Math::*run_bb_a[NUM_MATH_OPS])(Math_state *state);

class Math : public Ugen {
public:
    int op;
    Vec<Math_state> states;
    void (Math::*run_channel)(Math_state *state);

    Ugen_ptr x1;
    int x1_stride;
    Sample_ptr x1_samps;

    Ugen_ptr x2;
    int x2_stride;
    Sample_ptr x2_samps;

    Math(int id, int nchans, int op_, Ugen_ptr x1_, Ugen_ptr x2_) :
            Ugen(id, 'a', nchans) {
        op = op_;
        if (op < 0) op = 0;
        if (op >= NUM_MATH_OPS) op = MATH_OP_ADD;
        x1 = x1_;
        x2 = x2_;
        flags = CAN_TERMINATE;
        states.set_size(chans);

        init_x1(x1);
        init_x2(x2);
        run_channel = (void (Math::*)(Math_state *)) 0;
        update_run_channel();
    }

    ~Math() {
        x1->unref();
        x2->unref();
    }

    const char *classname() { return Math_name; }

    void initialize_channel_states() {
        for (int i = 0; i < chans; i++) {
            states[i].count = 0;
            states[i].prev = 0.0f;
            states[i].hold = 0.0f;
        }
    }

    void update_run_channel() {
        // initialize run_channel based on input types
        void (Math::*new_run_channel)(Math_state *state);
        if (x1->rate == 'a' && x2->rate == 'a') {
            new_run_channel = run_aa_a[op];
        } else if (x1->rate == 'a' && x2->rate != 'a') {
            new_run_channel = run_ab_a[op];
        } else if (x1->rate != 'a' && x2->rate == 'a') {
            new_run_channel = run_ba_a[op];
        } else if (x1->rate != 'a' && x2->rate != 'a') {
            new_run_channel = run_bb_a[op];
        }
        if (new_run_channel != run_channel) {
            initialize_channel_states();
            run_channel = new_run_channel;
        }
        clear_counts();
    }

    void print_details(int indent) {
        arco_print("op %s ", OP_TO_STRING[op]);
    }
    
    void print_sources(int indent, bool print_flag) {
        x1->print_tree(indent, print_flag, "x1");
        x2->print_tree(indent, print_flag, "x2");
    }

    void clear_counts() {
        // since we have a new parameter, we clear the count so that we will
        // immediately start ramping to a value between -x2 and x2 rather than
        // possibly wait for a long ramp to finish. A potential problem is that
        // if x1 is now low, creating long ramp times, and our current ramp value
        // (state->hold) is much larger than a new x2, it could take a long time
        // for the output to get within the desired range -x2 to x2.  It takes
        // a little work to determine what is affected by a change since an input
        // could have fanout to multiple output channels, so we just restart ramps
        // on all channels.
        if (op == MATH_OP_RLI) {
            for (int i = 0; i < chans; i++) {
                states[i].count = 0;
            }
        }
    }

    void repl_x1(Ugen_ptr ugen) {
        x1->unref();
        init_x1(ugen);
        update_run_channel();
    }

    void repl_x2(Ugen_ptr ugen) {
        x2->unref();
        init_x2(ugen);
        update_run_channel();
    }

    void set_x1(int chan, float f) {
        x1->const_set(chan, f, "Math::set_x1");
        clear_counts();
    }

    void set_x2(int chan, float f) {
        x2->const_set(chan, f, "Math::set_x2");
        clear_counts();
    }

    void rliset(float f) {
        if (op == MATH_OP_RLI) {
            for (int i = 0; i < chans; i++) {
                states[i].prev = unifrand_range(-f, f);
            }
        }
    }

    void init_x1(Ugen_ptr ugen) { init_param(ugen, x1, &x1_stride); }

    void init_x2(Ugen_ptr ugen) { init_param(ugen, x2, &x2_stride); }

    //----------------- mul ------------------

    void mul_aa_a(Math_state *state);
    void mul_ab_a(Math_state *state);
    void mul_ba_a(Math_state *state);
    void mul_bb_a(Math_state *state);

    //----------------- add ------------------

    void add_aa_a(Math_state *state);
    void add_ab_a(Math_state *state);
    void add_ba_a(Math_state *state);
    void add_bb_a(Math_state *state);

    //----------------- sub ------------------

    void sub_aa_a(Math_state *state);
    void sub_ab_a(Math_state *state);
    void sub_ba_a(Math_state *state);
    void sub_bb_a(Math_state *state);

    //----------------- div ------------------
    // div is division except we do not divide by anything smaller 
    // than 0.01, so if |x2| < 0.01, divide by 0.01 or -0.01

    void div_aa_a(Math_state *state);
    void div_ab_a(Math_state *state);
    void div_ba_a(Math_state *state);
    void div_bb_a(Math_state *state);

    //----------------- max ------------------

    void max_aa_a(Math_state *state);
    void max_ab_a(Math_state *state);
    void max_ba_a(Math_state *state);
    void max_bb_a(Math_state *state);

    //----------------- min ------------------

    void min_aa_a(Math_state *state);
    void min_ab_a(Math_state *state);
    void min_ba_a(Math_state *state);
    void min_bb_a(Math_state *state);

    //----------------- clp ------------------
    // clip x1 to the range of (positive) x2

    void clp_aa_a(Math_state *state);
    void clp_ab_a(Math_state *state);
    void clp_ba_a(Math_state *state);
    void clp_bb_a(Math_state *state);

    //----------------- pow ------------------

    void pow_aa_a(Math_state *state);
    void pow_ab_a(Math_state *state);
    void pow_ba_a(Math_state *state);
    void pow_bb_a(Math_state *state);

    //----------------- LT ------------------

    void lt_aa_a(Math_state *state);
    void lt_ab_a(Math_state *state);
    void lt_ba_a(Math_state *state);
    void lt_bb_a(Math_state *state);

    //----------------- GT ------------------

    void gt_aa_a(Math_state *state);
    void gt_ab_a(Math_state *state);
    void gt_ba_a(Math_state *state);
    void gt_bb_a(Math_state *state);

    //----------------- SCP ------------------
    // soft clipping y = x2 if x1 > x2; -x2 if x1 < -x2;
    // o.w. y = ((x1 / x2) - ((x1 / x2) ** 3) / 3) * (3 / 2) * x2
    //        = (x * 3 - x ** 3) * 0.5 * x2, where x = x1 / x2

    void scp_aa_a(Math_state *state);
    void scp_ab_a(Math_state *state);
    void scp_ba_a(Math_state *state);
    void scp_bb_a(Math_state *state);


    //----------------- PWI ------------------
    // raise x1 to integer power x2

    void pwi_aa_a(Math_state *state);
    void pwi_ab_a(Math_state *state);
    void pwi_ba_a(Math_state *state);
    void pwi_bb_a(Math_state *state);


    //----------------- RND ------------------
    // random number between x1 and x2

    void rnd_aa_a(Math_state *state);
    void rnd_ab_a(Math_state *state);
    void rnd_ba_a(Math_state *state);
    void rnd_bb_a(Math_state *state);


    //----------------- SH ------------------
    // sample and hold x1 on x2 zero crossings

    void sh_aa_a(Math_state *state);
    void sh_ab_a(Math_state *state);
    void sh_ba_a(Math_state *state);
    void sh_bb_a(Math_state *state);

    //----------------- QNT ------------------
    // quantize x1 according to x2

    void qnt_aa_a(Math_state *state);
    void qnt_ab_a(Math_state *state);
    void qnt_ba_a(Math_state *state);
    void qnt_bb_a(Math_state *state);

    //----------------- RLI ------------------
    // random linear interpolation at x1 Hz from -x2 to +x2

    void rli_aa_a(Math_state *state);
    void rli_ab_a(Math_state *state);
    void rli_ba_a(Math_state *state);
    void rli_bb_a(Math_state *state);

    //----------------- HZDIFF ------------------
    // random linear interpolation at x1 Hz from -x2 to +x2

    void hzdiff_aa_a(Math_state *state);
    void hzdiff_ab_a(Math_state *state);
    void hzdiff_ba_a(Math_state *state);
    void hzdiff_bb_a(Math_state *state);

    //----------------- TAN ------------------
    // random linear interpolation at x1 Hz from -x2 to +x2

    void tan_aa_a(Math_state *state);
    void tan_ab_a(Math_state *state);
    void tan_ba_a(Math_state *state);
    void tan_bb_a(Math_state *state);

    //----------------- ATAN2 ------------------
    // random linear interpolation at x1 Hz from -x2 to +x2

    void atan2_aa_a(Math_state *state);
    void atan2_ab_a(Math_state *state);
    void atan2_ba_a(Math_state *state);
    void atan2_bb_a(Math_state *state);

    //----------------- SIN ------------------
    // random linear interpolation at x1 Hz from -x2 to +x2

    void sin_aa_a(Math_state *state);
    void sin_ab_a(Math_state *state);
    void sin_ba_a(Math_state *state);
    void sin_bb_a(Math_state *state);

    //----------------- COS ------------------
    // random linear interpolation at x1 Hz from -x2 to +x2

    void cos_aa_a(Math_state *state);
    void cos_ab_a(Math_state *state);
    void cos_ba_a(Math_state *state);
    void cos_bb_a(Math_state *state);


    void real_run() {
        x1_samps = x1->run(current_block); // update input
        x2_samps = x2->run(current_block); // update input
        if (((x1->flags | x2->flags) & TERMINATED) &&
            (flags & CAN_TERMINATE)) {
            terminate(ACTION_TERM);
        }
        Math_state *state = &states[0];
        for (int i = 0; i < chans; i++) {
            (this->*run_channel)(state);
            state++;
            x1_samps += x1_stride;
            x2_samps += x2_stride;
        }
    }
};



