# arco.srp -- Serpent library for controlling Arco
#
# Roger B. Dannenberg
# Jan 2022

# call arco_init(ensemble) to start
# call arco_run() after setting up UI and or scheduling things
# arco_ready is set to true when arco is ready for action

require "debug"
require "sched"
require "o2util"
require "utils"
require "prefs"

AR = 44100.0  // audio rate
AP = 1 / AR // audio sample period
BL = 32
BL_RECIP = 1 / BL
BR = AR / BL
BP = 1 / BR

A_RATE = 'a'
B_RATE = 'b'
C_RATE = 'c'

// BPS is set to zero when audio stops to avoid activity that
// cannot be processed by the audio server. BPS is restored
// using this variable:
saved_vtsched_bps = 1.0  // default "tempo"

# states:
#    nil - initial value
#    'discovery' - looking for "arco" service
#    'initializing' - resetting the server
#    'stopped' - initialized, audio is not open
#    'opening' - collecting device info and opening audio device(s)
#    'running' - audio server is running
#    'resetting' - shutting down audio server
#    'quitting' - application is quitting
#
# state transitions:
# (Note: ANY state can transition to 'quitting' when arco_quit() is called.
#  'quitting' is the final state, you cannot transition out of it.)
#
#    nil: start state
#        Action: none
#        -> 'discovery' when arco_init() called by main program
#    'discovery': polling for "arco" service
#        Action: arco_init() polls for discovery of "arco"
#        -> 'initializing' when "arco" service discovered
#    'initializing': waiting for Arco to reset, will open audio
#        Action: reset_arco_handler() sends to /arco/reset
#        -> 'devinf' when receive /actl/reset
#    'devinf': waiting for device info, will open audio
#        Action: actl_reset() sends to /arco/devinf, open_audio_handler()
#                is called when last devinf message is received
#        -> 'opening' when open_audio_handler() calls arco_open()
#        -> 'stopped' when open_audio_handler() has nothing to open
#    'opening': waiting for Arco audio streaming to start
#        Action: call arco_open(), sends /arco/open
#        -> 'running' when /actl/starting called
#    'running': computing and streaming audio
#        Action: actl_starting()
#        -> 'stopped' when code calls close_audio_handler() or
#                          Close Audio menu selected
#    'devinf2': waiting for device info, will not open audio
#        Action: rescan_audio_handler() sends /arco/devinf
#        -> 'stopped' when last devinf message received
#    'stopped': initialized, but audio is not running
#        Action: none
#        -> 'devinf2' when Rescan Audio Devices menu selected
#        -> 'opening' when user code calls arco_open() or 
#                          Open Audio menu selected
#        -> 'initializing2' when user code calls reset_arco_handler() or
#                                Reset Arco menu selected
#    'initializing2': waiting for Arco to reset, will not open audio
#        Action: send to /arco/reset
#        -> 'devinf2' when receive /actl/reset
#    'quitting': application is shutting down
#        Action: send to /arco/quit
#
# Shutdown:
#     application calls arco_quit() (one way to implement this
#        is to set default_window.method = 'arco_main_win_handler'. This
#        will call arco_quit() when the main window is closed,
#        delaying exit until a clean shutdown is complete.)
#    arco_quit sends /arco/quit and begins polling with poll_for_no_arco
#    Arco stops running and calls o2sm_finish()
#    poll_for_no_arco detects Arco finish with 
#        o2_shmem_inst_count() == 0 and calls exit()
#        
arco_state = nil
arco_allowed_state_transitions = {  // maps new state to allowed current states
    'discovery': [nil],
    'initializing': 'discovery',
    'devinf': 'initializing',
    'opening': ['devinf', 'stopped'],
    'running': 'opening',
    'stopped': ['opening', 'running', 'devinf2'],
    'devinf2': ['initializing2', 'stopped'],
    'initializing2': 'stopped'}

# This function checks if a transition to newstate is legal. If legal,
# arco_state is changed and return value is true. Otherwise, stay in the
# current state, print a warning and return false.
def set_arco_state(newstate): 
    if newstate != 'quitting':
        allowed = arco_allowed_state_transitions[newstate]
        if arco_state != allowed and ((not isarray(allowed)) or 
                                      (arco_state not in allowed)):
            print "*****************************************************"
            print "* WARNING: Unexpected state transition from", 
            print arco_state, "to", newstate; "."
            return false
    display "arco_state change to", newstate
    arco_state = newstate
    return true


// atend types for Mix.ins():
SIGNAL = 'signal'
GAIN = 'gain'
BOTH = 'both'
// atend types for ugen.atend(). Various Ugens can send notification of end events:
//    Pwlb, Fileplay, ...
MUTE = 'mute'  // standard thing to do at end: call mute() to delete a sound instance
FINISH = 'finish'  // custom behavior - the target should implement finish() to
                   // handle the event

ZERO_ID = 0
ZEROB_ID = 1
INPUT_ID = 2
PREV_OUTPUT_ID = 3

// shadow the sets of Ugens maintained by audio server:
arco_output_set = []
arco_run_set = []

// manage action callbacks
next_action_id = 1
action_dict = {}

max_ugen_id_used = 0

def create_ugen_id():
    var uid = arco_ugen_new()
    if arco_ugen_id(uid) > max_ugen_id_used:
        max_ugen_id_used = arco_ugen_id(uid)
    uid


# Ugen.action_id is an integer key. Arco sends /actl/act with the key
# when the Ugen finishes.
# action_dict[key] is a list of actions of the form
# [ugen, object, method, params], where ugen is the holder of the
# action_id, which equals key, and the remaining [object, method, params]
# is the method or function to invoke to perform the action.
#
def create_action(ugen, object, method, rest parameters):
    var action_list
    var action = [ugen, object, method, parameters]
    if ugen.action_id:
        action_list = action_dict.get(ugen.action_id)
        if not action_list:
            print "ERROR: create_action - action_id not found in action_dict",
            print ugen.action_id
        action_list.append(action)
    else:
        action_dict[next_action_id] = [action]
        ugen.action_id = next_action_id
        o2_send_cmd("/arco/" + tolower(ugen.classname) + "/act", 0, "Ui",
                    ugen.id, next_action_id)
        next_action_id = next_action_id + 1
    print "create_action for ugen", ugen.id, "action", ugen.action_id


def actl_act(timestamp, address, types, rest parameters):
    display "actl_act", types, parameters
    var key = parameters[0]
    var action_list = action_dict.get(key)
    if not action_list:
        print "ERROR: actl_act - action_id not found in action_dict", key
        return
    var ugen = action_list[0][0]  // all actions start with the same ugen
    ugen.action_id = nil     // clear the action so we can install a new one
    for action in action_list:
        action[3].insert(0, parameters[1])  // make status be first parameter
        general_apply(action[1], action[2], action[3])
    action_dict.remove(key)  // allow garbage collection


# assign default_window.method = 'arco_main_win_handler' to quit Arco
# before quitting your main program. default_window is defined by
# require "wxserpent" -- works with wxserpent64 only (not serpent64)
def arco_main_win_handler(obj, event, x, y):
    if event == WXS_CLOSE_WINDOW:
        display "arco_main_win_handler", event, x, y
        // ask for confirmation:
        if prefs.modified and
           wxs_message_box("Save current settings to preferences?",
                   "Quit Requested", WXS_STYLE_YES_NO, 0) == WXS_MSG_YES:
            prefs.save()
        // request Arco to shut down
        arco_quit()
        // event is handled, so we do not actually quit yet


def file_quit_handler(rest ignore):
    arco_main_win_handler(default_window, WXS_CLOSE_WINDOW, 1, 0)


# To quit, application should call arco_quit(). Alternatively, 
# set default_window.method = 'arco_main_win_handler' to catch
# when main window closes (which would normally shut down the
# application) and instead call arco_quit() to clean up and
# THEN exit the application.
#
def arco_quit(rest ignore):
    o2_send_cmd("/arco/quit", 0)
    poll_for_no_arco()


def poll_for_no_arco()
    print "poll for no arco"
    if o2_shmem_inst_count() == 0:
        arco_thread_poll() // <- just a test to make sure this does not crash
                           // Arco. It should know that Arco is shut down and
                           // just return.
        exit()
    sched_cause(0.1, nil, 'poll_for_no_arco')


IS_WXSERPENT = symbol_value('WXS_DEFAULT_WINDOW') == 0  // is this wxserpent?

audio_devices = []

if IS_WXSERPENT:
    display "####### arco.srp GETTING File MENU FROM", default_window
    audio_devices_menu = default_window.get_menu("File")
    require "audiodev"

arco_open_msg = ""
if get_os() == 'linux':
   arco_open_msg = " If Arco crashes (on Linux) after opening audio, " +
                   "try increasing latency to 100 msec or opening other " +
                   "device(s)."

def actl_devinf(timestamp, address, types, info):
    if info == "":
        display "actl_devinf", repr(info), arco_state
        if arco_state == 'devinf':
            // auto-open in discovery->initializing->devinf->opening->running
            //     sequence:
            if prefs.get('audio_open_success') or
                wxs_message_box("Automatically open audio using preferences?" +
                    arco_open_msg, "Start Audio Now",
                    WXS_STYLE_YES_NO | WXS_STYLE_QUESTION, 0) == WXS_MSG_YES:
                // Apparently, if you jump right into opening audio, someone
                // accesses the File menu before it is even created. So delay
                // auto_open_audio() to allow window creation first:
                print "************** WRONG!!! FIX ME!! *******************"
                sched_select(rtsched)
                sched_cause(0.05, nil, 'auto_open_audio')
            return
        // else user just asked to rescan devices (state is 'devinf2'):
        set_arco_state('stopped')
        if IS_WXSERPENT:
            create_device_selections()  // build the radio button selections
        return  // done with devices
    if IS_WXSERPENT:
        audio_devices.append(info)
    elif find(info, "Aggregate") >= 0 or find(info, "default") >= 0:
        var id = int(info)
        print "  --> opening this device, id", id
        arco_open(id, id, arco_input_chans, arco_output_chans,
                  arco_latency, arco_buffersize)
        o2_send_cmd("/arco/prtree", o2_time_get() + 1, "");


def find_one_audio_device(selections, dir):
    var id
    for s in selections:
        var pos = find(s, "(") + 1
        if pos == -1:
            display "Internal error in find_one_audio_device", s, pos
            return nil
        if dir == "outs":
            pos = find(s, ",", pos) + 1
        var chans = int(subseq(s, pos))
        if chans > 0:
            if id:
                print "Multiple devices selected for", 
                print "input." if dir == "ins" else "output."
                return nil
            id = int(s)
    display "find_one_audio_device returns", dir, id
    return id


def arco_init(keyword ensemble="arco", ins = 2, outs = 2, network = t,
              latency = 30, buffersize = BL,
              color, title, o2trace, appname = "arco", dbgmenu = t):
# Initialize arco.
# ensemble - O2 ensemble name
# ins - number of input channels (if real input device has fewer channels, input
#       will be zero-padded to produce ins channels)
# outs - number of output channels (if real output device has fewer channels,
#        output will be wrapped and added so all channels are output)
# network - enables network connections with o2_network_enable(); this enables
#           local area discovery and requests a public IP address.
# latency - audio device latency in ms
# buffersize - buffer size for audio input and output
# color - main window background color (array of [r, g, b])
# title - main window title (string)
# o2trace - debug flags passed to O2 in o2_initialize
# appname - the application name, used to name preference file
# dbgmenu - if true, adds menu items File:"Print Ugen Info" and
#           File:"Arco Ugen GC Info"

    prefs = Prefs(appname)
    audiomaster_gain = prefs.get('master_gain', -12.0)

    if not set_arco_state('discovery'):
        return
    // set title and Quit handlers to shut down Arco on exit
    if IS_WXSERPENT
        if title:
            default_window.set_string(title)
        if not color:
            color = [160, 210, 210]
        default_window.set_rgb(color[0], color[1], color[2])
        default_window.method = 'arco_main_win_handler'
        display "####### arco_init GETTING File MENU FROM", default_window
        var file_menu = default_window.get_menu("File")
        if dbgmenu:
            file_menu.item("Print Ugen Info", "print Ugen tree and table",
                           nil, nil, 'arco_prugens_handler')
            file_menu.item("Arco Ugen GC Info", "print info about Ugen IDs",
                           nil, nil, 'arco_ugen_gc_info_handler')
        

        file_menu.item("Quit", "quit the application", nil, nil,
                       'file_quit_handler')
        
    arco_input_chans = ins
    arco_output_chans = outs
    arco_latency = latency
    arco_buffersize = buffersize
    sched_init()
    o2_network_enable(network)
    o2_initialize(ensemble, o2trace)
    arco_initialize()  // create audio shared memory interface
    o2_service_new("actl")
    print "service actl created"
    o2_method_new("/actl/devinf", "s", 'actl_devinf', t)
    o2_method_new("/actl/act", "ii", 'actl_act', t)
    o2_method_new("/actl/starting", "iiiiii", 'actl_starting', t)
    o2_method_new("/actl/reset", "", 'actl_reset', t)
    o2_method_new("/actl/cpu", "f", 'actl_cpu', t)
    // o2_method_new("/actl/yin", "fff", 'actl_yin', t)
    sched_select(rtsched)
    sched_cause(0.1, nil, 'poll_for_arco')
    if IS_WXSERPENT:
        audiodev_init()

def arco_run():
    sched_poll_function = 'arco_thread_poll'
    sched_o2_enabled = true
    if getfeatures() & OPTION_WXS == 0:
        sched_run()


# Called by application after selecting devices to open. inchan and
# outchan should be the number of input and output channels in the
# PortAudio streams.  These numbers might be adjusted if they do not
# match the device capabilities, which were reported in the /devinf
# messages. The application sees possibly different numbers of
# channels, which are available in the globals arco_input_chans and
# arco_output_chans. The application should not change these, and they
# are set by passing optional values to arco_init().
#
def arco_open(indev, outdev, inchan, outchan, latency, buffersize):
    prefs.set('audio_open_success', nil, true)  // audio crash detect
    if not zero_ugen:
        create_standard_ugens()
    o2_send_cmd("/arco/open", 0, "iiiiiis", indev, outdev,
                inchan, outchan, latency, buffersize, "actl");


arco_get_cpu_load_continuation = nil
arco_get_cpu_load_data = nil

def arco_get_cpu_load(continuation, optional data):
    arco_get_cpu_load_continuation = continuation
    arco_get_cpu_load_data = data
    o2_send_cmd("/arco/cpu", 0, "")  // get and display cpu load


# request a callback with estimated cpu load. Callback can have a
# non-nil 2nd parameter, data, if provided in this call.
def actl_cpu(timestamp, address, types, rest args):
    if arco_get_cpu_load_continuation:
        if arco_get_cpu_load_data:
            funcall(arco_get_cpu_load_continuation, args[0],
                    arco_get_cpu_load_data)
        else:
            funcall(arco_get_cpu_load_continuation, args[0])


def arco_prugens_handler(rest ignore):
    // this tells Arco to print the Ugen tree -- it can be useful for
    //     debugging.
    o2_send_cmd("/arco/prtree", 0, "")
    // also print the list of Ugens accessible by integer ID:
    o2_send_cmd("/arco/prugens", 0, "")


def arco_ugen_gc_info_handler(rest ignore):
    arco_ugen_gc_info()


# Ask Arco to print tree of Ugens:
def arco_prtree():
    o2_send_cmd("/arco/prtree", 0, "");


def arco_gain(x):
    o2_send_cmd("/arco/gain", 0, "f", x)


def arco_heartbeat(x):
    o2_send_cmd("/arco/hb", 0, "i", x)


arco_poll_to_free_ugens_id = 0


# internal function: set up basics after connection established
#
def reset_arco():
    if not set_arco_state('initializing' if arco_state == 'discovery'
                                         else 'initializing2'):
        return
    o2_send_cmd("/arco/reset", 0, "s", "actl")  // pass in this service name
    arco_poll_to_free_ugens_id = arco_poll_to_free_ugens_id + 1
    arco_poll_to_free_ugens(arco_poll_to_free_ugens_id)
    zero_ugen = nil
    zerob_ugen = nil
    input_ugen = nil
    prev_output_ugen = nil


last_gc_cycles = 0

def arco_poll_to_free_ugens(id):
    if id == arco_poll_to_free_ugens_id:
        arco_ugen_gc()  // free Ugen id's on server for all ugen_id's 
        // that the Serpent garbage collector has collected
        sched_cause(0.1, nil, 'arco_poll_to_free_ugens',
                    arco_poll_to_free_ugens_id)
    return
    // debugging information tells when GC happens (disabled)
    if last_gc_cycles != gc_cycles():
        print "******************************************",
        print "Completed", gc_cycles() - last_gc_cycles, 
        print "more GC cycles. Cycle count", gc_cycles()
        last_gc_cycles = gc_cycles()



def actl_reset(rest ignore):
    if not set_arco_state('devinf' if arco_state == 'initializing' 
                                   else 'devinf2'):
        return
    // else arco_state is 'initializing' and we are starting up
    print "**** arco was reset, starting initialization ****"
    arco_ugen_reset()  // new epoch of ugen_id's; all existing are invalidated
    create_standard_ugens()  // restore basic ugens
    audio_devices.clear()
    o2_send_cmd("/arco/devinf", 0, "s", "/actl/devinf")


def create_standard_ugens():
    if zero_ugen:
        print "WARNING: create_stanard_ugens -- ugens already created"
        return
    zero_ugen = Zero(ZERO_ID)
    zerob_ugen = Zerob(ZEROB_ID)
    input_ugen = Thru(zero_ugen, arco_input_chans, INPUT_ID)
    // previous output can be read here on the next block:
    prev_output_ugen = Thru(zero_ugen, arco_output_chans, PREV_OUTPUT_ID)


# internal function: wait for arco service, then reset Arco server
#
def poll_for_arco():
    print "poll for arco"
    if o2_status("arco") < O2_LOCAL:
        sched_cause(1.0, nil, 'poll_for_arco')
    else:
        print "**** discovered arco service. initialization starting ****"
        arco_heartbeat(0)  // initially, block count printing is off
        print "*** SENT arco_heartbeat(0) from poll_for_arco ***"
        reset_arco()


# this is an O2 message handler for message sent by audio thread
# when the audio stream is started:
#
def actl_starting(timestamp, address, types, rest args):
    vtsched.set_bps(saved_vtsched_bps)  // continue advancing time
    print "Audio stream is starting: in", args[0], "("; args[2], "chan),",
    print "out", args[1], "("; args[3], "chan),", "latency", args[4], 
    print "ms, block size", args[5]
    display "actl_starting", arco_state
    if not set_arco_state('running'):
        return
    prefs.set('audio_open_success', true, true)  // audio did not crash
    arco_ready()
    sched_select(rtsched)
    poll_for_status_id = poll_for_status_id + 1
    poll_for_status(poll_for_status_id)


class Ugen:
    var id  // ugen_id object: our encapsulated Arco id
    var classname  // name of Arco Unit Generator Class
    var chans // output channels
    var rate // output rate: A_RATE or B_RATE
    var inputs  // dictionary of inputs

    # init installs Ugen in table if id is not nil.  If id is nil,
    # no_msg should be true (to suppress /arco/*/new message -- see below).
    # If the Ugen has inputs, they are listed in inputs_ in order
    # as param_symbol, param_value, param_symbol, param_value, ...
    # Even though provided as an array so that we can get the order
    # right when we send the /arco/*/new message, the inputs_ are
    # retained in dictionary form for quick lookup in the set() method.
    # SPECIAL HACK: if no_msg is true, do not send a new message so
    # caller can issue a special message, and IGNORE inputs_
    # SPECIAL HACK #2: if omit_chans is true, omit adding chans as the
    # usual 2nd parameter in the /arco/*/new message.
    #
    # When initial parameters are numbers, they can represent either
    # int32, int64, double, float, time, or be coerced into a Const
    # unit generator. To handle these different interpretations, we
    # require a types_ parameter, which is a string similar to an O2
    # types string consisting of letters from "sihdft" and also "U"
    # which means "unit generator" in which case a number is coerced
    # to a Const. The type string does NOT include an initial "i" for
    # the id or a second "i" for chans, if any. The first type string
    # character refers to the first input value in inputs_. If the
    # type is "U", the actual parameter may also be an array of floats
    # with a length equal to chans_. A Const with multiple channels is
    # created. inputs_ are in pairs, with the name (a symbol) followed
    # by value. If the type is not "U", the name must still be present
    # as a place-holder, and by convention should be a helpful
    # parameter name, but it is ignored. Otherwise, names allow the
    # set method to replace the Ugen input with another Ugen.
    #
    def init(id_, classname_, chans_, rate_, types_,
             keyword no_msg = nil, omit_chans = nil, rest inputs_):
        id = id_
        classname = classname_
        chans = chans_
        rate = rate_
        inputs = {}  // mapping from input name (symbol) to a ugen
        if no_msg:
            return
        // calling const() if needed will send a message, so
        // we coerce all numbers to const() BEFORE constructing
        // the /arco/*/new message:
        for i = 1 to len(inputs_) by 2:
            if types_[idiv(i, 2)] == "U" and (isnumber(inputs_[i]) or
                                              isarray(inputs_[i])):
                inputs_[i] = const(inputs_[i])
        o2_send_start()  // build and send new method
        o2_add_int32(id if isinteger(id) else arco_ugen_id(id))
        if not omit_chans: // some Ugens, (Probe), do not have chans parameter
            display "arco.srp:520", chans, type(chans)
            o2_add_int32(chans)
        // print "sent", "/arco/" + tolower(classname) + "/new, id", id,

        // send the "new" message with parameters to create the Ugen:
        for i = 0 to len(inputs_) by 2:
            var inp = inputs_[i + 1]
            if types_[idiv(i, 2)] == "U":  // it's a Ugen
                o2_add_int32(arco_ugen_id(inp.id))
                inputs[inputs_[i]] = inp  // build dictionary of inputs
            else:  // add a normal value, use code from o2util.srp:
                funcall(TYPE_TO_ADD_TYPE[types_[idiv(i, 2)]], inp)
            // print inputs_[i], inp.id,
        o2_send_finish(0, "/arco/" + tolower(classname) + "/new", true)
        // print


    def play():  # connect this Ugen to audio output
        if this not in arco_output_set:
            arco_output_set.append(this)
            display "Ugen play", id
            o2_send_cmd("/arco/output", 0, "U", id)
        else:
            print "WARNING: in play(), Ugen already in output set", this
        this


    def mute(optional status):  # disconnect this Ugen from audio output
    # since "atend" actions always have a status, we accept a status
    # but ignore it.
        if this in arco_output_set:
            display "Ugen mute", id
            arco_output_set.remove(this)
            o2_send_cmd("/arco/mute", 0, "U", id)
        else:
            print "WARNING: in mute(), Ugen is not in output set", this
        this


    def fade(dur):  # fade to nothing, then disconnect from audio output
        if this in arco_output_set:
            display "Ugen fade", id, dur
            var faded = mult(id, pweb(0, 1, dur, 0))
            o2_send_cmd("/arco/swap", 0, "UU", id, faded.id)
            sched_select(rtsched)
            sched_cause(dur + 0.1, this, 'mute', faded)
        else:
            print "WARNING: in fade(), Ugen is not in output set", this


    def run(optional quiet):  # add this Ugen to the run set
        if this not in arco_run_set:
            arco_run_set.append(this)
            display "Ugen run", id
            o2_send_cmd("/arco/run", 0, "U", id)
        elif not quiet:
            print "WARNING: in run(), Ugen already in run set", this
        this


    def unrun(optional quiet):  # remove this Ugen from the run set
        if this in arco_run_set:
            display "Ugen unrun", id
            arco_run_set.remove(this)
            o2_send_cmd("/arco/unrun", 0, "U", id)
        elif not quiet:
            print "WARNING: in unrun(), Ugen is not in run set", this 
        this


    def get(ugen_name):
        inputs[ugen_name]


    def set(input, value, optional chan = 0):
        var previous = inputs.get(input)
        if not previous:
            if type(input) != 'Symbol':
                print "ERROR: set called with input", input,
                print     "of type", type(input)
            else:
                print "ERROR:", input, "not found in", classname
            breakpoint()
            return
        if isnumber(value):
            if previous.rate == C_RATE:
                // set the output of existing Const object:
                if chan >= previous.chans:
                    print "ERROR: const", input, "of", classname, "has",
                    print previous.chans, "channels but attempt to set channel",
                    print chan
                    breakpoint()
                    return
                o2_send_cmd("/arco/" + tolower(classname) +
                            "/set_" + str(input), 0, "Uif", id, chan, value)
                return
            // otherwise, make a Const object to hold the value
            value = const(value)  // replacing A_RATE or B_RATE with C_RATE
        // value is a Ugen which is the new input value
        inputs[input] = value
        o2_send_cmd("/arco/" + tolower(classname) +
                    "/repl_" + str(input), 0, "UU", id, value.id)
        this


    def atend(action, optional arg):
    # When this unit generator ends, action will be sent to this or, if
    # provided, to arg, which in either case must handle /arco/<class>/act
    # which is currently handled by Pwlb and Fileplay classes.
        if action == MUTE or action == FINISH:
            create_action(this, arg if arg else this, action)
        else:
            print "ERROR: Ugen atend - unknown action", repr(action)


instr_stack = []
def instr_begin():
    instr_stack.append({})

# After instr_begin(), you can define setable parameters in the Instrument
# you are building by calling param. A "setable parameter" associates a
# name to a particular ugen input as if the Instrument itself has that input.
# E.g., if you use an oscillator in the construction of an Instrument and 
# want the Instrument to have a setable parameter named 'myfreq' that
# controls the oscillator frequency, then between instr_begin() and 
# Instrument's init method, call param(oscillator, 'freq', 'myfreq').
# Then you can call instrument.set('myfreq', 440).
#
# Important: the setable parameter connects to a specific unit generator.
# If that unit generator is replaced in the Instrument graph, then setting
# the parameter may not have any effect. The assumption is that the
# Instrument graph is fixed.
#
# Parameters:
#     ugen - the Ugen or Instrument to be controlled
#     input - the symbol name of the ugen input to be controlled
#     name - the setable parameter name (defaults to input)
#
def param(ugen, input, optional name):
    if not name: name = input
    var context = instr_stack.last()
    var ugen_input = context.get(name)
    if ugen_input:
        print "ERROR: in param,", name, "is already defined."
        return
    // if ugen, input are abstractions, drill down to the actual ugen
    while issubclass(ugen, Instrument):
        ugen_input = ugen.parameter_bindings[input]
        ugen = ugen_input[0]
        input = ugen_input[1]
    context[name] = [ugen, input]


# After instr_begin(), you can define a named "member" of the Instrument
# You can access members by name, usually to send them an update, e.g.
#    member(pwl(...), 'env')
#    myinstr = Instrument(...)
#    myinstr.get('env').start()
# The ugen parameter can be an Instrument, in which case the "member"
# is the instrument object, not the Ugen serving as the Instrument output.
#
def member(ugen, name):
    var context = instr_stack.last()
    context[name] = ugen
    ugen


class Instrument (Ugen):
    var parameter_bindings
    var output


    def init(name, ugen):
        super.init(nil, name, ugen.chans, ugen.rate, "",
                   no_msg = true)
        output = ugen
        id = output.id
        parameter_bindings = instr_stack.unappend()
        for key in parameter_bindings.keys():
            var ug = parameter_bindings[key]


    def get(input):
        parameter_bindings.get(input)


    def set(input, value, optional chan = 0):
        var ugen_input = parameter_bindings[input]
        var ugen = ugen_input[0]
        input = ugen_input[1]
        ugen.set(input, value, chan)


def zero(): zero_ugen

def zerob(): zerob_ugen

//def sine(freq, amp, optional chans = 1):
//    Ugen(create_ugen_id(), "Sine", chans, A_RATE, "UU", 'freq', freq, 'amp', amp)
//
//def sineb(freq, amp, optional chans = 1):
//    if freq.rate == A_RATE or amp.rate == A_RATE:
//        print "ERROR: passing audio rate Ugen to block rate sineb"
//        return nil
//    else:
//        return Ugen(create_ugen_id(), "Sineb", chans, B_RATE, "UU", 
//                    'freq', freq, 'amp', amp)

class Const (Ugen):
    def init(x, optional chans = 1):
        if isarray(x):
            chans = max(len(x), 1)
        super.init(create_ugen_id(), "Const", chans, C_RATE, "", no_msg = true)
        if chans > 1:
            o2_send_cmd("/arco/const/new", 0, "Ui", id, chans)
            for i = 0 to chans:  // send "set" message for each channel
                var f = x    if isnumber(x) else
                       (x[i] if len(x) > i  else
                       (x[0] if len(x) == 1 else
                        x.last()))
                o2_send_start()
                o2_add_int32(arco_ugen_id(id))
                o2_add_int32(i)
                o2_add_float(real(f))
                o2_send_finish(0, "/arco/const/set", true)
        else: // simple case - 1 channel Const and initial value in one message
            o2_send_cmd("/arco/const/newf", 0, "Uf", id, x)


def const(x, optional chans = 1):
    return Const(x, chans)
