# arco.srp -- Serpent library for controlling Arco
#
# Roger B. Dannenberg
# Jan 2022

# call arco_init() to start (see def arco_init(...) for options)
# call arco_run() after setting up UI and or scheduling things
# arco_ready is set to true when arco is ready for action

require "debug"
require "sched"
require "o2util"
require "utils"
require "prefs"

FADE_LINEAR = 0
FADE_EXPONENTIAL = 1
FADE_LOWPASS = 2
FADE_SMOOTH = 3

PI = 3.1415926535898
PI_recip = 1/PI
PI2 = 6.2831853071794
PI2_recip = 1/PI2

AR = 44100.0  // audio rate
AP = 1 / AR // audio sample period
BL = 32
BL_RECIP = 1 / BL
BR = AR / BL
BP = 1 / BR

A_RATE = 'a'
B_RATE = 'b'
C_RATE = 'c'

// BPS is set to zero when audio stops to avoid activity that
// cannot be processed by the audio server. BPS is restored
// using this variable:
saved_vtsched_bps = 1.0  // default "tempo"

# states:
#    nil - initial value
#    'discovery' - looking for "arco" service
#    'initializing' - resetting the server
#    'stopped' - initialized, audio is not open
#    'opening' - collecting device info and opening audio device(s)
#    'running' - audio server is running
#    'resetting' - shutting down audio server
#    'quitting' - application is quitting
#
# state transitions:
# (Note: ANY state can transition to 'quitting' when arco_quit() is called.
#  'quitting' is the final state, you cannot transition out of it.)
#
#    nil: start state
#        Action: none
#        -> 'discovery' when arco_init() called by main program
#    'discovery': polling for "arco" service
#        Action: arco_init() polls for discovery of "arco"
#        -> 'initializing' when "arco" service discovered
#    'initializing': waiting for Arco to reset, will open audio
#        Action: reset_arco_handler() sends to /arco/reset
#        -> 'devinf' when receive /actl/reset
#    'devinf': waiting for device info, will normally open audio
#        Action: actl_reset() sends to /arco/devinf, open_audio_handler()
#                is called when last devinf message is received
#        -> 'opening' when open_audio_handler() calls arco_open()
#        -> 'stopped' when device in prefs is not found or if in the previous
#                time the program opened, no audio was opened -- maybe it
#                crashed, so let's stop and let the user see what was in
#                prferences, see other devices, and proceed manually
#    'opening': waiting for Arco audio streaming to start
#        Action: call arco_open(), sends /arco/open
#        -> 'stopped' when /actl/starting called with 0 in and 0 out chans
#        -> 'running' when /actl/starting called
#    'running': computing and streaming audio
#        Action: actl_starting()
#        -> 'stopped' when code calls close_audio_handler() or
#                          Close Audio menu selected
#    'devinf2': waiting for device info, will not open audio
#        Action: rescan_audio_handler() sends /arco/devinf
#        -> 'stopped' when last devinf message received
#    'stopped': initialized, but audio is not running
#        Action: none
#        -> 'devinf2' when Rescan Audio Devices menu selected
#        -> 'opening' when user code calls arco_open() or 
#                          Open Audio menu selected
#        -> 'initializing2' when user code calls reset_arco_handler() or
#                                Reset Arco menu selected
#    'initializing2': waiting for Arco to reset, will not open audio
#        Action: send to /arco/reset
#        -> 'devinf2' when receive /actl/reset
#    'quitting': application is shutting down
#        Action: send to /arco/quit
#
# Shutdown:
#     application calls arco_quit() (one way to implement this
#        is to set default_window.method = 'arco_main_win_handler'. This
#        will call arco_quit() when the main window is closed,
#        delaying exit until a clean shutdown is complete.)
#    arco_quit sends /arco/quit and begins polling with poll_for_no_arco
#    Arco stops running and calls o2sm_finish()
#    poll_for_no_arco detects Arco finish with 
#        o2_shmem_inst_count() == 0 and calls exit()
#        
arco_state = nil
arco_allowed_state_transitions = {  // maps new state to allowed current states
    'discovery': [nil],
    'initializing': 'discovery',
    'devinf': 'initializing',
    'opening': ['devinf', 'stopped'],
    'running': 'opening',
    'stopped': ['opening', 'running', 'devinf', 'devinf2'],
    'devinf2': ['initializing2', 'stopped'],
    'initializing2': 'stopped'}

# This function checks if a transition to newstate is legal. If legal,
# arco_state is changed and return value is true. Otherwise, stay in the
# current state, print a warning and return false.
def set_arco_state(newstate): 
    if newstate != 'quitting':
        allowed = arco_allowed_state_transitions[newstate]
        if arco_state != allowed and ((not isarray(allowed)) or 
                                      (arco_state not in allowed)):
            print "*****************************************************"
            print "* WARNING: Unexpected state transition from", 
            print arco_state, "to", newstate; "."
            return false
    display "arco_state change to", newstate
    arco_state = newstate
    if config_win:
        config_win.set_state(arco_state)
    return true


// atend types for Mix.ins():
SIGNAL = 'signal'
GAIN = 'gain'
BOTH = 'both'
// atend types for ugen.atend(). Various Ugens can send notification of
// end events: Pwlb, Fileplay, ...
MUTE = 'mute'      // standard thing to do at end: call mute() to delete
                   //     a sound instance
FINISH = 'finish'  // custom behavior - the target should implement finish()
                   //     to handle the event

ZERO_ID = 0
ZEROB_ID = 1
INPUT_ID = 2
OUTPUT_ID = 3

// shadow the sets of Ugens maintained by audio server:
arco_run_set = []

// manage action callbacks
next_action_id = 1
action_dict = {}

max_ugen_id_used = 0

def create_ugen_id():
    var uid = arco_ugen_new()
    if arco_ugen_id(uid) > max_ugen_id_used:
        max_ugen_id_used = arco_ugen_id(uid)
    uid


def create_action(ugen, object, method, rest parameters):
# Assign an object, method and parameters to be invoked when
# a unit generator (ugen) sends an action message.
// ugen.action_id is an integer key. Arco sends /actl/act with
//     the key when the Ugen finishes.
// action_dict[key] is a list of actions of the form
//     [ugen, object, method, params], where ugen is the holder of the
//     action_id, which equals key, and the remaining [object, method, params]
//     is the method or function to invoke to perform the action.
// See also atend(), which conveniently invokes 'mute' or 'finish' methods
//     of a unit generator when the ugen's behavior ends.
    var action_list
    var action = [ugen, object, method, parameters]
    if ugen.action_id:
        action_list = action_dict.get(ugen.action_id)
        if not action_list:
            print "ERROR: create_action - action_id not found in action_dict",
            print ugen.action_id
        action_list.append(action)
    else:
        action_dict[next_action_id] = [action]
        ugen.action_id = next_action_id
        o2_send_cmd("/arco/act", 0, "Ui", ugen.id, next_action_id)
        next_action_id = next_action_id + 1
    print "create_action for ugen", ugen.id, "action", ugen.action_id


def actl_act(timestamp, address, types, rest parameters):
# This is an internal handler for actions, which are "callbacks" to notify
# the client of some event (like ending an envelope) in the server.
    display "actl_act", types, parameters
    var key = parameters[0]
    var action_list = action_dict.get(key)
    if not action_list:
        print "ERROR: actl_act - action_id not found in action_dict", key
        return
    var ugen = action_list[0][0]  // all actions start with the same ugen
    ugen.action_id = nil     // clear the action so we can install a new one
    for action in action_list:
        action[3].insert(0, parameters[1])  // make status be first parameter
        general_apply(action[1], action[2], action[3])
    action_dict.remove(key)  // allow garbage collection


# call default_window.method.add_target_method(nil, 'arco_main_win_handler')
# to shut down Arco before your main program exits. default_window is defined
# by require "wxserpent" -- works with wxserpent64 only (not serpent64)
#
def arco_main_win_handler(obj, event, x, y):
# custom main window event handler to catch CLOSE event and (maybe)
# save prefs and then cleanly shut down Arco's audio thread
    if event == WXS_CLOSE_WINDOW:
        display "arco_main_win_handler", event, x, y
        // ask for confirmation:
        if prefs.modified and
           wxs_message_box("Save current settings to preferences?",
                   "Quit Requested", WXS_STYLE_YES_NO, 0) == WXS_MSG_YES:
            prefs.save()
        // request Arco to shut down
        arco_quit()
        // event is handled, so we do not actually quit yet
    else:
        display "arco_main_win_handler", event,
        display     default_window.get_left(), default_window.get_top()



class Arco_window (Window):
# A substitute for Window class that updates preferences when the window
# moves. After instantiating an Arco_window, use set_prefs() to attach
# the window to preferences -- this will move and size the window to values
# stored in prefs, if any.
# Note that Arco_window keeps the window rectangle (position, size) in
# prefs, but not whether the window is open or closed. Window_manager,
# if there is one, does that.
    var prefs

    def init(title, x, y, w, h, optional varname, prefs):
    # init's main function is to apply optional prefs early so any subclass
    # can override prefs width and height by calling fit_to_children()
        super.init(title, x, y, w, h, varname)
        set_prefs(prefs)


    def set_prefs(p):
        if not varname:
            print "WARNING: Arco_window.set_prefs expected varname to be set"
        elif p:
            prefs = p
            var rect = prefs.get(varname)
            display "Arco_window got prefs", varname, rect
            if rect:  // restore the window coordinates and size
                set_position(rect[0], rect[1])
                set_size(rect[2], rect[3])
            else:  // store the current coordinates
                prefs.set(varname,
                          [get_left(), get_top(), get_width(), get_height()])
                display "Arco_window set prefs", varname, prefs.get(varname)


    def on_size(width, height, optional x, y):
    # record new rectangle in preferences, optional params come from on_move()
        if prefs:
            x = x or get_left()
            y = y or get_top()
            prefs.set(varname, [x, y, width, height])
            display "Arco_window on_size", varname, prefs.get(varname)


    def on_move(x, y):
    # record new rectangle in preferences
        display "on_move", x, y, get_width(), get_height()
        on_size(get_width(), get_height(), x, y)



# Capturing movement in the main window requires some tricky code since
# the window is already created using Default_window which ignores on_size()
# and on_move(). Default_window is already a "shadow" for the underlying main
# window which is created directly in wxserpent initialization. Here, we just
# replace control_map[0] so that it "thinks" the default window is now an
# object of type Default_arco_window. Previously, the variable default_window
# was listed in control_names, a list of global control names, so we can just
# leave it there. The original default_window object will be garbage collected
# since the only reference was from default_window. (Actually, if someone has
# copied the reference, say to 'app_window', the only problem is if someone
# also called app_window.add_method_target(), so we'll copy the handlers from
# the original object to our new one.)
#
class Default_arco_window (Arco_window):
    def init():
        id = 0
        nesting = 0
        varname = 'default_window'
        control_map[0] = this
        // in case any handlers are already attached to the old window:
        target = default_window.target
        method = default_window.method

default_window = Default_arco_window()


def file_quit_handler(rest ignore):
    arco_main_win_handler(default_window, WXS_CLOSE_WINDOW, 1, 0)


# To quit, application should call arco_quit(). Alternatively, 
# set default_window.method = 'arco_main_win_handler' to catch
# when main window closes (which would normally shut down the
# application) and instead call arco_quit() to clean up and
# THEN exit the application.
#
def arco_quit(rest ignore):
    o2_send_cmd("/arco/quit", 0)
    poll_for_no_arco()


def poll_for_no_arco()
    print "poll for no arco"
    if o2_shmem_inst_count() == 0:
        arco_thread_poll() // <- just a test to make sure this does not crash
                           // Arco. It should know that Arco is shut down and
                           // just return.
        exit()
    sched_cause(0.1, nil, 'poll_for_no_arco')


IS_WXSERPENT = symbol_value('WXS_DEFAULT_WINDOW') == 0  // is this wxserpent?

audio_devices = []

if IS_WXSERPENT:
    display "####### arco.srp GETTING File MENU FROM", default_window
    audio_devices_menu = default_window.get_menu("File")
    require "audiodev"

arco_open_msg = ""
if get_os() == 'linux':
   arco_open_msg = " If Arco crashes (on Linux) after opening audio, " +
                   "try increasing latency to 100 msec or opening other " +
                   "device(s)."

def actl_devinf(timestamp, address, types, info):
# callback to address /actl/devinf from arco's /arco/devinf.
# info is a string describing an audio device, or "" at end of list.
    if info == "":  // we now have all the audio device info so we can proceed
        display "actl_devinf", repr(info), arco_state
        if arco_state == 'devinf':
            // auto-open in discovery->initializing->devinf->opening->running
            //     sequence:
            if prefs.get('audio_open_success') or
                wxs_message_box("Automatically open audio using preferences?" +
                    arco_open_msg, "Start Audio Now",
                    WXS_STYLE_YES_NO | WXS_STYLE_QUESTION, 0) == WXS_MSG_YES:
                // Apparently, if you jump right into opening audio, someone
                // accesses the File menu before it is even created. So delay
                // auto_open_audio() to allow window creation first:
                print "************** WRONG!!! FIX ME!! *******************"
                sched_select(rtsched)
                sched_cause(0.05, nil, 'auto_open_audio')
            else:
                print "No automatic open, switching to 'stopped' state"
                set_arco_state('stopped')  // did not try to open yet
            return
        // else user just asked to rescan devices (state is 'devinf2'):
        set_arco_state('stopped')
        if IS_WXSERPENT:
            create_device_selections()  // build the radio button selections
        return  // done with devices
    if IS_WXSERPENT:
        audio_devices.append(info)
    elif find(info, "Aggregate") >= 0 or find(info, "default") >= 0:
        var id = int(info)
        print "  --> opening this device, id", id
        arco_open(id, id, arco_input_chans, arco_output_chans,
                  arco_latency, arco_buffersize)
        o2_send_cmd("/arco/prtree", o2_time_get() + 1, "");


def find_one_audio_device(selections, dir):
    var id
    for s in selections:
        var pos = find(s, "(") + 1
        if pos == -1:
            display "Internal error in find_one_audio_device", s, pos
            return nil
        if dir == "outs":
            pos = find(s, ",", pos) + 1
        var chans = int(subseq(s, pos))
        if chans > 0:
            if id:
                print "Multiple devices selected for", 
                print "input." if dir == "ins" else "output."
                return nil
            id = int(s)
    display "find_one_audio_device returns", dir, id
    return id


def arco_init(keyword ensemble="arco", ins = 2, outs = 2, network = t,
              latency = 30, buffersize = BL,
              color, title, o2trace, appname = "arco", dbgmenu = t):
# Initialize arco.
# ensemble - O2 ensemble name
# ins - number of input channels (if real input device has fewer channels, input
#       will be zero-padded to produce ins channels)
# outs - number of output channels (if real output device has fewer channels,
#        output will be wrapped and added so all channels are output)
# network - enables network connections with o2_network_enable(); this enables
#           local area discovery and requests a public IP address.
# latency - audio device latency in ms
# buffersize - buffer size for audio input and output
# color - main window background color (array of [r, g, b])
# title - main window title (string)
# o2trace - debug flags passed to O2 in o2_initialize
# appname - the application name, used to name preference file
# dbgmenu - if true, adds menu items File:"Print Ugen Info" and
#           File:"Arco Ugen GC Info"

    prefs = Prefs(appname)
    display "arco_init setting default window prefs", default_window, prefs
    default_window.set_prefs(prefs)
    arco_master_gain = prefs.get('master_gain', -12.0)

    if not set_arco_state('discovery'):
        return
    // set title and Quit handlers to shut down Arco on exit
    if IS_WXSERPENT
        if title:
            default_window.set_string(title)
        if not color:
            color = [160, 210, 210]
        default_window.set_rgb(color[0], color[1], color[2])
//        default_window.add_target_method(nil, 'arco_main_win_handler')
        display "####### arco_init GETTING File MENU FROM", default_window
        var file_menu = default_window.get_menu("File")
        if dbgmenu:
            file_menu.item("Print Ugen Info", "print Ugen tree and table",
                           nil, nil, 'arco_prugens_handler')
            file_menu.item("Arco Ugen GC Info", "print info about Ugen IDs",
                           nil, nil, 'arco_ugen_gc_info_handler')
        

        file_menu.item("Quit", "quit the application", nil, nil,
                       'file_quit_handler')
        
    arco_input_chans = ins
    arco_output_chans = outs
    arco_latency = latency
    arco_buffersize = buffersize
    sched_init()
    o2_network_enable(network)
    o2_initialize(ensemble, o2trace)
    arco_initialize()  // create audio shared memory interface
    o2_service_new("actl")
    print "service actl created"
    o2_method_new("/actl/devinf", "s", 'actl_devinf', t)
    o2_method_new("/actl/act", "ii", 'actl_act', t)
    o2_method_new("/actl/starting", "iiiiii", 'actl_starting', t)
    o2_method_new("/actl/reset", "", 'actl_reset', t)
    o2_method_new("/actl/cpu", "f", 'actl_cpu', t)
    sched_select(rtsched)
    sched_cause(0.1, nil, 'poll_for_arco')
    if IS_WXSERPENT:
        audiodev_init()


def arco_run():
    sched_poll_function = 'arco_thread_poll'
    sched_o2_enabled = true
    if getfeatures() & OPTION_WXS == 0:
        sched_run()


# Called by application after selecting devices to open. inchan and
# outchan should be the number of input and output channels in the
# PortAudio streams.  These numbers might be adjusted if they do not
# match the device capabilities, which were reported in the /devinf
# messages. The application sees possibly different numbers of
# channels, which are available in the globals arco_input_chans and
# arco_output_chans. The application should not change these, and they
# are set by passing optional values to arco_init().
#
def arco_open(indev, outdev, inchan, outchan, latency, buffersize):
    prefs.set('audio_open_success', nil, true)  // audio crash detect
    if not zero_ugen:
        create_standard_ugens()
    o2_send_cmd("/arco/open", 0, "iiiiiis", indev, outdev,
                inchan, outchan, latency, buffersize, "actl");


arco_get_cpu_load_continuation = nil
arco_get_cpu_load_data = nil

def arco_get_cpu_load(continuation, optional data):
    arco_get_cpu_load_continuation = continuation
    arco_get_cpu_load_data = data
    o2_send_cmd("/arco/cpu", 0, "")  // get and display cpu load


# request a callback with estimated cpu load. Callback can have a
# non-nil 2nd parameter, data, if provided in this call.
def actl_cpu(timestamp, address, types, rest args):
    if arco_get_cpu_load_continuation:
        if arco_get_cpu_load_data:
            funcall(arco_get_cpu_load_continuation, args[0],
                    arco_get_cpu_load_data)
        else:
            funcall(arco_get_cpu_load_continuation, args[0])


def arco_prugens_handler(rest ignore):
    // this tells Arco to print the Ugen tree -- it can be useful for
    //     debugging.
    o2_send_cmd("/arco/prtree", 0, "")
    // also print the list of Ugens accessible by integer ID:
    o2_send_cmd("/arco/prugens", 0, "")


def arco_ugen_gc_info_handler(rest ignore):
    arco_ugen_gc_info()


# Ask Arco to print tree of Ugens:
def arco_prtree():
    o2_send_cmd("/arco/prtree", 0, "");


def arco_gain(x):
    o2_send_cmd("/arco/gain", 0, "f", x)


def arco_heartbeat(x):
    o2_send_cmd("/arco/hb", 0, "i", x)


arco_poll_to_free_ugens_id = 0


# internal function: set up basics after connection established
#
def reset_arco():
    if not set_arco_state('initializing' if arco_state == 'discovery'
                                         else 'initializing2'):
        return
    o2_send_cmd("/arco/reset", 0, "s", "actl")  // pass in this service name
    arco_poll_to_free_ugens_id = arco_poll_to_free_ugens_id + 1
    arco_poll_to_free_ugens(arco_poll_to_free_ugens_id)
    zero_ugen = nil
    zerob_ugen = nil
    input_ugen = nil
    output_ugen = nil


last_gc_cycles = 0

def arco_poll_to_free_ugens(id):
    if id == arco_poll_to_free_ugens_id:
        arco_ugen_gc()  // free Ugen id's on server for all ugen_id's 
        // that the Serpent garbage collector has collected
        sched_cause(0.1, nil, 'arco_poll_to_free_ugens',
                    arco_poll_to_free_ugens_id)
    return
    // debugging information tells when GC happens (disabled)
    if last_gc_cycles != gc_cycles():
        print "******************************************",
        print "Completed", gc_cycles() - last_gc_cycles, 
        print "more GC cycles. Cycle count", gc_cycles()
        last_gc_cycles = gc_cycles()



def actl_reset(rest ignore):
    if not set_arco_state('devinf' if arco_state == 'initializing' 
                                   else 'devinf2'):
        return
    // else arco_state is 'initializing' and we are starting up
    print "**** arco was reset, starting initialization ****"
    arco_ugen_reset()  // new epoch of ugen_id's; all existing are invalidated
    create_standard_ugens()  // restore basic ugens
    audio_devices.clear()
    o2_send_cmd("/arco/devinf", 0, "s", "/actl/devinf")
    arco_ready()



def create_standard_ugens():
    if zero_ugen:
        print "WARNING: create_stanard_ugens -- ugens already created"
        return
    zero_ugen = Zero(ZERO_ID)
    zerob_ugen = Zerob(ZEROB_ID)
    input_ugen = Thru(zero_ugen, arco_input_chans, INPUT_ID)
    output_ugen = Sum(arco_output_chans, true, OUTPUT_ID)


# internal function: wait for arco service, then reset Arco server
#
def poll_for_arco():
    print "poll for arco"
    if o2_status("arco") < O2_LOCAL:
        sched_cause(1.0, nil, 'poll_for_arco')
    else:
        print "**** discovered arco service. initialization starting ****"
        arco_heartbeat(0)  // initially, block count printing is off
        print "*** SENT arco_heartbeat(0) from poll_for_arco ***"
        reset_arco()


// This should be created at most one time:
monitor_audio_manager = nil


# this is an O2 message handler for message sent by audio thread
# when the audio stream is started:
#
def actl_starting(timestamp, address, types, rest args):
    vtsched.set_bps(saved_vtsched_bps)  // continue advancing time
    var in_chans = args[2]
    var out_chans = args[3]
    print "Audio stream is starting: in", args[0], "("; in_chans, "chan),",
    print "out", args[1], "("; out_chans, "chan),", "latency", args[4], 
    print "ms, block size", args[5]
    display "actl_starting", arco_state
    if in_chans == 0 and out_chans == 0:
        print "WARNING: failed to open audio device"
        set_arco_state('stopped')
        return;
    if not set_arco_state('running'):
        return
    prefs.set('audio_open_success', true, true)  // audio did not crash

    // delayed until now when we have audio input and output
    if not monitor_audio_manager:
        monitor_audio_manager = Window_manager("Monitor Audio",
                520, 400, 300, 30, 'mon_win', 'Monitor_audio',
                color = MONITOR_COLOR, prefs = prefs,
                help_string = "open a window to monitor and control audio")
        
    sched_select(rtsched)
    start_poll_for_status()


def max_chans(chans, ugen):
# compute the maximum of chans and the channels implied by ugen, where
# ugen may be a number (Const), array (Const) or Ugen
    max(chans, 1 if isnumber(ugen) else
               (len(ugen) if isarray(ugen) else ugen.chans))


class Ugen:
    var id  // ugen_id object: our encapsulated Arco id
    var classname  // name of Arco Unit Generator Class
    var chans // output channels
    var rate // output rate: A_RATE or B_RATE
    var inputs  // dictionary of inputs
    var action_id  // key to action_dict to get action_list

    # init installs Ugen in table if id is not nil.  If id is nil,
    # no_msg should be true (to suppress /arco/*/new message -- see below).
    # If the Ugen has inputs, they are listed in inputs_ in order
    # as param_symbol, param_value, param_symbol, param_value, ...
    # Even though provided as an array so that we can get the order
    # right when we send the /arco/*/new message, the inputs_ are
    # retained in dictionary form for quick lookup in the set() method.
    # SPECIAL HACK: if no_msg is true, do not send a new message so
    # caller can issue a special message, and IGNORE inputs_
    # SPECIAL HACK #2: if omit_chans is true, omit adding chans as the
    # usual 2nd parameter in the /arco/*/new message.
    #
    # We support polymorphism where constant (Const) inputs can be
    # specified by numbers. For this to work, the init() method needs
    # to know whether a parameter represents a (possibly c-rate) Ugen
    # or just a number. Therefore, there is a types_ parameter for
    # an O2-like type string. As an extension to O2, the type "U" means
    # an Arco Ugen is expected, so numbers will be coerced to a new
    # Const Ugen and an array of numbers will be coerced to a
    # multi-channel Const Ugen.  Other types are one of "sihdft", which
    # have the usual O2 interpretation.
    # 
    # When initial parameters are numbers, they can represent either
    # int32, int64, double, float, time, or be coerced into a Const
    # unit generator. To handle these different interpretations, we
    # require a types_ parameter, which is a string similar to an O2
    # types string consisting of letters from "sihdft" and also "U"
    # which means "unit generator" in which case a number is coerced
    # to a Const. The type string does NOT include an initial "i" for
    # the id or a second "i" for chans, if any. The first type string
    # character refers to the first input value in inputs_.
    #
    # Implementation note: For type "U", in addition to numbers and
    # arrays of numbers, you can pass an instance of (some subclass of)
    # Ugen. The Ugen contains an id field set to a Serpent External
    # of type Ugen_id, which in turn contains the actual Arco ID, which
    # is sent via O2 as type "i" (int32).
    #
    # If the type is not "U", the param_symbol must still be present
    # as a place-holder, and by convention should be a helpful
    # parameter name, but it is ignored. Otherwise, param_symbol allows
    # the set method to replace the Ugen input with another Ugen.
    #
    def init(id_, classname_, chans_, rate_, types_,
             keyword no_msg = nil, omit_chans = nil, rest inputs_):
        id = id_
        classname = classname_
        chans = chans_
        rate = rate_
        inputs = {}  // mapping from input name (symbol) to a ugen
        // in the case of Mix and perhaps others, inputs is an array
        // containing an input name, input ugen and gain ugen
        if no_msg:
            return
        // calling const() if needed will send a message, so
        // we coerce all numbers to const() BEFORE constructing
        // the /arco/*/new message:
        for i = 1 to len(inputs_) by 2:
            if types_[idiv(i, 2)] == "U" and (isnumber(inputs_[i]) or
                                              isarray(inputs_[i])):
                inputs_[i] = const(inputs_[i])
        o2_send_start()  // build and send new method
        o2_add_int32(id if isinteger(id) else arco_ugen_id(id))
        if not omit_chans: // some Ugens, (Probe), do not have chans parameter
            o2_add_int32(chans)
        // print "sent", "/arco/" + tolower(classname) + "/new, id", id,

        // send the "new" message with parameters to create the Ugen:
        for i = 0 to len(inputs_) by 2:
            var inp = inputs_[i + 1]
            if types_[idiv(i, 2)] == "U":  // it's a Ugen
                o2_add_int32(arco_ugen_id(inp.id))
                inputs[inputs_[i]] = inp  // build dictionary of inputs
            else:  // add a normal value, use code from o2util.srp:
                funcall(TYPE_TO_ADD_TYPE[types_[idiv(i, 2)]], inp)
            // print inputs_[i], inp.id,
        o2_send_finish(0, "/arco/" + tolower(classname) + "/new", true)
        // print


    def to_str():
        "<" + str(classname) + " Ugen, id " +
        str(arco_ugen_id(id) if id else nil) + " chans " + str(chans) + ">"


    def play():  # connect this Ugen to audio output
        // display "Ugen play", id
        output_ugen.ins(this)
        this


    def mute(optional status):
    # disconnect this Ugen from audio output
    # since "atend" actions always have a status, we accept a status
    # but ignore it.
        output_ugen.rem(this)
        this


    def fade(dur, keyword mode = FADE_SMOOTH):
    # fade to nothing, then disconnect from audio output. If not already
    # connected to audio output, this will cause Arco to print a warning.
        var fader = fade_in_lookup.get(this)
        if fader:  // fade_in is in progress; convert to fade out
            fade_in_lookup.remove(this)
            fader.set_dur(dur)
            fader.set_goal(0)
            fader.set_mode(mode)
            return fader
        else:
            var faded = fader(this, 1, dur, 0).term()
            output_ugen.swap(this, faded)
            faded.set_mode(mode)
            return faded   // return the new fader ugen


    def fade_in(dur, keyword mode = FADE_SMOOTH, term = true):
    # -- fade from 0 to 1, then disconnect fader. This ugen must
    # *not* be connected to output_ugen (i.e. .play() has not
    # been called. On return, this ugen will be connected
    # through a fader to output_ugen and starting to fade in.
    # After the fade-in, the fader will be removed and this
    # ugen will be connected directly to output_ugen. During
    # the fade-in or after the fade-in, you can call the
    # fade method to fade back out and remove this ugen from
    # the output_ugen.
        var fader = fader(this, 0, dur, 1)
        if term: fader.term()
        fade_in_lookup[this] = fader
        sched_select(rtsched)
        fader.set_mode(mode)
        fader.play()
        sched_cause(dur + 0.1, fader, 'fade_in_complete', this)


    def smooth_disconnect(input_name, ugen, fade_time, 
                          keyword mode = FADE_SMOOTH):
    # fade to nothing over fade_time (seconds); then disconnect from
    # some unit generator at fade_time + 0.1. This must be connected
    # to ugen, which must support a call to the set method as follows:
    #         ugen.set(input_name, zero_ugen)
        var faded = fader(this, 1, fade_time, 0)
        ugen.set(input_name, faded)
        faded.set_mode(mode)
        sched_select(rtsched)
        sched_cause(fade_time + 0.1, ugen, 'set', input_name, zero_ugen)


    def run():  # add this Ugen to the run set
        // display "Ugen run", id
        o2_send_cmd("/arco/run", 0, "U", id)


    def unrun():  # remove this Ugen from the run set
        o2_send_cmd("/arco/unrun", 0, "U", id)


    def get(ugen_name):
        inputs[ugen_name]


    def set(input, value, optional chan = 0):
        var previous = inputs.get(input)
        if not previous:
            if type(input) != 'Symbol':
                print "ERROR: set called with input", input,
                print     "of type", type(input)
            else:
                print "ERROR:", input, "not found in", classname
            breakpoint()
            return
        if isnumber(value):
            if previous.rate == C_RATE:
                // set the output of existing Const object:
                if chan >= previous.chans:
                    print "ERROR: const", input, "of", classname, "has",
                    print previous.chans, "channels but attempt to set channel",
                    print chan
                    breakpoint()
                    return
                o2_send_cmd("/arco/" + tolower(classname) +
                            "/set_" + str(input), 0, "Uif", id, chan, value)
                return
            // otherwise, make a Const object to hold the value
            value = const(value)  // replacing A_RATE or B_RATE with C_RATE
        // value is a Ugen which is the new input value
        inputs[input] = value
        o2_send_cmd("/arco/" + tolower(classname) +
                    "/repl_" + str(input), 0, "UU", id, value.id)
        this


    def atend(action, optional arg):
    # When this unit generator ends, action will be sent to this or, if
    # provided, to arg, which in either case must handle /arco/act
    # which is currently handled by Pwlb and Fileplay classes.
        if action == MUTE or action == FINISH:
            create_action(this, arg if arg else this, action)
        else:
            print "ERROR: Ugen atend - unknown action", repr(action)

    def term(optional dur = 0):
        o2_send_cmd("/arco/term", 0, "Uf", id, dur)
        this

    def trace(optional trace_flag = true):
        o2_send_cmd("/arco/trace", 0, "Ui", id, 1 if trace_flag else 0)
        this


instr_stack = []
def instr_begin():
    instr_stack.append({})

# After instr_begin(), you can define setable parameters in the Instrument
# you are building by calling param. A "setable parameter" associates a
# name to a particular ugen input as if the Instrument itself has that input.
# E.g., if you use an oscillator in the construction of an Instrument and 
# want the Instrument to have a setable parameter named 'myfreq' that
# controls the oscillator frequency, then between instr_begin() and 
# Instrument's init method, call param(oscillator, 'freq', 'myfreq').
# Then you can call instrument.set('myfreq', 440).
#
# Important: the setable parameter connects to a specific unit generator.
# If that unit generator is replaced in the Instrument graph, then setting
# the parameter may not have any effect. The assumption is that the
# Instrument graph is fixed.
#
# Parameters:
#     ugen - the Ugen or Instrument to be controlled
#     input - the symbol name of the ugen input to be controlled
#     name - the setable parameter name (defaults to input)
#
def param(ugen, input, optional name):
    if not name: name = input
    var context = instr_stack.last()
    var ugen_input = context.get(name)
    if ugen_input:
        print "ERROR: in param,", name, "is already defined."
        return
    // if ugen, input are abstractions, drill down to the actual ugen
    while issubclass(ugen, Instrument):
        ugen_input = ugen.parameter_bindings[input]
        ugen = ugen_input[0]
        input = ugen_input[1]
    context[name] = [ugen, input]


# After instr_begin(), you can define a named "member" of the Instrument
# You can access members by name, usually to send them an update, e.g.
#    member(pwl(...), 'env')
#    myinstr = Instrument(...)
#    myinstr.get('env').start()
# The ugen parameter can be an Instrument, in which case the "member"
# is the instrument object, not the Ugen serving as the Instrument output.
#
def member(ugen, name):
    var context = instr_stack.last()
    context[name] = ugen
    ugen


class Instrument (Ugen):
    var parameter_bindings
    var output


    def init(name, ugen):
        super.init(nil, name, ugen.chans, ugen.rate, "",
                   no_msg = true)
        output = ugen
        id = output.id
        if len(instr_stack) == 0:
            error("instr_stack is empty. Maybe you forgot to call " +
                  "instr_begin() at the beginning of your Instrument " +
                  "subclass's init() function")
        parameter_bindings = instr_stack.unappend()
        display "Instrument.init", name, parameter_bindings


    def get(input):
        parameter_bindings.get(input)


    def set(input, value, optional chan = 0):
        var ugen_input = parameter_bindings[input]
        var ugen = ugen_input[0]
        input = ugen_input[1]
        ugen.set(input, value, chan)


def zero(): zero_ugen

def zerob(): zerob_ugen


class Const_like (Ugen):
# abstract superclass for Const and Smoothb, which are similar

    def add_floats(x, msg):
    # finish a message with address msg by adding float values from x
        for i = 0 to chans:
            var f = x if isnumber(x) else (x[i] if len(x) > i else 0)
            o2_add_float(real(f))
        o2_send_finish(0, msg, true)


class Const (Const_like):

    def init(x, optional chans):
    # x is initial value or array of initial values
    # chans defaults to size of x
    # if len(x) > chans (consider len(x) = 1 if isnumber(x)),
    # then extra values are ignored. if len(x) < chans, then
    # if isnumber(x), *all* channels are set to x, and otherwise
    # channels from len(x) are initialized to zero
        var chans_default = max(len(x), 1) if isarray(x) else 1
        chans = chans if chans else chans_default
        super.init(create_ugen_id(), "Const", chans, C_RATE, "", no_msg = true)
        o2_send_start()
        o2_add_int32(arco_ugen_id(id))
        add_floats(x, "/arco/const/newn")
        

    def set(x):
        o2_send_start()
        o2_add_int32(arco_ugen_id(id))
        add_floats(x, "/arco/const/setn")


    def set_chan(chan, x):
        o2_send_cmd("/arco/const/set", 0, "Uif", id, chan, x)


def const(x, optional chans):
    return Const(x, chans)


