# arco.srp -- Serpent library for controlling Arco
#
# Roger B. Dannenberg
# Jan 2022

# call arco_init(ensemble) to start
# call arco_run() after setting up UI and or scheduling things
# arco_ready is set to true when arco is ready for action

require "debug"
require "sched"
require "o2util"
require "utils"

AR = 44100.0  // audio rate
AP = 1 / AR // audio sample period
BL = 32
BL_RECIP = 1 / BL
BR = AR / BL
BP = 1 / BR

# states:
#    nil - initial value and after reset completes
#    'discovery' - looking for "arco" service
#    'initializing' - resetting the server
#    'opening' - opening audio device(s)
#    'running' - audio server is running
#    'resetting' - shutting down audio server
#    'quiting' - 
#
# state transitions:
#    start state is nil
#    main program calls arco_init(): nil -> 'discovery',
#        poll for discovery of "arco" service until found
#    on discovery: arco_initialization() sends /arco/reset, 
#        'discovery' -> 'initializing'
#        Arco replies to /actl/reset handled by actl_reset()
#        send to /arco/devinf
#        'initializing' -> 'opening'
#    Arco sends device info to /host/openaggr (implemented by application)
#        application makes input and output device selections and calls
#        arco_open()n
#    arco_open() creates standard Ugens and sends to /arco/open with
#        Arco replies to /actl/starting, handled by actl_starting()
#    actl_starting() does 'opening' -> 'running' and calls application's
#        arco_ready().  Application now has running audio.
#
#    Shutdown:
#         application calls arco_quit() (one way to implement this
#            is to set default_window.method = 'arco_main_win_handler'. This
#            will call arco_quit() when the main window is closed,
#            delaying exit until a clean shutdown is complete.)
#        arco_quit sends /arco/quit and begins polling with poll_for_no_arco
#        Arco stops running and calls o2sm_finish()
#        poll_for_no_arco detects Arco finish with 
#            o2_shmem_inst_count() == 0 and calls exit()
#        
arco_state = nil
def set_arco_state(state): 
    display "arco_state change", state
    arco_state = state


// atend types for Mix.ins():
SIGNAL = 'signal'
GAIN = 'gain'
BOTH = 'both'
// atend types for Pwlb.atend():
MUTE = 'mute'


ZERO_ID = 0
ZEROB_ID = 1
INPUT_ID = 2
PREV_OUTPUT_ID = 3

// shadow the sets of Ugens maintained by audio server:
aud_output_set = []
aud_run_set = []

// manage action callbacks
next_action_id = 1
action_dict = {}

max_ugen_id_used = 0

def create_ugen_id():
    var uid = arco_ugen_new()
    if arco_ugen_id(uid) > max_ugen_id_used:
        max_ugen_id_used = arco_ugen_id(uid)
    uid


# Ugen.action_id is an integer key. Arco sends /actl/act with the key
# when the Ugen finishes.
# action_dict[key] is a list of actions of the form [object, method, params]
#
def create_action(ugen, object, method, rest parameters):
    var action_list
    var action = [object, method, parameters]
    if ugen.action_id:
        action_list = action_dict.get(ugen.action_id)
        if not action_list:
            print "ERROR: create_action - action_id not found in action_dict",
            print ugen.action_id
        action_list.append(action)
    else:
        action_dict[next_action_id] = [action]
        ugen.action_id = next_action_id
        o2_send_cmd("/arco/" + tolower(ugen.classname) + "/act", 0, "Ui",
                    ugen.id, next_action_id)
        next_action_id = next_action_id + 1
    print "create_action for ugen", ugen.id, "action", ugen.action_id
    watched_action(ugen, "action_list[" + str(ugen.action_id) + "] gets")


def actl_act(timestamp, address, types, rest parameters):
    display "actl_act", types, parameters
    var key = parameters[0]
    action_list = action_dict.get(key)
    if not action_list:
        print "ERROR: actl_act - action_id not found in action_dict", key
        return
    for action in action_list:
        general_apply(action[0], action[1], action[2])
    watched_action(action[0], "action_list[" + str(key) + "] removing")
    action_dict.remove(key)  // allow garbage collection


# assign default_window.method = 'arco_main_win_handler' to quit Arco
# before quitting your main program. default_window is defined by
# require "wxserpent" -- works with wxserpent64 only (not serpent64)
def arco_main_win_handler(obj, event, x, y):
    if event == WXS_CLOSE_WINDOW:
        // request Arco to shut down
        arco_quit()
        // event is handled, so we do not actually quit yet


# To quit, application should call arco_quit(). Alternatively, 
# set default_window.method = 'arco_main_win_handler' to catch
# when main window closes (which would normally shut down the
# application) and instead call arco_quit() to clean up and
# THEN exit the application.
#
def arco_quit(rest ignore):
    o2_send_cmd("/arco/quit", 0)
    o2_send_cmd("/arco/close", 0)
    poll_for_no_arco()


def poll_for_no_arco()
    print "poll for no arco"
    if o2_shmem_inst_count() == 0:
        arco_thread_poll() // <- just a test to make sure this does not crash
                           // Arco. It should know that Arco is shut down and
                           // just return.
        exit()
    sched_cause(0.1, nil, 'poll_for_no_arco')


def arco_init(keyword ensemble="arco", ins = 2, outs = 2, network = t, 
              color, title):
    // set title and Quit handlers to shut down Arco on exit
    if symbol_value('WXS_DEFAULT_WINDOW') == 0:  // is this wxserpent?
        if title:
            default_window.set_string(title)
        if not color:
            color = [160, 210, 210]
        default_window.set_rgb(color[0], color[1], color[2])
        default_window.method = 'arco_main_win_handler'
        var file_menu = default_window.get_menu("File")
        file_menu.item("Quit", "quit the application", nil, nil, 'arco_quit')
        
    arco_input_chans = ins
    arco_output_chans = outs
    sched_init()
    o2_network_enable(network)
    o2_initialize(ensemble, t)
    arco_initialize()  // create audio shared memory interface
    o2_service_new("actl")
    o2_method_new("/actl/act", "i", 'actl_act', t)
    o2_method_new("/actl/starting", "iiiiii", 'actl_starting', t)
    o2_method_new("/actl/reset", "", 'actl_reset', t)
    o2_method_new("/actl/cpu", "f", 'actl_cpu', t)
    sched_select(rtsched)
    set_arco_state('discovery')
    sched_cause(0.1, nil, 'poll_for_arco')


def arco_run():
    sched_poll_function = 'arco_thread_poll'
    sched_o2_enabled = true
    if getfeatures() & OPTION_WXS == 0:
        sched_run()


# Called by application after selecting devices to open. inchan and
# outchan should be the number of input and output channels in the
# PortAudio streams.  These numbers might be adjusted if they do not
# match the device capabilities, which were reported in the /devinfo
# messages. The application sees possibly different numbers of
# channels, which are available in the globals arco_input_chans and
# arco_output_chans. The application should not change these, and they
# are set by passing optional values to arco_init().
#
def arco_open(indev, outdev, inchan, outchan, latency, buffersize):
    create_standard_ugens()
    o2_send_cmd("/arco/open", 0, "iiiiiis", indev, outdev,
                inchan, outchan, latency, buffersize, "actl");


arco_get_cpu_load_continuation = nil
arco_get_cpu_load_data = nil

def arco_get_cpu_load(continuation, optional data):
    arco_get_cpu_load_continuation = continuation
    arco_get_cpu_load_data = data
    o2_send_cmd("/arco/cpu", 0, "")  // get and display cpu load


# request a callback with estimated cpu load. Callback can have a
# non-nil 2nd parameter, data, if provided in this call.
def actl_cpu(timestamp, address, types, rest args):
    if arco_get_cpu_load_continuation:
        if arco_get_cpu_load_data:
            funcall(arco_get_cpu_load_continuation, args[0],
                    arco_get_cpu_load_data)
        else:
            funcall(arco_get_cpu_load_continuation, args[0])
            

# Ask Arco to print tree of Ugens:
def arco_prtree():
    o2_send_cmd("/arco/prtree", 0, "");


arco_poll_to_free_ugens_id = 0


# internal function: set up basics after connection established
#
def arco_initialization():
    print "**** discovered arco service. initialization starting ****"
    set_arco_state('initializing')
    o2_send_cmd("/arco/reset", 0, "s", "actl")  // pass in this service name
    // actl_reset()  // TEMP PATCH
    arco_poll_to_free_ugens_id = arco_poll_to_free_ugens_id + 1
    arco_poll_to_free_ugens(arco_poll_to_free_ugens_id)


last_gc_cycles = 0

def arco_poll_to_free_ugens(id):
    if id == arco_poll_to_free_ugens_id:
        arco_ugen_gc()  // free Ugen id's on server for all ugen_id's 
        // that the Serpent garbage collector has collected
        sched_cause(0.1, nil, 'arco_poll_to_free_ugens',
                    arco_poll_to_free_ugens_id)
    return
    // debugging information tells when GC happens (disabled)
    if last_gc_cycles != gc_cycles():
        print "******************************************",
        print "Completed", gc_cycles() - last_gc_cycles, 
        print "more GC cycles. Cycle count", gc_cycles()
        last_gc_cycles = gc_cycles()


def actl_reset(rest ignore):
    # don't intialize anything if we are cleanly shutting down
    if arco_state == 'resetting':
        set_arco_state(nil)
        return
    // else arco_state is 'initializing' and we are starting up
    print "**** arco was reset, starting initialization ****"
    arco_ugen_reset()  // new epoch of ugen_id's; all existing are invalidated
    set_arco_state('opening')
    o2_send_cmd("/arco/devinf", 0, "s", "/host/openaggr")


def create_standard_ugens()
    zero_ugen = Ugen(arco_ugen_new_id(ZERO_ID), "Zero", -1, 'a')
    o2_send_cmd("/arco/zero/new", 0, "i", ZERO_ID)
    // print "sent /arco/zero/new, id", ZERO_ID

    zerob_ugen = Ugen(arco_ugen_new_id(ZEROB_ID), "Zerob", -1, 'b')
    o2_send_cmd("/arco/zerob/new", 0, "i", ZEROB_ID)
    // print "sent /arco/zerob/new, id", ZEROB_ID

    thru_ugen = Ugen(arco_ugen_new_id(INPUT_ID), "Thru",
                     arco_input_chans, 'a', 'input', zero())

    // previous output can be read here on the next block:
    var tmp = arco_ugen_new_id(PREV_OUTPUT_ID)
    display "made new ugen_id 3 with", arco_ugen_id(tmp)
    output_ugen = Ugen(tmp, "Thru", 
                       arco_output_chans, 'a', 'input', zero())
    display "made prev_output", output_ugen, arco_ugen_id(output_ugen.id)


# internal function: wait for arco service, then run
# arco_initialization
#
def poll_for_arco():
    print "poll for arco"
    if o2_status("arco") < O2_LOCAL:
        sched_cause(1.0, nil, 'poll_for_arco')
    else:
        arco_initialization()


# this is an O2 message handler for message sent by audio thread
# when the audio stream is started:
#
def actl_starting(timestamp, address, types, rest args):
    print "Audio stream is starting: in", args[0], "("; args[2], "chan),",
    print "out", args[1], "("; args[3], "chan),", "latency", args[4], 
    print "ms, block size", args[5]
    set_arco_state('running')
    arco_ready()


class Ugen:
    var id  // ugen_id object: our encapsulated Arco id
    var classname  // name of Arco Unit Generator Class
    var chans // output channels
    var rate // output rate: 'a' or 'b'
    var inputs  // dictionary of inputs

    # init installs Ugen in table if id is not nil.  If id is nil,
    # chans_ should be negative (to suppress /arco/*/new message -- see below).
    # If the Ugen has inputs, they are listed in inputs_ in order
    # as param_symbol, param_value, param_symbol, param_value, ...
    # Even though provided as an array so that we can get the order
    # right when we send the /arco/*/new message, the inputs_ are
    # retained in dictionary form for quick lookup in the set() method.
    # SPECIAL HACK: if chans_ is negative, we set chans to abs(chans_)
    #   so you can still initialize the channel count, but we do not 
    #    send a new message so that caller can issue a special message,
    #    and we IGNORE inputs_
    def init(id_, classname_, chans_, rate_, rest inputs_):
        id = id_
        classname = classname_
        chans = abs(chans_)
        rate = rate_
        inputs = {}  // mapping from input name (symbol) to a ugen
        if chans_ >= 0:
            // calling const() if needed will send a message, so
            // we coerce all numbers to const() BEFORE constructing
            // the /arco/*/new message:
            for i = 1 to len(inputs_) by 2:
                if isnumber(inputs_[i]):
                    inputs_[i] = const(inputs_[i])
            o2_send_start()  // build and send new method
            o2_add_int32(id if isinteger(id) else arco_ugen_id(id))
            o2_add_int32(chans)
            // print "sent", "/arco/" + tolower(classname) + "/new, id", id,
            for i = 0 to len(inputs_) by 2:
                var inp = inputs_[i + 1]
                o2_add_int32(arco_ugen_id(inp.id))
                // print inputs_[i], inp.id,
                inputs[inputs_[i]] = inp  // build dictionary of inputs
            o2_send_finish(0, "/arco/" + tolower(classname) + "/new", true)
            // print


    def play():
        aud_output_set.append(this)
        watched_action(this, "play: ugen added to aud_output_set")
        display "play", id
        o2_send_cmd("/arco/output", 0, "U", id)
        this


    def mute():
        display "Ugen mute", id
        aud_output_set.remove(this)
        watched_action(this, "mute: ugen removed from aud_output_set")
        o2_send_cmd("/arco/mute", 0, "U", id)
        // if you mute something twice, we ignore the redundancy
        this


    def get(ugen_name):
        inputs[ugen_name]


    def set(input, value, optional chan = 0):
        var previous = inputs.get(input)
        if not previous:
            print "ERROR:", input, "not found in", classname
            return
        if isnumber(value):
            if previous.rate == 'c':  // set the output of existing Const object
                if chan >= previous.chans:
                    print "ERROR: const", input, "of", classname, "has",
                    print previous.chans, "channels but attempt to set channel",
                    print chan
                    return
                o2_send_cmd("/arco/" + tolower(classname) + "/set_" + input,
                            0, "Uif", id, chan, value)
                return
            // otherwise, make a Const object to hold the value
            value = const(value)  // replacing 'a' or 'b' with 'c'
        // value is a Ugen which is the new input value
        inputs[input] = value
        o2_send_cmd("/arco/" + tolower(classname) + "/repl_" + input,
                    0, "UU", id, value.id)
        this


    def atend(action, optional arg):
    # When this unit generator ends, action will be sent to this or, if
    # provided, to arg, which in either case must handle /arco/<class>/act
    # which is currently handled by Pwlb and Strplay classes. Currently, 
    # action must be 'mute' or, equivalently, MUTE.
        if action == MUTE:
            create_action(this, arg, action)
        else:
            print "ERROR: Ugen atend - unknown action", repr(action)


instr_stack = []
def instr_begin():
    instr_stack.append({})

# After instr_begin(), you can define setable parameters in the Instrument
# you are building by calling param. A "setable parameter" associates a
# name to a particular ugen input as if the Instrument itself has that input.
# E.g., if you use an oscillator in the construction of an Instrument and 
# want the Instrument to have a setable parameter named 'myfreq' that
# controls the oscillator frequency, then between instr_begin() and 
# Instrument's init method, call param(oscillator, 'freq', 'myfreq').
# Then you can call instrument.set('myfreq', 440).
#
# Important: the setable parameter connects to a specific unit generator.
# If that unit generator is replaced in the Instrument graph, then setting
# the parameter may not have any effect. The assumption is that the
# Instrument graph is fixed.
#
# Parameters:
#     ugen - the Ugen or Instrument to be controlled
#     input - the symbol name of the ugen input to be controlled
#     name - the setable parameter name (defaults to input)
#
def param(ugen, input, optional name):
    if not name: name = input
    var context = instr_stack.last()
    var ugen_input = context.get(name)
    if ugen_input:
        print "ERROR: in param,", name, "is already defined."
        return
    // if ugen, input are abstractions, drill down to the actual ugen
    while issubclass(ugen, Instrument):
        ugen_input = ugen.parameter_bindings[input]
        ugen = ugen_input[0]
        input = ugen_input[1]
    context[name] = [ugen, input]


# After instr_begin(), you can define a named "member" of the Instrument
# You can access members by name, usually to send them an update, e.g.
#    member(pwl(...), 'env')
#    myinstr = Instrument(...)
#    myinstr.get('env').start()
# The ugen parameter can be an Instrument, in which case the "member"
# is the instrument object, not the Ugen serving as the Instrument output.
#
def member(ugen, name):
    var context = instr_stack.last()
    context[name] = ugen
    ugen


class Instrument (Ugen):
    var parameter_bindings
    var output


    def init(name, ugen):
        // pass -ugen.chans to suppress /arco/*/new message
        super.init(nil, name, -ugen.chans, ugen.rate)
        output = ugen
        watched_action(ugen, "ugen is output of " + name)
        id = output.id
        parameter_bindings = instr_stack.unappend()
        for key in parameter_bindings.keys():
            var ug = parameter_bindings[key]
            watched_action(ug, "ugen is " + str(key))


    def get(input):
        parameter_bindings.get(input)


    def set(input, value, optional chan = 0):
        var ugen_input = parameter_bindings[input]
        var ugen = ugen_input[0]
        input = ugen_input[1]
        ugen.set(input, value, chan)


def zero(): zero_ugen

def zerob(): zerob_ugen

def sine(freq, amp, optional chans = 1):
    return Ugen(create_ugen_id(), "Sine", chans, 'a', 'freq', freq, 'amp', amp)

def sineb(freq, amp, optional chans = 1):
    if freq.rate == 'a' or amp.rate == 'a':
        print "ERROR: passing audio rate Ugen to block rate sineb"
        return nil
    else:
        return Ugen(create_ugen_id(), "Sineb", chans, 'b', 'freq', freq, 'amp', amp)

def const(x):
    var ugen = Ugen(create_ugen_id(), "Const", -1, 'c')
    o2_send_cmd("/arco/const/newf", 0, "Uf", ugen.id, x)
    // print "sent /arco/const/newf, id", ugen.id, "value", x
    return ugen


class Pwl (Ugen):
    def init(points):
        super.init(create_ugen_id(), "Pwl", -1, 'a')
        o2_send_cmd("/arco/pwl/new", 0, "U", id)
        set_point_array(points)

    def set_points(rest points):
        set_point_array(points)

    def set_point_array(points):
        o2_send_start()
        o2_add_int32(id)
        # track cummulative time and samples to avoid accumulated time error
        var time = 0
        var count = 0
        for i = 0 to len(points) by 2:
            time = time + points[i]
            var samps = round(time * AR - count)
            count = count + samps
            o2_add_float(samps)  // the number of samples to ramp
            if i + 1 < len(points):  // allowed to omit final zero amplitude
                o2_add_float(points[i + 1])  // the destination amplitude
        o2_send_finish(0, "/arco/pwl/env", true)
        this

    def start():
        o2_send_cmd("/arco/pwl/start", 0, "i", id)
        this


def pwl(rest points): Pwl(points)  # pwl as a function


class Pwlb (Ugen):
    var action_id

    def init(points):
        super.init(create_ugen_id(), "Pwlb", -1, 'b')
        o2_send_cmd("/arco/pwlb/new", 0, "U", id)
        set_point_array(points)

    def set_points(rest points):
        set_point_array(points)

    def set_point_array(points):
        // display "Pwlb", points
        o2_send_start()
        o2_add_int32(arco_ugen_id(id))
        # track cummulative time and samples to avoid accumulated time error
        var time = 0
        var count = 0
        // print "               ";
        for i = 0 to len(points) by 2:
            time = time + points[i]
            var samps = round(time * BR - count)
            count = count + samps
            // print samps,
            o2_add_float(samps)  // the number of samples to ramp
            if i + 1 < len(points):  // allowed to omit final zero amplitude
                print points[i + 1],
                o2_add_float(points[i + 1])  // the destination amplitude
        // print
        o2_send_finish(0, "/arco/pwlb/env", true)
        this

    def start():
        o2_send_cmd("/arco/pwlb/start", 0, "U", id)
        this


def pwlb(rest points): Pwlb(points)


class Mix (Ugen):
    var input_name  // for dictionary of inputs, we need to generate names

    
    def init(chans_):
        input_name = 0
        super.init(create_ugen_id(), "Mix", chans_, 'a')


    def set(input, value, optional chan = 0):
        print "ERROR: set method not available for Mix class"


    def ins(ugen, gain, optional atend):
        if isnumber(gain):
            gain = const(gain)
        inputs[input_name] = [ugen, gain]
        input_name = input_name + 1
        o2_send_cmd("/arco/mix/ins", 0, "UUU", id, ugen.id, gain.id)
        if atend:
            if atend == SIGNAL and issubclass(ugen, Instrument) and 
               ugen.get['envelope']:
                create_action(ugen.envelope, this, 'rem', ugen)
            elif atend == GAIN and issubclass(gain, Pwlb):
                create_action(gain, this, 'rem', ugen)
            else:
                print "Mix.ins() ignoring unknown atend parameter -", atend
        return this
    

    def rem(ugen):
        for key in inputs.keys():
            if inputs[key][0] == ugen:
                inputs.remove(key)
                o2_send_cmd("/arco/mix/rem", 0, "UU", id, ugen.id)
                return this
        return this


    def find_name_of(ugen):
        for key in inputs.keys():
            if inputs[key][0] == ugen:
                return key
        return nil


    def set_gain(ugen, gain):
    # general set gain to either a Ugen or float (constant value)
        // inputs are "named" by numbers that start at 0 and increment for
        // each ins() operation. We do not reuse numbers.
        // Start by finding the input name:
        var i = find_name_of(ugen)
        if not i:
            print "ERROR: Mix set_gain cannot find ugen", ugen
            return
        var gain_ugen = inputs[i][1]
        if isinstance(gain_ugen, Ugen) and gain_ugen.rate == "c":
            // a Const exists, so we just write to it using set_gain
            o2_send_cmd("/arco/mix/set_gain", 0, "UUf", id, ugen, gain)
        else:  // have to replace with either gain as Ugen or make a const
            if isnumber(gain):
                gain = const(gain)
            inputs[i][1] = gain
            o2_send_cmd("/arco/mix/repl_gain", 0, "UUU", id, ugen, gain)
    

def mix(optional chans = 1):
    return Mix(chans)


def reson(input, center, bandwidth, optional chans = 1):
    if input.rate != 'a':
        print "ERROR: input to audio rate reson is not audio rate"
        return nil
    return Ugen(create_ugen_id(), "Reson", chans, 'a', 'input', input, 
                'center', center, 'bandwidth', bandwidth)

def resonb(input, center, bandwidth, optional chans = 1):
    if input.rate == 'a' or center.rate == 'a' or bandwidth.rate == 'a':
        print "ERROR: passing audio rate Ugen to block rate resonb"
        return nil
    return Ugen(create_ugen_id(), "Resonb", chans, 'b', 'input', input, 
                'center', center, 'bandwidth', bandwidth)

def mult(x, y, optional chans = 1):
    return Ugen(create_ugen_id(), "Mult", chans, 'a', 'x', x, 'y', y)

def multb(x, y, optional chans = 1):
    if x.rate == 'a' or x.rate == 'a':
        print "ERROR: passing audio rate Ugen to block rate multb"
        return nil
    return Ugen(create_ugen_id(), "Multb", chans, 'b', 'x', x, 'y', y)

def strplay(filename, optional chans = 2, start = 0, end = 0, cycle, mix, expand)
    return Strplay(filename, chans, start, end, cycle, mix, expand)


class Strplay (Ugen):
    var action_id

    def init(filename, chans, start, end, cycle, mix, expand):
        // -chans cuts off standard creation:
        super.init(create_ugen_id(), "Strplay", -chans, 'a')
        o2_send_start()  // make our own new message
        o2_add_int32(arco_ugen_id(id))
        o2_add_string(filename)
        o2_add_int32(chans)
        o2_add_float(start)
        o2_add_float(end)
        o2_add_bool(cycle)
        o2_add_bool(mix)
        o2_add_bool(expand)
        o2_send_finish(0, "/arco/strplay/new", true)

    def go(optional play_flag = true):
        o2_send_start()  // make our own new message
        o2_add_int32(arco_ugen_id(id))
        o2_add_bool(play_flag)
        o2_send_finish(0, "/arco/strplay/play", true)
    
    def stop():
        go(false)

