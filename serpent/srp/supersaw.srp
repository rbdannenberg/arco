# supersaw.srp -- Instr_design subclass for Supersaw instruments
#
# Roger B. Dannenberg
# Oct 2024

# DEPENDENCIES - the internal values and the parameters they depend on
#
# gain_to_normalize:
#     computed by: calc_tableosc_amps
#     depends on:  rolloff, n, animate
# lowpass cutoff: cutoff
# detune_hz x2: detune
# pitch_const: pitch
# vib_depth x2: lfodepth
# vib freq: lfofreq
# shared_hz x1: pitch
# animate_detune x1: animate
# comp[i] amp:
#     computed by: calc_tableosc_amps
#     depends on:  rolloff, n, animate, gain_to_normalize
# comp[i] table_index: pitch, antialias
# mixer width: width
#
# REVERSING DEPENDENCIES, these are the parameters and what to update
# when they change:
#
# set_rolloff   -> calc_tableosc_amps
# set_animate   -> calc_tableosc_amps, animate_detune x1
# set_cutoff    -> lowpass cutoff
# set_detune    -> detune_hz x2
# set_pitch     -> pitch_const x, shared_hz x1, comp[i] table_index
# set_anirate   -> anirate x
# set_antialias -> comp[i] table_index
# set_width     -> mixer width

require "velocity"

sawtooth_waveforms = nil

class Sawtooth_waveforms:
# manager for a tableosc with precomputed sawtooth waveforms
# there should be only one instance
    var tables   // a tableosc ugen holding shared waveforms
    var created  // array of index or nil - does waveform exist and
                 // at what index?
    var next_index // where to put next waveform

    def init():
        created = array(36)  // cached waveforms for full 2048-point
                             // sawtooth at 0, then steps 4, 8, ... 136
        tables = tableosc(1, 1)
        next_index = 0
        assert(not sawtooth_waveforms)  // this is a singleton class
        sawtooth_waveforms = this
    
    def get_index(step, optional antialias = t):
        var i, f0, n, tlen, ampspec
        if antialias:
            i = max(min(int(step / 4), len(created) - 1), 1)
        else:
            i = 0
        if created[i]:
            return created[i]
        created[i] = next_index

        if antialias:
            f0 = step_to_hz(step)
            n = max(1, int(AR  * 2 / (5 * f0)))
            // note that n * f0 is about (sample-rate / 2) * 4 / 5
            // table len should be 8x oversampled, so 16 * n
            // but limit table size to 16K which would correspond
            // to an f0 of 17 Hz. Otherwise, very low frequencies
            // would lead to very large tables, e.g. 1Hz would, after
            // rounding up to a table size that's a power of 2, lead
            // to a table size of 0.5 M, or 2 MB of memory.
            tlen = min(16384, max(16 * n, 512))
            ampspec = [1 / i for i = 1 to n + 1]
            tables.create_tas(next_index, tlen, ampspec)
        else:  // for the aliasing version, just make a 256-point
               // table. It will be an exact sawtooth due to linear
               // interpolation except for the last 1/256 of the period
               // where linear interpolation will make it ramp down.
            ampspec = [i / 256 for i = 0 to 256]
            tables.create_ttd(next_index, ampspec)
        next_index = next_index + 1
        return next_index - 1


class Supersaw_instr (Instrument):
    // copies of values in note_spec for use by components:
    // var chans -- inherited from Instrument(Ugen)
    var antialias  // select antialiased wavetables, can be updated
    var n  // number of components, the instance's n cannot be updated
    var rndphase  // randomize initial phase, cannot be updated
    var attack  // attack time, can be updated
    var decay   // decay time, can be updated

    // Param_descr's derived from note_spec attribute of the same name.
    // Since these are in the Instrument.parameter_bindings, they can be set
    // while the instance is playing to update the instance:
    var animate  // animation Param_descr from 0 to 1 for use by components
    var rolloff_param  // Param_descr for use by components
    var anirate  // the animation rate Param_descr for use by components
    var lowpass  // controlled by 'cutoff' using set_cutoff() method

    // derived from rolloff and animate
    var gain_to_normalize  // 1 / sqrt(power), based on rolloff and animate

    // needed to cause calc_tableosc_amps to run:
    var recalc_tableosc_amps  // redo power computation
    
    var pitch_const // pitch which is used by all components
    var vib  // the lfo, controlled by 'lfofreq' and 'lfodepth'
    var shared_hz  // addb ugen providing basic frequency (with vib)
    var detune_hz  // a ugen_hzdiff for full detuning range in hz, controlled
                   // by 'detune' in the range 0 to 2 (steps)
    var initial_detune // detune_hz * animate as a real for initialization
    var animate_detune // detune_hz * animate for rlib ugen scaling
    var rolloff  // amplitude rolloff of components with distance from center
                 // this can be set via .set('rolloff', x) via rolloff_param

    var mixer  // a stdistr Ugen, controlled by setable 'width' attribute
    var env
    var components  // array of table_osc ugens

    def init(synth, note_spec, pitch, vel):
        instr_begin()
        if not sawtooth_waveforms:
            Sawtooth_waveforms()  // need singleton
        var chans = note_spec['chans']

        animate = param('animate', note_spec.get('animate', 0), 'clip', 0, 1)
        animate.add_method(this, 'set_animate')

        // note: antialias is a number (0 or 1) that is not passed as a
        // Param_descr to any unit generators, but it *is* used as a number,
        // so we need it to be just a number. To implement
        // .set('antialias', a), we create a Param_descr with param() and
        // attach a method to change antialias and select new waveforms.
        var antialias_param = param('antialias', note_spec.get('antialias', 1),
                                    'clip', 0, 1)
        antialias = antialias_param.value() // get clipped value
        antialias_param.add_method(this, 'set_antialias')

        n = max(1, round(note_spec.get('n', 8)))

        rndphase = note_spec.get('rndphase', 1)

        rolloff = note_spec.get('rolloff', 0)
        rolloff_param = param('rolloff', rolloff, 'clip', 0, 1)
        rolloff_param.add_method(this, 'set_rolloff')

        var table_index = sawtooth_waveforms.get_index(pitch, antialias != 0)
        if chans == 1:
            mixer = sum()
            // note that 'width' is not declared as a parameter if chans == 1
            // so any attempt to set 'width' will do nothing. chans is also
            // not set-able, so if this instrument is created by a synth with
            // chans == 1, it will not be possible to change to chans == 2, so
            // it will always be correct to ignore 'width'
        else:
            var width = param('width', note_spec.get('width', 0), 'clip', 0, 1)
            width.add_method(this, 'set_width')
            mixer = stdistr(n, width.value())
                             
        var attack_param = param('attack', note_spec.get('attack', 0.04),
                                 'clip', 0)
        attack = attack_param.value()  // get clipped value
        attack_param.add_method(this, 'set_attack')

        env = pweb(attack, vel_to_linear(vel), lin = true)
        env.linear_attack().atend(FINISH, this)
        // when instrument ends, it will be removed from the mixer
        // and put on the finishing_notes list, but when it finishes,
        // we should call synth.is_finished(this) to put it on the 
        // free_notes list.

        var cutoff = param('cutoff', note_spec.get('cutoff', 100))
        cutoff.add_method(this, 'set_cutoff')

        var lphz = min(AR * 0.4, step_to_hz(cutoff.value() + pitch))
        lowpass = lowpass(mixer, lphz)
        output = mult(lowpass, env)
        var decay_param = param('decay', note_spec.get('decay', 0.1), 'clip', 0)
        decay = decay_param.value()
        decay_param.add_method(this, 'set_decay')

        // frequency will be hz_to_step(step) + detune + lfo
        // we share vib among all components
        // we combine step, animate, detune and (i, n) to form hz.
        // we use hz and vib to control our oscillator.
        pitch_const = const(pitch)
        var lfofreq = param('lfofreq', note_spec.get('lfofreq', 5),
                            'map', 0, 20)
        var lfodepth = param('lfodepth', note_spec.get('lfodepth', 0),
                             'map', 0, 2)
        vib = sineb(lfofreq, ugen_hzdiffb(pitch_const, lfodepth))

        shared_hz = addb(step_to_hz(pitch), vib)
        var detune = param('detune', note_spec.get('detune', 0), 'map', 0, 2)
        detune_hz = ugen_hzdiffb(pitch_const, detune)
                      
        anirate = param('anirate', note_spec.get('anirate', 1), 'map', 0, 10)
        initial_detune = animate.value() *
                         steps_to_hzdiff(pitch, detune.value())
        animate_detune = multb(animate, detune_hz)

        calc_gain_to_normalize()
        components = [supersaw_component(i, chans, table_index) for i = 0 to n]
        super.init("Supersaw", output, synth)


    def supersaw_component(i, chans, table_index):
    # each component is one sawtooth wave. i is in the range 0 to n-1
    # where n is the total number of sawtooths added together by
    # supersaw.
        var comp  // the component (before panning)
        var animate_fmod = ugen_rlib(anirate, animate_detune)
        animate_fmod.rliset(initial_detune)  // randomize initial hz offset
        // detune_frac gives n points uniformly spaced from -1 to +1:
        var detune_frac = (i * 2) / (n - 1) - 1 if n > 1 else 0
        // fixed detuning amount in hz:
        var fixed_fmod = multb(detune_hz, detune_frac)
        var hz = addb(shared_hz, 
                      blendb(fixed_fmod, animate_fmod, animate))
        var amp = calc_tableosc_amp(i)
        comp = tableosc(hz, amp, phase = rndphase * pr_unif(360))

        comp.borrow(sawtooth_waveforms.tables)
        comp.select(table_index)
        if chans == 1:
            mixer.ins(comp)
        else:
            mixer.ins(i, comp)
        return comp


    def calc_tableosc_amp(i):
    # compute amplitude as a function of gain, i, rolloff, animate
        // ith component with rolloff is rolloff ** k where k increases
        // with distance from the center = (n-1)/2
        var k = abs(i - (n - 1) / 2)
        var ani = animate.value()
        return (ani + (1 - ani) * (rolloff ** k)) * gain_to_normalize


    def calc_gain_to_normalize():
    # compute total power for normalization and set amplitudes of components
        // first, we use a formula for summing n terms in a geometric series
        // created by summing n waveforms with amplitude rolloff^i
        var rsqr = rolloff ** 2
        var power = 1
        if rolloff == 1:
            power = power + (n - 1)
        elif n > 1:  // and rolloff < 1
            power = power + 2 * rsqr * (1 - rolloff ** (n - 1)) / (1 - rsqr)
        // now power is for the case where animate is 0. When animate is 1,
        // there is no rolloff, so power is just n. Since we're interpolating
        // the signals, we can also interpolate the power:
        var ani = animate.value()
        power = n * ani + power * (1 - ani)
        // so we normalize by scaling by 1/sqrt(power):
        gain_to_normalize = 1 / sqrt(power)

        
    def calc_tableosc_amps():
        calc_gain_to_normalize()
        // now we can set amps in components:
        for comp at i in components:
            var amp = calc_tableosc_amp(i)
            comp.set('amp', amp)

        
    def set_rolloff(rolloff_):
        rolloff = rolloff_
        if reuse:
            recalc_tableosc_amps = true
        else:
            calc_tableosc_amps()

            
    def set_attack(attack_):
        attack = attack_


    def set_decay(decay_):
        decay = decay_


    def set_animate(animate_):
        if reuse:
            recalc_tableosc_amps = true
        else:
            calc_tableosc_amps()


    def set_cutoff(cutoff):
    # compute cutoff as sum of pitch and cutoff parameter in steps. Clip
    # to 80% of Nyquist rate to avoid problems.
        lowpass.set('cutoff', min(AR * 0.4, step_to_hz(cutoff + pitch)))


    def set_antialias(antialias_):
        antialias = antialias_
        if not reuse:
            calc_tableosc_index()


    def set_width(width):
        if chans == 2:  // otherwise, mixer is a sum and width does nothing
            mixer.set_width(width)


    def calc_tableosc_index()
        var table_index = sawtooth_waveforms.get_index(pitch, antialias != 0)
        for comp in components:
            comp.select(table_index)


    def set_pitch_vel():
        if recalc_tableosc_amps:
            calc_tableosc_amps()
            recalc_tableosc_amps = false
        // set dependents on pitch:
        pitch_const.set(pitch)
        shared_hz.set('x1', step_to_hz(pitch))
        calc_tableosc_index()
        // start envelope
        env.set_points(attack, vel_to_linear(vel))
        env.start()


    def noteoff():
        env.decay(decay)
        


class Supersaw_synth (Synth):

    def instr_create(note_spec, pitch, vel):
        Supersaw_instr(this, note_spec, pitch, vel)


    def init(instr_spec, customization, chans):
        super.init(instr_spec, customization, chans,
            // parameter names:
            ['animate',  // 0 (fixed) to 1 (fluctuating)
             'anirate',  // rate of animation
             'antialias',  // 0 or 1
             'n',  // num. components, fixed at synth creation
             'rndphase',  // if not 0, randomizes initial phases
             'detune',
             'width',
             'rolloff',
             'attack',
             'decay',
             'cutoff',  // cutoff frequency is steps above pitch
             'lfofreq',
             'lfodepth'])



