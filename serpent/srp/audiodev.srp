# audiodev.srp -- select and control audio devices
#
# Roger B. Dannenberg
# April 2023

# Do not load this directly. It is loaded automatically by arco when
# running in wxserpent.


def audiodev_init()
    audio_devices_menu.item("Configure Audio",
                            "open a window to select audio devices", nil, nil,
                            'configure_audio_handler')
    configure_audio = nil  // must be initialized to know window is not open


# this is called when the application starts. If devices are selected, we can
# open them. Otherwise, we open the Audio Configuration window for the user.
def auto_open_audio():
    var ca = configure_audio
    if not ca
        configure_audio_handler()
    configure_audio.open_audio_handler()
    if not ca
        config_win.delete()
        display "auto_open_audio - deleting config_win", gccyclesst, maxugenst
        configure_audio = nil


# open window to select audio devices
def configure_audio_handler(rest ignore):
    if not configure_audio:
        configure_audio = Configure_audio()
        poll_for_status_id = poll_for_status_id + 1
        poll_for_status(poll_for_status_id)


def find_channels(item, dir):
    var pos = find(item, "(") + 1
    if pos == -1:
        display "Internal error in find_channels", item, pos
        return 0
    if dir == 'out':
        pos = find(item, ",", pos) + 1
    var chans = int(subseq(item, pos))
    return chans


# makes a list of device descriptions where the number of input or output
# channels > 0. dir is 'in' or 'out'. Also strips off the device id but
# constructs a mapping from descriptions to device ids in audio_devices_map.
def find_devices(devs, dir):
    var found = ["None", "Default"]
    for item in devs:
        if find_channels(item, dir) > 0:
            var dev = int(item)
            var pos = find(item, " - ")
            if pos > 0:
                var name = subseq(item, pos + 3)
                audio_devices_map[name] = dev
                found.append(name)
    return found


// references to controls. These are tested to 
// see if controls exist yet, so must be initialized:
config_win = nil
audio_input_rb = nil

def select_preference(rb, items, attr):
    var pref = prefs.get(attr, "Default")
    for name at i in items:
        if name == pref:
            rb.set_value(i)


def create_device_selections():
# create radio boxes to select audio input. Y coord is device_selections_y
    if not config_win:
        return
    if audio_input_rb:
        audio_input_rb.delete()
        audio_output_rb.delete()

    // audio devices are listed in audio_devices as strings
    audio_devices_map = {"None": -2, "Default": -1}
    var input_items = find_devices(audio_devices, 'in')
    var rbheight = 40 + len(input_items) * 20
    Radiobox(config_win, "Audio Input", input_items, 
             10, device_selections_y, 400, rbheight, 'audio_input_rb')
    var bottom = wxs_y + wxs_h
    select_preference(audio_input_rb, input_items, 'audio_in_dev')

    var output_items = find_devices(audio_devices, 'out')
    rbheight = 40 + len(output_items) * 20
    Radiobox(config_win, "Audio Output", output_items, 
             'R', 'S', 'S', rbheight, 'audio_output_rb')
    bottom = max(bottom, wxs_y + wxs_h) + 10
    select_preference(audio_output_rb, output_items, 'audio_out_dev')


poll_for_status_id = 0

def poll_for_status(id):
    if id != poll_for_status_id or not config_win:
        return  // quit this "process"
    display "poll_for_status", gccyclesst, maxugenst
    if gccyclesst:
        gccyclesst.set_string("GC cycles: " + str(gc_cycles()))
        maxugenst.set_string("Max Ugen ID: " + str(max_ugen_id_used))
        arco_get_cpu_load('show_cpu_load')
    sched_cause(1.0, nil, 'poll_for_status', id)


def show_cpu_load(cpu):
    if cpuloadst:  // caution: Static_text control may have been deleted
        cpuloadst.set_string("CPU Load: " + str(round(cpu, 2)))
        cpuloadgauge.set_value(int(100 * cpu))


gccyclesst = nil // text boxes are created after Arco audio is started
cpuloadst = nil

class Configure_audio:
    def init():
        Window("Configure Audio", 520, 20, 850, 360, 'config_win')
        config_win.set_rgb(200, 230, 200)
        config_win.add_target_method(this, 'win_handler')

        Button(config_win, "Open Audio", 10, 10, 100, 'H', 
               'open_audio_button')
        open_audio_button.add_target_method(this, 'open_audio_handler')

        Button(config_win, "Close Audio", 'R', 'S', 'S', 'H', 
               'close_audio_button')
        close_audio_button.add_target_method(this, 'close_audio_handler')

        Button(config_win, "Rescan Audio", 'R', 'S', 'S', 'H', 
               'rescan_audio_button')
        rescan_audio_button.add_target_method(this, 'rescan_audio_handler')

        Button(config_win, "Reset Audio", 'R', 'S', 'S', 'H', 
               'reset_audio_button')
        reset_audio_button.add_target_method(this, 'reset_audio_handler')

        Statictext(config_win, "Cpu Load:", 10, 'D', 110, 20, 'cpuloadst')
        var y = wxs_y  // save y offset
        Gauge(config_win, 100, 'R', y - 3, 120, 20, 'cpuloadgauge')
        wxs_w = 140  // give extra space before GC cycles
        Statictext(config_win, "GC cycles: 0", 'R', y, 100, 20, 'gccyclesst')
        Statictext(config_win, "Max Ugen ID: 0", 'R', y, 130, 20, 'maxugenst')

        wxs_compute_coordinates('S', 'D', 'S', 'S')  // compute Y below maxugenst
        device_selections_y = wxs_y  // save coordinate for future layout
        create_device_selections()


    def win_handler(obj, event, x, y):
        if event == WXS_CLOSE_WINDOW:
            config_win.delete()    // destroy the window and components
            configure_audio = nil  // destroy reference to this object
        wxs_event_not_handled()    // allow window to close


    def device_id(rb, attr):  // compute device id, given radio button
        var dev = rb.item_string(rb.value())
        prefs.set(attr, dev, t)
        audio_devices_map[dev]


    def open_audio_handler(rest ignore):
        if not set_arco_state('opening'):
            return

        var in_dev = device_id(audio_input_rb, 'audio_in_dev')
        var out_dev = device_id(audio_output_rb, 'audio_out_dev')

        display "Calling arco_open", in_dev, out_dev
        // Indicate no input or no output by setting channels to zero:
        arco_open(in_dev, out_dev, 0 if in_dev == -2 else arco_input_chans,
                  0 if out_dev == -2 else arco_output_chans,
                  arco_latency, arco_buffersize)


    def close_audio_handler(rest ignore):
        if not set_arco_state('stopped'):
            return
        saved_vtsched_bps = vtsched.bps
        vtsched.set_bps(STOPPED_BPS)
        o2_send_cmd("/arco/close", 0, "")
        poll_for_status_id = poll_for_status_id + 1


    def rescan_audio_handler(rest ignore):
        if not set_arco_state('devinf2'):
            return
        audio_devices.clear()
        audio_devices_map.clear()
        o2_send_cmd("/arco/devinf", 0, "s", "/actl/devinf")
        

    def reset_audio_handler(rest ignore):
        reset_arco()


audiodev_init()
