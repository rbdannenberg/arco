# arco.srp -- Serpent library for controlling Arco
#
# Roger B. Dannenberg
# May 22 2023

# call arco_init(ensemble) to start
# call arco_run() after setting up UI and or scheduling things
# arco_ready is set to true when arco is ready for action

require "debug"
require "wxserpent"
require "prob"
require "arco"
require "allugens"

SIMPLE = false

default_window.set_size(350, 300) // set size of default window


ui_initialized = false # boolean that denotes if ui has been initialized

def arco_ready():
    # called when arco is initialized and ready to make sound or when
    # arco audio stream has been reopened

    print "**** arco audio is running! ****"
    var win = default_window
    if ui_initialized:
        return

    Statictext(win, "I. Four of a Kind", 5, 5, 150, 'H', 'title') # title of record of interest

    # Record 1 starts and stops recording depending on the selection of the checkbox
    Checkbox(win, "rec1", 5, 25, 'S', 'S', 'r1checkbox') # record 1 Checkbox
    r1checkbox.add_target_method(nil, 'rec1handler')

    # Record 2 plays back track 1 and starts recording track 2
    Checkbox(win, "rec2", 5, 'D', 'S', 'S', 'r2checkbox') # record 2 Checkbox
    r2checkbox.add_target_method(nil, 'rec2handler')

    Checkbox(win, "rec3", 5, 'D', 'S', 'S', 'r3checkbox') # record 3 Checkbox
    r3checkbox.add_target_method(nil, 'rec3handler')

    Checkbox(win, "all", 5, 'D', 'S', 'S', 'allcheckbox') # all Checkbox
    allcheckbox.add_target_method(nil, 'rec4handler')

    Statictext(win, "Latency", 150, 170, 150, 'H', 'text_latency') # audio latency
    # win.id is the integer handle for default_window
    # min: 0, max: 100, but initial is the initial value of the slider
    Slider(win.id, 0, 100, 50, 0, 190, 350, 'S', t, 'latency_slider')

    ui_initialized = true


######## PLAYREC FUNCTIONS ########
recplay1 = nil
recplay2 = nil
recplay3 = nil

def rec1handler(obj, event, x, y):
    display "rec1handler", x
    if x:
        if not recplay1: // long fade time to test this feature
            recplay1 = recplay(input_ugen, 2, 1.0, 3.0, false)
        recplay1.run() # needs be in run set to make active
        recplay1.record(true)
    elif not recplay1:
        print "WARNING: There is no recplay1 Ugen!"
    else:
        recplay1.record(false)
        recplay1.unrun() # does not need to be active now


def rec2handler(obj, event, x, y):
    display "rec2handler", x
    lag = symbol_value(latency_slider).value() // latency value
    lag = lag/1000 // set lag to milliseconds

    if x and recplay1:
        if not recplay2: // long fade time to test this feature
            recplay2 = recplay(input_ugen, 2, 1.0, 3.0, false)
        recplay2.run() # needs be in run set to make active
        recplay2.record(true)

        # Play recplay1
        recplay1.play().atend(MUTE)
        recplay1.start(lag)
    elif not recplay1:
        print "WARNING: There is no recplay1 Ugen!"
    else:
        recplay2.record(false)
        recplay2.unrun() # does not need to be active now
        recplay1.stop() // atend is already set up to mute when finished


def rec3handler(obj, event, x, y):
    display "rec3handler", x
    lag = symbol_value(latency_slider).value() // latency value
    lag = lag/1000 // set lag to milliseconds
    if x:
        if not recplay3: // long fade time to test this feature
            recplay3 = recplay(input_ugen, 2, 1.0, 3.0, false)
        recplay3.run() # needs be in run set to make active
        recplay3.record(true)

        # Play recplay1 and recplay2
        if recplay1 and recplay2:
            recplay1.play().atend(MUTE)
            recplay1.start(lag)
            recplay2.play().atend(MUTE)
            recplay2.start(lag)
        else:
            print "WARNING: There is no recplay1 Ugen!"
    elif not recplay3:
        print "WARNING: There is no recplay1 Ugen!"
    else:
        recplay3.record(false)
        recplay3.unrun() # does not need to be active now
        recplay1.stop() // atend is already set up to mute when finished
        recplay2.stop()


def rec4handler(obj, event, x, y):
    display "rec4handler", x
    lag = symbol_value(latency_slider).value() // latency value
    lag = lag/1000 // set lag to milliseconds
    if x and recplay1 and recplay2 and recplay3:
        recplay1.play().atend(MUTE)
        recplay1.start(lag)
        recplay2.play().atend(MUTE)
        recplay2.start(lag)
        recplay3.play().atend(MUTE)
        recplay3.start(lag)
    elif (not x) and recplay1 and recplay2 and recplay3:
        recplay1.stop()
        recplay2.stop()
        recplay3.stop()


########## Main Initialization ################

def arco_prugens_handler(rest ignore):
    // this tells Arco to print the Ugen tree -- it can be useful for
    //     debugging.
    o2_send_cmd("/arco/prtree", 0, "")
    // also print the list of Ugens accessible by integer ID:
    o2_send_cmd("/arco/prugens", 0, "")


def arco_ugen_gc_info_handler(rest ignore):
    arco_ugen_gc_info()


def main():
    o2_debug_flags("") // ("SsBl")
    arco_init(latency = 60, network = false, title = "Resound Test")
    // this should be replaced by a preference and menu system to select
    // and open audio device(s):
    arco_run()
    sched_select(rtsched)
    display "####### main.srp GETTING File MENU FROM", default_window
    var file_menu = default_window.get_menu("File")
    file_menu.item("Print Ugen Info", "print Ugen tree and table",
                   nil, nil, 'arco_prugens_handler')
    file_menu.item("Arco Ugen GC Info", "print info about Ugen IDs",
                   nil, nil, 'arco_ugen_gc_info_handler')


main()

    

