# init.srp for Separation Logic
#
# Roger B. Dannenberg
# September, 2024

require "debug"
require "wxserpent"
require "prob"
require "arco"
require "allugens"
require "slider"
require "reverb"
require "steps"
require "constraint"
require "air"
require "points"
require "pizz"
require "melo"
require "fast"
require "pan"

MUSIC_PATH = "/Users/rbd/Music/separation-logic/"

SHOWTRIG_X = 280
SHOWTRIG_Y = 360


# Sound files for testing:

audioinput_files = [
        "1-air.wav",    // intro sound, 2 air tones
        "2-points.wav", // short tones that are recorded and layered
        "3-pizz.wav",   // pizz tones that are recorded and layered
        "4-melody.wav", // a lyrical passage that is recorded and layered
        "5-fast.wav",   // fast riffs that are processed and reverbed
        "6-slow.wav",   // not used
        "5-fast-a.wav", // first fast riff only
        "5-fast-b.wav", // 2nd fast riff only
        "5-fast-c.wav", // 3rd fast riff only
        "5-fast-d.wav", // 4th fast riff only
        "5-fast-e.wav", // 5th fast riff only
        "7-fastpoints.wav", // 2-points.wav sped up, not used
        "multiphonic.wav",  // multiphonics
        "sing.wav",     // sung tone with voice sweep
        "singtone.wav", // sung tone steady
        "whistle.wav",  // whistle tones at end
        "long.wav",     // long melody at end
        "air-only.wav"  // just air tones from 1-air.wav used at end
        ]

arco_set_input_files(audioinput_files)

def play_into_input_from(name):
    var fullname = MUSIC_PATH + name
    display "play_into_input_from", name, fullname
    simulate_input_from_file(fullname)

def main():
    arco_init(latency = 10, network = false, title = "Separation Logic",
              appname = "sep")
    arco_run()


ui_initialized = false

class Center_constraint (Simple_constraint):
# constraint that adjusts overall gain for [left, right] that pans to center.
# converts slider value from dB to linear:
    def compute(): return pan_45(0.5, db_to_linear(x))


class Db_constraint (Simple_constraint):
    def compute(): return db_to_linear(x)


def arco_ready():
# called when arco is intialized and ready to make sound or when
# arco audio stream has been reopened
    print "**** arco audio is running! ****"
    var win = default_window
    if ui_initialized:
        return
    test_menu = Menu(win, "Test")
    test_menu.item("Create RBD Control Panel",
                   "creates lots of extra controls for testing",
                   nil, nil, 'create_debug_controls')
    sep_mixer = Sep_mixer()
#TODO: e.g. simulator.cycles_control
    simulator = nil
#    simulator = Simulator()
    air_mgr = Air_mgr()
    sep_cue = Sep_cue()
    trigger_mgr = Trigger_mgr(default_window, SHOWTRIG_X, SHOWTRIG_Y)
    win.fit_to_children()

    // -------- input to output ----------
    monitor_gain_constraint = Center_constraint(0.0)
    monitor_gain = gain_control(route(input_ugen, 0), monitor_gain_sl,
                                monitor_gain_constraint)
    monitor_gain.play()



def create_debug_controls(rest ignore)
    controls = Sep_controls("Separation Logic - Test")


pattern = [5, 7, 9, 12, 6, 8, 10, 13, 2, 4, 5, 9, 6, 8, 10, 13]

shift1 = 0
shift2 = 0
shift3 = 0
cycle_period = 0.1
cycle_transpose = 0


//---------------------- MIDI and CONTROL ---------------------

// create and apply gain constraint connected to a slider

ugen_to_constraint = {}  // mapping from ugen to constraint

def gain_control(input, slider, optional constraint):
# multiply input by gain determined by slider; the result is
# the multiplier that implements gain, so it represents the output
    display "gain_control", input, slider, slider.val, constraint
    if not constraint:
        constraint = Db_constraint()
    constraint.connect(slider)
    var ugen = constraint.get_const()
    ugen_to_constraint[ugen] = constraint
    return mult(input, ugen)


def constrained_ugen_finish(ugen):
# To free some objects (ugen and constraint), call this to shut down
# a gain created by gain_control. ugen is the result of gain_control().
# This is especially important to call if you repeatedly call gain_control.
# E.g. suppose over time you create a 1000 notes, each with a gain_control'd
# output, and the gain_control results (all mult ugens representing the note
# outputs) are all sent the .mute() message. The result will be that you
# still have 1000 constraints attached to and activated by the slider, and
# each constraint change will update an associated const or smoothb ugen.
# Not good! You can solve this by calling constrained_ugen_finish(ugen)
# before calling ugen.mute(). This will detach the constraint from the
# slider, allowing garbage collection to reclaim the mult and const
# (or smoothb).  Alternatively, you could make one gain control, sum *all*
# the notes and apply the gain to the sum. You would then need to detach
# each note output from the mix ugen input when the note ends. Another
# option is do not use gain_control. Instead make and keep one constraint,
# say constraint_1, and apply gain control by
#     output = mult(input, constraint_1.get_const())
# This works because get_const() (or get_smoothb) will return a cached
# const ugen (or smoothb ugen) which will then be shared by all mult ugens.
# To get rid of the single constraint and const, if needed, you can call
# slider.remove_target_method(constraint_1) and then constraint_1 = nil.
    var constraint = ugen_to_constraint.get(ugen)
    if constraint:
        constraint.finish()


// make a trigger indicator

def actl_trig(timestamp, address, types, idnum, rms)
    // display "TRIG ONSET DETECTED:", idnum, rms
    trigger_mgr.trigger()


class Trigger_mgr:
    var trigger_mode
    var trig_ugen  // the unit generator

    def init(win, x, y):
        display "Showtrig init", x, y
        Statictext(win, "Audio trigger:", x, y, 100, 20, 'showtrig_label')
        // window size of 896 is multiple of 32 and ~20ms,
        // gives ~100Hz analysis rate. Pause for 0.2s after trigger:
        trig_ugen = trig(input_ugen, "/actl/trig", 896, 0.01, 0.2)
        o2_method_new("/actl/trig", "if", 'actl_trig', t)
        Eventlight(win, 20, x + 100, y, 'showtrig_light')
        showtrig_light.on_color = "GREEN"

    def start():
        trigger_mode = 'start'

    def trigger():
        showtrig_light.blink()
        // display "Trigger_mgr.trigger", trigger_mode
        if trigger_mode == 'start':
            air_mgr.trigger()
            trigger_mode = nil
        elif trigger_mode == 'gliss':
#TODO: gliss_mgr
            gliss_mgr.gliss_action()

    def enable()
        trig_ugen.run()



// --------------- Cue Display and Actions -----------------

CUE_START = 1 // beginning, wait for audio trigger
CUE_POINTS = 2     // A
CUE_PIZZ = 3       // B
CUE_MELO = 4       // C
CUE_FAST = 5       // D
CUE_ENABLE2 = 6    // E
CUE_GLISS = 7      // F
CUE_GLISSUP = 8    // G
CUE_GLISSNORM = 9  // H
CUE_WHISTLE = 10   // I
CUE_AIR = 11       // J
CUE_END = 12       // K

sep_cue_to_string = ["  ", "0", "A", "B", "C", "D", "E",
                     "F", "G", "H", "I", "J", "K"]

sep_cue_to_descr = ["  ", "Start", "Point", "Pizz", "Melo", "Riffs", "Riffs2",
                    "Droop", "Up", "Norm", "Whistl", "Air", "End"] 

cue_to_file_name = { CUE_START: "1-air.wav",
                     CUE_POINTS: "2-points.wav",
                     CUE_PIZZ: "3-pizz.wav",
                     CUE_MELO: "4-melody.wav" }

class Cue_buttons:
    def init(x, y):
        make_button(CUE_START, 'cue_0_btn', 'cue_0', x = x, y = y)
        make_button(CUE_POINTS, 'cue_a_btn', 'cue_a')
        make_button(CUE_PIZZ, 'cue_b_btn', 'cue_b')
        make_button(CUE_MELO, 'cue_c_btn', 'cue_c')
        make_button(CUE_FAST, 'cue_d_btn', 'cue_d')


    def make_button(i, varname, method, keyword x = 'S', y = 'D'):
        Button(default_window, sep_cue_to_string[i], x, y, 20, 20, varname).
                add_target_method(this, method)
        wxs_x = wxs_x + 25  // move right for descriptive text
        Statictext(default_window, sep_cue_to_descr[i], 'S', 'S', 50, 20)
        wxs_x = wxs_x - 25  // move back to button position
        

    def cue_0(rest ignore):
        print "cue_0"
        sep_cue.set_cue_num(CUE_START)

    def cue_a(rest ignore):
        sep_cue.set_cue_num(CUE_POINTS)

    def cue_b(rest ignore):
        sep_cue.set_cue_num(CUE_PIZZ)

    def cue_c(rest ignore):
        sep_cue.set_cue_num(CUE_MELO)

    def cue_d(rest ignore):
        sep_cue.set_cue_num(CUE_FAST)



class Sep_cue:
    var cue_num
    var advance_last_time


    def init():
        cue_num = 0
        x = 265
        y = 230
        Statictext(default_window, " ", x, y, 80, 100, 'sepcue_text')
        sepcue_text.set_color("YELLOW")
        sepcue_text.set_font(95, WXS_FONT_SWISS, WXS_FONT_NORMAL, WXS_FONT_BOLD,
                             false, "")
        wxs_space = WXS_DEFAULT_SPACE + 10
        Button(default_window, "Skip Cue", x + 85, y, 85, 'H', 'sepskip_btn')
        sepskip_btn.add_target_method(this, 'sep_skip')
        // wxs_y = wxs_y + 20
        Button(default_window, "Sim Cue", 'S', 'D', 'S', 'H', 'sepsim_btn')
        sepsim_btn.add_target_method(this, 'sep_sim')
        // wxs_y = wxs_y + 20
        Button(default_window, "Next Cue", 'S', 'D', 'S', 'H', 'sepcue_btn')
        sepcue_btn.add_target_method(this, 'sep_advance')
        wxs_space = WXS_DEFAULT_SPACE
        advance_last_time = -10
        cue_num = 0
        cue_buttons = Cue_buttons(x + 10, 7)



    def sep_skip(rest ignore):
        set_cue_num(cue_num + 1, "sep_skip")


    def sep_sim(rest ignore):
    # "sim" means play a recording to simulate input. The recording corresponds
    # to the current cue_num.
        print "**** sep_sim", cue_to_string(cue_num)
        var file_name = cue_to_file_name.get(cue_num)
        if file_name:
            play_into_input_from(file_name)
        else:
            print "********* NO INPUT SIMULATION FILE FOR THIS CUE ************"


    def set_cue_num(num, optional source = "set_cue_num"):
        cue_num = num
        sepcue_text.set_string(cue_to_string(cue_num))
        print "****", source, "to", cue_to_string(cue_num)
        // ------- these changes are installed regardless of how we get to the cue:
        if cue_num == CUE_START:
            print "Setting up trigger for CUE_START cue"
            trigger_mgr.enable()  // runs unit generator
            trigger_mgr.start()   // enables "air" section
        elif cue_num == CUE_POINTS:
            points_obj = Points()
        elif cue_num == CUE_PIZZ:
            pizz_rec_obj = Pizz_rec()
            pizz_instr = Pizz(pizz_rec_obj.recplay, 4, 1.5, 3, -1.5, 75)
            pizz_instr.play()
        elif cue_num == CUE_MELO:
            melo_obj = Melo()
        elif cue_num == CUE_FAST:
            fast_obj = Fast()
            fast_obj.cycles_control(true, false)
            // shut down air, points, pizz, melo if running
            YOU ARE HERE
            points_obj


    def sep_advance(rest ignore):
//        print "*** sep_advance turning on trace ***"
//        trace(1)
//        print "*** sep_advance turned on trace ***"
        display "sep_advance", rtsched.time, advance_last_time
        if advance_last_time + 3 > rtsched.time
            print "**** sep_advance: TOO SOON, IGNORING THIS INPUT ****"
            return
        advance_last_time = rtsched.time
        set_cue_num(cue_num + 1, "sep_advance")

        if cue_num == CUE_START:
            nil
        elif cue_num == CUE_POINTS:
            nil
        elif cue_num == CUE_PIZZ:
            nil
        elif cue_num == CUE_MELO:
            nil
        elif cue_num == CUE_FAST:
            simulator.cycles_control(true, false)
        elif cue_num == CUE_ENABLE2:
            fast_instr = Fast()
            fast.play()
        elif cue_num == CUE_GLISS:
            simulator.cycles_control(false, false)

#TODO: fix:

            audio_server <- fast(false)
            audio_server <- gliss(true)
            rtsched.start_use()
            rtsched.cause(30, this, 'pizz_rep')
            rtsched.finish_use()
        elif cue_num == CUE_GLISSUP:
            audio_server <- set_gliss_rate(-20)
        elif cue_num == CUE_GLISSNORM:
            audio_server <- set_gliss_rate(4)
        elif cue_num == CUE_WHISTLE:
            nil // do nothing here!
        elif cue_num == CUE_AIR:
            simulator.cycles_control(true, true)
            audio_server <- wet(0.03)
        elif cue_num == CUE_END:
            audio_server <- endit()
        else:
            simulator.cycles_control(false, true)
            print "WARNING: sep_advace: unknown cue"



    def cue_to_string(n):
        if n > 0 and n < len(sep_cue_to_string):
            sep_cue_to_string[n]
        else:
            "?"


    def pizz_rep():
        pizz_rep_instr = Pizz(pizz_rec_obj.recplay, 48, 1, 6.4, -0.8,
                              pizzrep_gain, 105)
        pizz_rep_rev = Stereo_reverb(pizz_rep_instr, 0.02, 3)
        pizz_rep_rev.play()




// -------------- pizz processing -----------------
//
class Pizz_rec:
    var recplay  // the recplay ugen for recording
    
    def init():
        recplay = recplay(input_ugen, 1, 1, 0.5)
        recplay.run()
        recplay.record(true)
        sched_cause(6.5, this, 'stop_recording')

    def stop_recording():
        recplay.record(false)
        recplay.unrun()


//
#TODO:
#require "midicontrol"

# -------------- control panel/mixer ---------------

//declare_msg_type('set_monitor_gain', "d")
//declare_msg_type('set_intro_gain', "d")
//declare_msg_type('set_points_gain', "d")
//declare_msg_type('set_pizz_gain', "d")
//declare_msg_type('set_melo_gain', "d")
//declare_msg_type('set_fast_gain', "d")
//declare_msg_type('set_droop_gain', "d")
//declare_msg_type('set_ending_gain', "d")

SLIDER_NAMES = ["0 - Intro", "A - Points", "B - Pizz",
                "C - Melody", "D - Riffs", "D - Extra", "E - Droop",
                "Pizz-rep", "Ending"]

SLIDER_SYMBOLS = ['intro_gain_sl', 'points_gain_sl',
                  'pizz_gain_sl', 'melo_gain_sl', 'fast_gain_sl',
                  'cycles_gain_sl', 'droop_gain_sl', 'pizzrep_gain_sl',
                  'ending_gain_sl']



class Sep_mixer:
    var trigger_threshold


    def set_trig_thresh(obj, x):
    # handler for trig_thresh_sl
        display "set_trig_threshold", x
        trigger_mgr.trig_ugen.set_threshold(x)


    def init()
        win = default_window // Arco_window("Mixer", 550, 40, 280, 100)
        // win.set_prefs(prefs)

        Labeled_slider(win, "Flute thru", 10, 5, 250, 'H',
                       80, -60, 20, 0, 'db', 'monitor_gain_sl', prefs = prefs)

        Labeled_slider(win, "Threshold", 'S', 'D', 'S', 'S',
                       80, 0, 2, 0.1, 'linear', 'trig_thresh_sl', prefs = prefs)
        trig_thresh_sl.add_target_method(this, 'set_trig_thresh')

        Labeled_slider(win, "Capture Dly", 'S', 'D', 'S', 'S', 80, 0, 0.5,
                       0.3, 'linear', 'capture_dly_sl', prefs = prefs)

        for name at i in SLIDER_NAMES:
            Labeled_slider(win, name, 'S', 'D', 'S', 'S', 80, -60, 20, 0,
                           'db', SLIDER_SYMBOLS[i], prefs = prefs)

        Button(win, "Save", 'S', 'D', 'S', 'S', 'save_bt')
        save_bt.add_target_method(this, 'save_button_handler')
        
        Button(win, "Reload", 'S', 'D', 'S', 'S', 'reload_bt')
        reload_bt.add_target_method(this, 'reload_button_handler')
        
        win.fit_to_children()


    def save_button_handler(rest ignore)
    # handler for Save button
        prefs.save()
        

    def reload_button_handler(rest ignore)
    # handler for Reload button
        display "reload_button_handler", prefs
        prefs.init(prefs.file_name) // reload prefs from file to restore values
        monitor_gain_sl.set_value(prefs.get('monitor_gain_sl', 0))
        trig_thresh_sl.set_value(prefs.get('trigger_threshold_sl', 1))
        intro_gain_sl.set_value(prefs.get('intro_gain_sl', 1))
        points_gain_sl.set_value(prefs.get('points_gain_sl', 1))
        pizz_gain_sl.set_value(prefs.get('pizz_gain_sl', 1))
        melo_gain_sl.set_value(prefs.get('melo_gain_sl', 1))
        fast_gain_sl.set_value(prefs.get('fast_gain_sl', 1))
        cycles_gain_sl.set_value(prefs.get('cycles_gain_sl', 1))
        droop_gain_sl.set_value(prefs.get('droop_gain_sl', 1))
        pizzrep_gain_sl.set_value(prefs.get('pizzrep_gain_sl', 1))
        ending_gain_sl.set_value(prefs.get('ending_gain_sl', 1))

main()
