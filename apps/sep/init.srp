# init.srp for Separation Logic
#
# Roger B. Dannenberg
# September, 2024

require "debug"
require "wxserpent"
require "prob"
require "arco"
require "allugens"
require "slider"
require "reverb"
require "steps"
require "air"

SHOWTRIG_X = 330
SHOWTRIG_Y = 320


# Sound files for testing:

audioinput_files = ["1-air.wav",    // intro sound, 2 air tones
                    "2-points.wav", // short tones that are recorded and layered
                    "3-pizz.wav",   // pizz tones that are recorded and layered
                    "4-melody.wav", // a lyrical passage that is recorded and layered
                    "5-fast.wav",   // fast riffs that are processed and reverbed
                    "6-slow.wav",   // not used
                    "5-fast-a.wav", // first fast riff only
                    "5-fast-b.wav", // 2nd fast riff only
                    "5-fast-c.wav", // 3rd fast riff only
                    "5-fast-d.wav", // 4th fast riff only
                    "5-fast-e.wav", // 5th fast riff only
                    "7-fastpoints.wav", // 2-points.wav sped up, not used
                    "multiphonic.wav",  // multiphonics
                    "sing.wav",     // sung tone with voice sweep
                    "singtone.wav", // sung tone steady
                    "whistle.wav",  // whistle tones at end
                    "long.wav",     // long melody at end
                    "air-only.wav"  // just air tones from 1-air.wav used at end
                    ]

arco_set_input_files(audioinput_files)

def main():
    arco_init(latency = 10, network = false, title = "Separation Logic",
              appname = "sep")
    arco_run()


ui_initialized = false

def arco_ready():
# called when arco is intialized and ready to make sound or when
# arco audio stream has been reopened
    print "**** arco audio is running! ****"
    var win = default_window
    if ui_initialized:
        return
    test_menu = Menu(win, "Test")
    test_menu.item("Create RBD Control Panel",
                   "creates lots of extra controls for testing",
                   nil, nil, 'create_debug_controls')
    sep_mixer = Sep_mixer()
#TODO: e.g. simulator.cycles_control
    simulator = nil
#    simulator = Simulator()
    air_mgr = Air_mgr()
    sep_cue = Sep_cue()
    trigger_mgr = Trigger_mgr(default_window, SHOWTRIG_X, SHOWTRIG_Y)
    sep_cue = Sep_cue
    win.fit_to_children()


def create_debug_controls(rest ignore)
    controls = Sep_controls("Separation Logic - Test")


pattern = [5, 7, 9, 12, 6, 8, 10, 13, 2, 4, 5, 9, 6, 8, 10, 13]

shift1 = 0
shift2 = 0
shift3 = 0
cycle_period = 0.1
cycle_transpose = 0


//---------------------- MIDI and CONTROL ---------------------

// make a trigger indicator

def actl_trig(timestamp, address, types, idnum, rms)
    display "TRIG ONSET DETECTED:", idnum, rms
    trigger_mgr.trigger()


class Trigger_mgr:
    var trigger_mode
    var trig_ugen  // the unit generator

    def init(win, x, y):
        display "Showtrig init", x, y
        Statictext(win, "Audio trigger:", x, y, 100, 20, 'showtrig_label')
        // window size of 896 is multiple of 32 and ~20ms,
        // gives ~100Hz analysis rate. Pause for 0.2s after trigger:
        trig_ugen = trig(input_ugen, "/actl/trig", 896, 0.01, 0.2)
        o2_method_new("/actl/trig", "if", 'actl_trig', t)
        Eventlight(win, 20, x + 100, y, 'showtrig_light')
        showtrig_light.on_color = "GREEN"

    def start():
        trigger_mode = 'start'

    def trigger():
        showtrig_light.blink()
        if trigger_mode == 'start':
            sched_select(rtsched)
            sched_cause(first_node_delay, air_mgr, 'air', t)
            cause(5, air_mgr, 'airs_stop_recording')
            cause(70, air_mgr, 'air', false)
            trigger_mode = nil
        elif trigger_mode == 'gliss':
#TODO: gliss_mgr
            gliss_mgr.gliss_action()

    def enable()
        trig_ugen.run()



// --------------- Cue Display and Actions -----------------

CUE_START = 1 // beginning, wait for audio trigger
CUE_POINTS = 2     // A
CUE_PIZZ = 3       // B
CUE_MELO = 4       // C
CUE_FAST = 5       // D
CUE_ENABLE2 = 6    // E
CUE_GLISS = 7      // F
CUE_GLISSUP = 8    // G
CUE_GLISSNORM = 9  // H
CUE_WHISTLE = 10   // I
CUE_AIR = 11       // J
CUE_END = 12       // K

sep_cue_to_string = ["  ", "0", "A", "B", "C", "D", "E",
                     "F", "G", "H", "I", "J", "K"]

class Sep_cue:
    var cue_num
    var advance_last_time



    def init():
        cue_num = 0
        Statictext(default_window, " ", 245, 230, 80, 100, 'sepcue_text')
        sepcue_text.set_color("YELLOW")
        sepcue_text.set_font(95, WXS_FONT_SWISS, WXS_FONT_NORMAL, WXS_FONT_BOLD,
                             false, "")
        Button(default_window, "Next Cue", 350, 260, 85, 50, 'sepcue_btn')
        sepcue_btn.add_target_method(this, 'sep_advance')
        advance_last_time = -10
        cue_num = 0


    def sep_advance(rest ignore):
//        print "*** sep_advance turning on trace ***"
//        trace(1)
//        print "*** sep_advance turned on trace ***"
        display "sep_advance", rtsched.time, advance_last_time
        if advance_last_time + 3 > rtsched.time
            print "**** sep_advance: TOO SOON, IGNORING THIS INPUT ****"
            return
        advance_last_time = rtsched.time
        cue_num = cue_num + 1
        if cue_num == CUE_START:
            trigger_mgr.enable()
        elif cue_num == CUE_POINTS:
            points_obj = Points()
        elif cue_num == CUE_PIZZ:
            pizz_rec_obj = Pizz_rec()
            pizz_instr = Pizz(pizz_rec_obj.recplay, 4, 1.5, 3, -1.5,
                              pizz_gain, 75)
            pizz_instr.play()
        elif cue_num == CUE_MELO:
            melo_instr = Melo()
            melo_instr.play()
        elif cue_num == CUE_FAST:
            simulator.cycles_control(true, false)
        elif cue_num == CUE_ENABLE2:
            fast_instr = Fast()
            fast.play()
        elif cue_num == CUE_GLISS:
            simulator.cycles_control(false, false)

#TODO: fix:

            audio_server <- fast(false)
            audio_server <- gliss(true)
            rtsched.start_use()
            rtsched.cause(30, this, 'pizz_rep')
            rtsched.finish_use()
        elif cue_num == CUE_GLISSUP:
            audio_server <- set_gliss_rate(-20)
        elif cue_num == CUE_GLISSNORM:
            audio_server <- set_gliss_rate(4)
        elif cue_num == CUE_WHISTLE:
            nil // do nothing here!
        elif cue_num == CUE_AIR:
            simulator.cycles_control(true, true)
            audio_server <- wet(0.03)
        elif cue_num == CUE_END:
            audio_server <- endit()
        else:
            simulator.cycles_control(false, true)
            print "sep_advace: unknown cue"
        print "**** sep_advance", cue_to_string(cue_num)
        sepcue_text.set_string(cue_to_string(cue_num))


    def cue_to_string(n):
        if n > 0 and n < len(sep_cue_to_string):
            sep_cue_to_string[n]
        else:
            "?"


    def pizz_rep():
        pizz_rep_instr = Pizz(pizz_rec_obj.recplay, 48, 1, 6.4, -0.8,
                              pizzrep_gain, 105)
        pizz_rep_rev = Stereo_reverb(pizz_rep_instr, 0.02, 3)
        pizz_rep_rev.play()



// ------------ points: pointillism processing ---------------
//
class Points:
    var recplay, mix

    def init():
    # pointillistic short flute notes: record and later play
        mix = mix(2)
        recplay = recplay(input_ugen, 1, 1, 0.5)
        recplay.run()
        recplay.record(true)
        sched_select(rtsched)  // for scheduling below

        # launch a bunch of echoes at random offsets
        for i = 0 to 40:
            # start with no rate changes.
            # add rate changes after 17s
            # rate should be from 0.5 to 1.5, with minimum
            # increasing from 0.3 to 1 from 17 to 45s
            # (note: this seems backward - wouldn't that min decrease to
            # expand the range? Nevertheless, this is what was described
            # and implemented, so I'm leaving it this way in 2023. Oh,
            # also max returns to 1 after 45s, so I guess it's intentional
            # to return to no speedup/slowdown after 45s. -RBD)
            var delay = pr_unif(5, 85)
            var rate_min = 1 if delay < 17 else
                           min(1, interpolate(delay, 17, 0.3, 45, 1))
            var rate_max = 1 if delay < 17 or delay > 45 else 1.5
            var rate = unif(rate_min, rate_max)
            var gain = min(1, max(0.2, interpolate(delay, 5, 1, 55, 0.4)))
            // max duration is approx. 85 (max delay) + 47 (dur) = 132
            sched_cause(delay, this, 'echo', i, unif(10), rate, gain)

        mix.play()


    def echo(i, start_time, rate, gain):
        var rp = recplay(zero_ugen, 1, 0.5)
        rp.borrow(recplay)
        rp.set('speed', rate)
        mix.ins(mix_name(i), rp, pan_45(random()))
        rp.start(start_time)


    def stop_recording():
        recplay.record(false)
        recplay.unrun()
        display "stop_recording"


// -------------- pizz processing -----------------
//
class Pizz_rec:
    var recplay  // the recplay ugen for recording
    
    def init():
        recplay = recplay(input_ugen, 1, 1, 0.5)
        recplay.run()
        recplay.record(true)
        sched_cause(6.5, this, 'stop_recording')

    def stop_recording():
        recplay.record(false)
        recplay.unrun()



class Pizz (Instrument):
    var mix, count, off

    def init(recplay, delay_spread, rate_origin, rate_slope, gain, dur):
    # count is number of pizz players to launch
    # delay_spread is the spread in seconds between each launch (not counting
    #       added jitter of 0 to 1 seconds)
    # rate_origin is the initial rate in (half)steps
    # each pizz player's rate (after the initial one) is incremented by
    #       rate_slope (also measured in (half)steps)
        count = count_
        instr_begin()
        mix = mix(2)

        # launch some echos. Each recplayer will be restarted at random
        # times until off; then we stop each one, keeping track with
        # count how many players are acive.
        sched_select(rtsched)  // for scheduling below
        off = false // set true to end everything
        count = 4
        for i = 0 to count:
            var delay = i * delay_spread + random()  # spread out the delays
            // for the first pizz section, rates will be 3, 1.5, 0, -1.5:
            var rate = step_to_ratio(rate_origin + i * rate_slope)
            var rp = recplayer(zero_ugen, 1, 1)
            rp.set('speed', rate)
            rp.borrow(recplay)
            mix.ins(mix_name(i), rp, pan_45(unif(0.3, 0.7), gain))
            sched_cause(delay, 'echo', rp, rate)
        sched_cause(dur, this, 'end_all')
        super.init("Pizz", mix)


    def echo(rp, rate):
        if off:
            count = count - 1
        else:
            rp.start(0)
            sched_cause(6.7 / rate + random(), this, 'echo', rp, rate)

    def end_all():
        display "stopping Pizz", count
        off = true
        if count > 0:
            cause(3, 'end_all')
        else:
            mute()
            // creator should remove references to this instance


// ---------------- Melo processing -----------------
//
class Melo (Instrument):
    var mix, recplay
    
    def init():
        mix = mix(2)
        recplay = recplay(input_ugen, 1, 1, 0.5)
        recplay.run()
        recplay.record(true)

        # launch some echos
        sched_select(rtsched)
        sched_cause(9.3, this, 'echo', 'in9')
        sched_cause(13.3, this, 'echo', 'in13')
        sched_cause(19.7, this, 'echo', 'in20')
        sched_cause(22.6, this, 'echo', 'in23')
        sched_cause(24, this, 'stop_recording')
        sched_cause(45, this, 'stop')

        super.init("Melo", mix)


    def echo(name):
        var rp = recplayer(zero_ugen, 1, 1)
        rp.start(0)
        mix.ins(name, rp, melo_gain)


    def stop():
        recplay.record(false)
        recplay.unrun()
        fade(1)
        

// ----------------- Fast processing -----------------
//
class Fast (Instrument):
    var mix, gated_foo

    def init():
        mix = Mix(2)
        var gf1 = Gated_foo(input_ugen, 0.5, 0.15, 0.6, 100, 1, 1, 0.05, 1)
        mix.ins('gf1', gf1, [1 * fast_gain, 0.75 * fast_gain])

        var gf2 = Gated_foo(input_ugen, 0.3, 0.2, 0.6, 100, 1, 1, 0.05, 1)
        mix.ins('gf2', gf2, [1.2 * fast_gain, 1.6 * fast_gain])

        gated_foo = [gf1, gf2]
        super.init("Fast", mix)
        


#TODO:
#require "midicontrol"

# -------------- control panel/mixer ---------------

//declare_msg_type('set_monitor_gain', "d")
//declare_msg_type('set_intro_gain', "d")
//declare_msg_type('set_points_gain', "d")
//declare_msg_type('set_pizz_gain', "d")
//declare_msg_type('set_melo_gain', "d")
//declare_msg_type('set_fast_gain', "d")
//declare_msg_type('set_droop_gain', "d")
//declare_msg_type('set_ending_gain', "d")

class Sep_mixer:
    var win
    var monitor_gain, trigger_threshold, intro_gain, points_gain
    var pizz_gain, melo_gain, fast_gain, droop_gain, ending_gain

    def set_monitor_gain(obj, x):
    # handler for monitor_gain_sl
        nil

    def set_trig_thresh(obj, x):
    # handler for trig_thresh_sl
        display "set_trig_threshold", x
        trigger_mgr.trig_ugen.set_threshold(x)


    def set_intro_gain(obj, x):
    # handler for intro_gain_sl
        nil


    def set_points_gain(obj, x):
    # handler for points_gain_sl
        nil


    def set_pizz_gain(obj, x):
    # handler for pizz_gain_sl
        nil


    def set_melo_gain(obj, x):
    # handler for melo_gain_sl
        nil


    def set_fast_gain(obj, x):
    # handler for fast_gain_sl
        nil


    def set_cycles_gain(obj, x):
    # handler for cycles_gain_sl
        nil


    def set_droop_gain(obj, x):
    # handler for droop_gain_sl
        nil


    def set_pizzrep_gain(obj, x):
    # handler for pizzrep_gain_sl
        nil


    def init()
        win = Window("Separation Logic", 550, 40, 280, 100)

        Labeled_slider(win, "Flute thru", 10, 5, 250, 'H',
                       80, -60, 20, 0, 'db', 'monitor_gain_sl')
        monitor_gain_sl.add_target_method(this, 'set_monitor_gain')
#TODO: remove these comments containing Aura messages:
        //                            'set_monitor_gain', 0, 2, 0)

        Labeled_slider(win, "Threshold", 'S', 'D', 'S', 'S',
                       80, 0, 2, 0.1, 'linear', 'trig_thresh_sl')
        trig_thresh_sl.add_target_method(this, 'set_trig_thresh')
        //                     'set_trigger_threshold', 0, 2, 0)

        Labeled_slider(win, "0 - Intro", 'S', 'D', 'S', 'S',
                       80, 0, 2, 1, 'linear', 'intro_gain_sl')
        intro_gain_sl.add_target_method(this, 'set_intro_gain')
        //                          'set_intro_gain', 0, 2, 1)

        Labeled_slider(win, "A - Points", 'S', 'D', 'S', 'S',
                       80, 0, 2, 1, 'linear', 'points_gain_sl')
        points_gain_sl.add_target_method(this, 'set_points_gain')
        //                           'set_points_gain', 0, 2, 1)

        Labeled_slider(win, "B - Pizz", 'S', 'D', 'S', 'S',
                       80, 0, 2, 1, 'linear', 'pizz_gain_sl')
        pizz_gain_sl.add_target_method(this, 'set_pizz_gain')
        //                         'set_pizz_gain', 0, 2, 1)

        Labeled_slider(win, "C - Melody", 'S', 'D', 'S', 'S',
                       80, 0, 2, 1, 'linear', 'melo_gain_sl')
        melo_gain_sl.add_target_method(this, 'set_melo_gain')
        //                         'set_melo_gain', 0, 2, 1)

        Labeled_slider(win, "D - Riffs", 'S', 'D', 'S', 'S',
                       80, 0, 2, 1, 'linear', 'fast_gain_sl')
        fast_gain_sl.add_target_method(this, 'set_fast_gain')
        //                         'set_fast_gain', 0, 2, 1)

        Labeled_slider(win, "D - Extra", 'S', 'D', 'S', 'S',
                       80, 0, 2, 1, 'linear', 'cycles_gain_sl')
        cycles_gain_sl.add_target_method(this, 'set_cycles_gain')
        //                           'set_cycles_gain', 0, 2, 1)

        Labeled_slider(win, "E - Droop", 'S', 'D', 'S', 'S',
                       80, 0, 2, 1, 'linear', 'droop_gain_sl')
        droop_gain_sl.add_target_method(this, 'set_droop_gain')
        //                          'set_droop_gain', 0, 2, 1)

        Labeled_slider(win, "Pizz-rep", 'S', 'D', 'S', 'S',
                       80, 0, 2, 1, 'linear', 'pizzrep_gain_sl')
        pizzrep_gain_sl.add_target_method(this, 'set_pizzrep_gain')
        //                            'set_pizzrep_gain', 0, 2, 1)

        Labeled_slider(win, "Ending", 'S', 'D', 'S', 'S',
                       80, 0, 2, 1, 'linear', 'ending_gain_sl')
        ending_gain_sl.add_target_method(this, 'set_ending_gain')
        //                           'set_ending_gain', 0, 2, 1)

        Button(win, "Save", 80, 'D', 'S', 'S', 'save_bt')
        save_bt.add_target_method(this, 'save_button_handler')
        
        Button(win, "Reload", 'S', 'D', 'S', 'S', 'reload_bt')
        reload_bt.add_target_method(this, 'reload_button_handler')
        
        win.fit_to_children()
        reload_button_handler()


    def save_button_handler(rest ignore)
    # handler for Save button
        prefs.set('monitor_gain', monitor_gain_sl.val)
        prefs.set('trigger_threshold', trig_thresh_sl.val)
        prefs.set('intro_gain', intro_gain_sl.val)
        prefs.set('points_gain', points_gain_sl.val)
        prefs.set('pizz_gain', pizz_gain_sl.val)
        prefs.set('melo_gain', melo_gain_sl.val)
        prefs.set('fast_gain', fast_gain_sl.val)
        prefs.set('cycles_gain', fast_gain_sl.val)
        prefs.set('droop_gain', droop_gain_sl.val)
        prefs.set('pizzrep_gain', pizzrep_gain_sl.val)
        prefs.set('ending_gain', ending_gain_sl.val)
        prefs.save()
        

    def reload_button_handler(rest ignore)
    # handler for Reload button
        display "reload_button_handler", prefs
        monitor_gain_sl.set_value(prefs.get('monitor_gain', 0))
        trig_thresh_sl.set_value(prefs.get('trigger_threshold', 1))
        intro_gain_sl.set_value(prefs.get('intro_gain', 1))
        points_gain_sl.set_value(prefs.get('points_gain', 1))
        pizz_gain_sl.set_value(prefs.get('pizz_gain', 1))
        melo_gain_sl.set_value(prefs.get('melo_gain', 1))
        fast_gain_sl.set_value(prefs.get('fast_gain', 1))
        cycles_gain_sl.set_value(prefs.get('cycles_gain', 1))
        droop_gain_sl.set_value(prefs.get('droop_gain', 1))
        pizzrep_gain_sl.set_value(prefs.get('pizzrep_gain', 1))
        ending_gain_sl.set_value(prefs.get('ending_gain', 1))

main()
