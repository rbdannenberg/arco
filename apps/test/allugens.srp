 
 
# vu.srp -- record and play audio in memory
#
# Roger B. Dannenberg
# May 2023

def vu(reply_addr, period):
    Vu(reply_addr, period)


class Vu (Ugen):
    def init(reply_addr, period)
        super.init(create_ugen_id(), "Vu", 0, '', "sf",
                   'reply_addr', reply_addr, 'period', period)

    def start(reply_addr, period):
        o2_send_cmd("/arco/vu/start", 0, "Usf", id, reply_addr, period)
        this

    def set(input, value):  // patterned after Ugen.set()
        // Note that the only thing you can set is 'input'
        inputs['input'] = value
        display "Vu set", id, value.id
        o2_send_cmd("/arco/vu/repl_input", 0, "UU", id, value.id)
        this
 
 
 
# probe.srp -- stream audio from file
#
# Roger B. Dannenberg
# May 2023

def probe(input, reply_addr)
    Probe(input, reply_addr)



class Probe (Ugen):
    var running

    def init(input, reply_addr):
        super.init(create_ugen_id(), "Probe", 0, '', "Us",
                   omit_chans = t,
                   'input', input, 'reply_addr', reply_addr)

    def probe(period, frames, chan, nchans, stride):
        o2_send_cmd("/arco/probe/probe", 0, "Ufiiii", id, period,
                    frames, chan, nchans, stride)
        if not running:
            run() // suppress warning if we're already in run setx
            running = true
        this

    def thresh(threshold, direction, max_wait):
        o2_send_cmd("/arco/probe/thresh", 0, "Ufif", id,
                    threshold, direction, max_wait)
        this
        
    def stop():
        o2_send_cmd("/arco/probe/stop", 0, "U", id)
        if running:
            unrun()
            running = false
        this
        
 
 
 
# pwl.srp -- piece-wise linear envelope
#
# Roger B. Dannenberg
# May 2023

require "envelope"

class Pwl (Envelope):
    def init(points):
        super.init("Pwl", "/arco/pwl/", 'a', points)

def pwl(keyword init, start = true, rest points):
    envelope(Pwl(points), init, start)


class Pwlb (Envelope):
    def init(points):
        super.init("Pwlb", "/arco/pwlb/", 'b', points)

def pwlb(keyword init, start = true, rest points):
    envelope(Pwlb(points), init, start)
 
 
 
# pwe.srp -- piece-wise exponential envelope
#
# Roger B. Dannenberg
# May 2023

require "envelope"

class Pwe (Envelope):
    def init(points):
        super.init("Pwe", "/arco/pwe/", 'a', points)

def pwe(keyword init, start = true, lin = false, rest points):
    envelope(Pwe(points), init, start, lin)


class Pweb (Envelope):
    def init(points):
        super.init("Pweb", "/arco/pweb/", 'b', points)

def pweb(keyword init, start = true, lin = false, rest points):
    envelope(Pweb(points), init, start, lin)
 
 
 
# mix.srp -- audio mixer
#
# Roger B. Dannenberg
# May 2023

class Mix (Ugen):
    
    def init(chans_, wrap):
        super.init(create_ugen_id(), "Mix", chans_, A_RATE,
                   "i", 'wrap', 1 if wrap else 0)
        register_action(this, ACTION_REM, this, 'action_rem')


    def action_rem(status, uid, parameters):
        // find input with uid if any
        display "Mix.action_rem", status, uid, parameters
        for input in inputs.values():  // [name, ugen, gain] arrays
            var ugen = input[1]
            if arco_ugen_id(ugen.id) == uid:
                inputs.remove(input[0])
            
        
    def set(input, value, optional chan = 0):
        print "ERROR: set method called but not available for Mix class"


    def ins(name, ugen, gain, optional dur, mode, keyword atend):
        if isnumber(gain) or isarray(gain):
            gain = const(gain)
        elif gain.rate == 'a':
            print "WARNING: In Mix.ins, audio-rate mix gain must not be audio."
            return
        if not dur:
            dur = 0
        if not mode:
            mode = FADE_SMOOTH
        inputs[name] = [name, ugen, gain]
        o2_send_cmd("/arco/mix/ins", 0, "UsUUfi", id, str(name), ugen.id, 
                                                      gain.id, dur, mode)
        if atend:
            var env = ugen.get['envelope']
            if atend == SIGNAL and issubclass(ugen, Instrument) and env:
                create_action(env, this, 'rem', ugen)
            elif atend == GAIN and issubclass(gain, Pwlb):
                create_action(gain, this, 'rem', ugen)
            else:
                print "WARNING: In Mix.ins() ignoring unknown atend",
                print "parameter -", atend
        return this
    

    def rem(name, dur, mode):
        if inputs.has_key(name) or force:
            if not dur:
                dur = 0
            if not mode:
                mode = FADE_SMOOTH
            o2_send_cmd("/arco/mix/rem", 0, "Usfi", id, str(name), dur, mode)
            display "/arco/mix/rem", id, str(name), dur, mode
            inputs.remove(name)
        return this


    def find_name_of(ugen):
        for key in inputs.keys():
            if inputs[key][1] == ugen:
                return key
        return nil


    def set_gain(name, gain, optional chan = 0):
    # general set gain to either a Ugen or float (constant value)
        if not inputs.has_key(name):
            print "ERROR: Mix.set_gain() cannot find input", name
            return
        var gain_ugen = inputs[name][2]
        display "in set_gain", inputs[name], gain_ugen, repr(gain_ugen.rate)
        if isinstance(gain_ugen, Ugen) and gain_ugen.rate == C_RATE:
            if chan >= gain_ugen.chans:
                print "WARNING: In Mix.set_gain(), gain for", name, "is a", 
                print gain_ugen.chans, 
                print "channel Const, but set_gain requests channel", chan
            // a Const exists, so we just write to it using set_gain
            // display "mix set_gain, calling /set_gain", id, name, chan, gain
            o2_send_cmd("/arco/mix/set_gain", 0, "Usif", id, str(name),
                                                         chan, gain)
        else:  // have to replace with either gain as Ugen or make a const
            if isnumber(gain) or isarray(gain):
                if chan != 0:
                    print "WARNING: In Mix.set_gain(), creating a Const,",
                    print "but chan != 0"
                gain = const(gain)
                // display "mix set_gain is number(s), convert", gain.id
            elif gain.rate == 'a':
                print "WARNING: In Mix.set_gain(), audio-rate mix gain",
                print "will be downsampled and then interpolated"
            inputs[name][2] = gain
            // display "mix set_gain, calling /repl_gain", id, name, gain.id
            o2_send_cmd("/arco/mix/repl_gain", 0, "UsU", id, str(name), gain.id)
        this


def mix(optional chans = 1, keyword wrap = true):
    Mix(chans, wrap)


def mix_name(i):
# handy function to convert index into a symbol to name an input when
# inputs are originally created in a loop or come from an array
    intern("in" + str(i))
 
 
 
# sine.srp - constructor implementation
#
# (machine generated by u2f.py)

def sine(freq, amp, optional chans):
    if not chans:
        chans = max_chans(max_chans(1, freq), amp)
    Ugen(create_ugen_id(), "sine", chans, 'a', "UU", 'freq', freq, 'amp', amp)

def sineb(freq, amp, optional chans):
    if not isnumber(freq) and freq.rate == 'a':
        print "ERROR: 'freq' input to Ugen 'sineb' must be block rate"
        return nil
    if not isnumber(amp) and amp.rate == 'a':
        print "ERROR: 'amp' input to Ugen 'sineb' must be block rate"
        return nil
    if not chans:
        chans = max_chans(max_chans(1, freq), amp)
    Ugen(create_ugen_id(), "sineb", chans, 'b', "UU", 'freq', freq, 'amp', amp)

 
 
 
# mathugen.srp - constructor implementation for mult, add, ugen_div, ugen_max,
#           ugen_min, ugen_clip, ugen_less, ugen_greater, ugen_soft_clip.
#           For completeness, you can create a Math as well with ugen_math.

MATH_OP_MUL = 0
MATH_OP_ADD = 1
MATH_OP_SUB = 2
MATH_OP_DIV = 3
MATH_OP_MAX = 4
MATH_OP_MIN = 5
MATH_OP_CLP = 6  // min(max(x, -y), y) i.e. clip if |x| > y
MATH_OP_POW = 7
MATH_OP_LT = 8
MATH_OP_GT = 9
MATH_OP_SCP = 10
MATH_OP_PWI = 11
MATH_OP_RND = 12
MATH_OP_SH = 13
MATH_OP_QNT = 14
MATH_OP_RLI = 15
MATH_OP_HZDIFF = 16

class Math (Ugen):
    def init(op, x1, x2, optional chans):
        if not chans:
            chans = max_chans(max_chans(1, x1), x2)
        super.init(create_ugen_id(), "math", chans, 'a', "iUU",
                   'op', op, 'x1', x1, 'x2', x2)
    def rliset(x):
    # randomize initial values (only for op == MATH_OP_RLI)
        o2_send_cmd("/arco/math/rliset", 0, "Uf", id, x)


class Mathb (Ugen):
    # NOTE: initialization may fail if x1 or x2 are incompatible
    # An object is created and returned but its id will be nil
    def init(op, x1, x2, optional chans):
        if not isnumber(x1) and x1.rate == 'a':
            display "ERROR: 'x1' input to Ugen 'mathb' must be block rate",
            display op, x1
        elif not isnumber(x2) and x2.rate == 'a':
            display "ERROR: 'x2' input to Ugen 'mathb' must be block rate",
            display op, x2
        else:
            chans = chans or max_chans(max_chans(1, x1), x2)
            super.init(create_ugen_id(), "mathb", chans, 'b', "iUU",
                       'op', op, 'x1', x1, 'x2', x2)

    def rliset(x):
        o2_send_cmd("/arco/mathb/rliset", 0, "Uf", id, x)


def mult(x1, x2, optional chans, keyword x2_init):
    if x2_init:
        if not chans:
            chans = max_chans(max_chans(1, x1), x2)
        Ugen(create_ugen_id(), "multx", chans, 'a', "UUf", 'x1', x1, 'x2', x2,
             'init', x2_init)
    else:
        Math(MATH_OP_MUL, x1, x2, chans)


def multb(x1, x2, optional chans):
    Mathb(MATH_OP_MUL, x1, x2, chans)


def add(x1, x2, optional chans):
    Math(MATH_OP_ADD, x1, x2, chans)
def addb(x1, x2, optional chans):
    Mathb(MATH_OP_ADD, x1, x2, chans)

def sub(x1, x2, optional chans):
    Math(MATH_OP_SUB, x1, x2, chans)
def subb(x1, x2, optional chans):
    Mathb(MATH_OP_SUB, x1, x2, chans)

def ugen_div(x1, x2, optional chans):
    Math(MATH_OP_DIV, x1, x2, chans)
def ugen_divb(x1, x2, optional chans):
    Mathb(MATH_OP_DIV, x1, x2, chans)

def ugen_max(x1, x2, optional chans):
    Math(MATH_OP_MAX, x1, x2, chans)
def ugen_maxb(x1, x2, optional chans):
    Mathb(MATH_OP_MAX, x1, x2, chans)

def ugen_min(x1, x2, optional chans):
    Math(MATH_OP_MIN, x1, x2, chans)
def ugen_minb(x1, x2, optional chans):
    Mathb(MATH_OP_MIN, x1, x2, chans)

def ugen_clip(x1, x2, optional chans):
    Math(MATH_OP_CLP, x1, x2, chans)
def ugen_clipb(x1, x2, optional chans):
    Mathb(MATH_OP_CLP, x1, x2, chans)

def ugen_pow(x1, x2, optional chans):
    Math(MATH_OP_POW, x1, x2, chans)
def ugen_powb(x1, x2, optional chans):
    Mathb(MATH_OP_POW, x1, x2, chans)

def ugen_less(x1, x2, optional chans):
    Math(MATH_OP_LT, x1, x2, chans)
def ugen_lessb(x1, x2, optional chans):
    Mathb(MATH_OP_LT, x1, x2, chans)

def ugen_greater(x1, x2, optional chans):
    Math(MATH_OP_GT, x1, x2, chans)
def ugen_greaterb(x1, x2, optional chans):
    Mathb(MATH_OP_GT, x1, x2, chans)

def ugen_soft_clip(x1, x2, optional chans):
    Math(MATH_OP_SCP, x1, x2, chans)
def ugen_soft_clipb(x1, x2, optional chans):
    Mathb(MATH_OP_SCP, x1, x2, chans)

def ugen_powi(x1, x2, optional chans):
    Math(MATH_OP_PWI, x1, x2, chans)
def ugen_powib(x1, x2, optional chans):
    Mathb(MATH_OP_PWI, x1, x2, chans)

def ugen_rand(x1, x2, optional chans):
    Math(MATH_OP_RND, x1, x2, chans)
def ugen_randb(x1, x2, optional chans):
    Mathb(MATH_OP_RND, x1, x2, chans)

def sample_hold(x1, x2, optional chans):
    Math(MATH_OP_SH, x1, x2, chans)
def sample_holdb(x1, x2, optional chans):
    Mathb(MATH_OP_SH, x1, x2, chans)

def ugen_quantize(x1, x2, optional chans):
    Math(MATH_OP_QNT, x1, x2, chans)
def ugen_quantizeb(x1, x2, optional chans):
    Mathb(MATH_OP_QNT, x1, x2, chans)

def ugen_rli(x1, x2, optional chans):
    Math(MATH_OP_RLI, x1, x2, chans)
def ugen_rlib(x1, x2, optional chans):
    Mathb(MATH_OP_RLI, x1, x2, chans)

def ugen_hzdiff(x1, x2, optional chans):
    Math(MATH_OP_HZDIFF, x1, x2, chans)
def ugen_hzdiffb(x1, x2, optional chans):
    Mathb(MATH_OP_HZDIFF, x1, x2, chans)

def ugen_tan(x1, x2, optional chans):
    Math(MATH_OP_TAN, x1, x2, chans)
def ugen_tanb(x1, x2, optional chans):
    Mathb(MATH_OP_TAN, x1, x2, chans)

def ugen_atan2(x1, x2, optional chans):
    Math(MATH_OP_ATAN2, x1, x2, chans)
def ugen_atan2b(x1, x2, optional chans):
    Mathb(MATH_OP_ATAN2, x1, x2, chans)

def ugen_sin(x1, x2, optional chans):
    Math(MATH_OP_SIN, x1, x2, chans)
def ugen_sinb(x1, x2, optional chans):
    Mathb(MATH_OP_SIN, x1, x2, chans)

def ugen_cos(x1, x2, optional chans):
    Math(MATH_OP_COS, x1, x2, chans)
def ugen_cosb(x1, x2, optional chans):
    Mathb(MATH_OP_COS, x1, x2, chans)
 
 
 
# reson.srp - constructor implementation
#
# (machine generated by u2f.py)

def reson(input, center, q, optional chans):
    if input.rate != 'a':
        print "ERROR: 'input' input to Ugen 'reson' must be audio rate"
        return nil
    if not chans:
        chans = max_chans(max_chans(max_chans(1, input), center), q)
    Ugen(create_ugen_id(), "reson", chans, 'a', "UUU", 'input', input,
         'center', center, 'q', q)

def resonb(input, center, q, optional chans):
    if not isnumber(input) and input.rate == 'a':
        print "ERROR: 'input' input to Ugen 'resonb' must be block rate"
        return nil
    if not isnumber(center) and center.rate == 'a':
        print "ERROR: 'center' input to Ugen 'resonb' must be block rate"
        return nil
    if not isnumber(q) and q.rate == 'a':
        print "ERROR: 'q' input to Ugen 'resonb' must be block rate"
        return nil
    if not chans:
        chans = max_chans(max_chans(max_chans(1, input), center), q)
    Ugen(create_ugen_id(), "resonb", chans, 'b', "UUU", 'input', input,
         'center', center, 'q', q)

 
 
 
# lowpass.srp - constructor implementation
#
# (machine generated by u2f.py)

def lowpass(input, cutoff, optional chans):
    if input.rate != 'a':
        print "ERROR: 'input' input to Ugen 'lowpass' must be audio rate"
        return nil
    if not chans:
        chans = max_chans(max_chans(1, input), cutoff)
    Ugen(create_ugen_id(), "lowpass", chans, 'a', "UU", 'input', input,
         'cutoff', cutoff)

def lowpassb(input, cutoff, optional chans):
    if not isnumber(input) and input.rate == 'a':
        print "ERROR: 'input' input to Ugen 'lowpassb' must be block rate"
        return nil
    if not isnumber(cutoff) and cutoff.rate == 'a':
        print "ERROR: 'cutoff' input to Ugen 'lowpassb' must be block rate"
        return nil
    if not chans:
        chans = max_chans(max_chans(1, input), cutoff)
    Ugen(create_ugen_id(), "lowpassb", chans, 'b', "UU", 'input', input,
         'cutoff', cutoff)

 
 
 
# fileplay.srp -- stream audio from file
#
# Roger B. Dannenberg
# May 2023

def fileplay(filename, optional chans = 2, start = 0, end = 0, 
            cycle, mix, expand)
    Fileplay(chans, filename, start, end, cycle, mix, expand)



class Fileplay (Ugen):

    def init(chans, filename, start, end, cycle, mix, expand):
        // -chans cuts off standard creation:
        super.init(create_ugen_id(), "Fileplay", chans, 'a', "sffBBB",
                   'filename', filename, 'start', start,'end', end,
                   'cycle', cycle, 'mix', mix, 'expand', expand)

    def go(optional play_flag = true):
        o2_send_cmd("/arco/fileplay/play", 0, "UB", id, play_flag)
        this
    
    def stop():
        go(false)
        this
 
 
 
# filerec.srp -- stream audio from file
#
# Roger B. Dannenberg
# May 2023

def filerec(filename, input, optional chans = 2)
    Filerec(chans, filename, input)



class Filerec (Ugen):

    def init(chans, filename, input):
        super.init(create_ugen_id(), "Filerec", chans, '', "sU",
                   'filename', filename, 'input', input)

    def go(optional rec_flag = true):
        o2_send_cmd("/arco/filerec/rec", 0, "UB", id, rec_flag)
        this
    
    def stop():
        go(false)
        this
 
 
 
# recplay.srp -- record and play audio in memory
#
# Roger B. Dannenberg
# May 2023

def recplay(input, optional chans = 1, gain = 1, 
            fade_time = 0.1, loop = false):
    Recplay(chans, input, gain, fade_time, loop)


class Recplay (Ugen):

    def init(chans, input, gain, fade_time, loop):
        super.init(create_ugen_id(), "Recplay", chans, 'a', "UUfB",
                   'input', input, 'gain', gain, 'fade_time', fade_time,
                   'loop', loop)

    def record(record_flag):
        o2_send_cmd("/arco/recplay/rec", 0, "UB", id, record_flag)
        this

    def start(start_time):
    # start playing recording from offset start_time
        o2_send_cmd("/arco/recplay/start", 0, "Ud", id, start_time)
        this

    def stop():
        o2_send_cmd("/arco/recplay/stop", 0, "U", id)
        this

    def set_speed(x):
        o2_send_cmd("/arco/recplay/speed", 0, "Uf", id, x)
        this

    def borrow(u):
        o2_send_cmd("/arco/recplay/borrow", 0, "UU", id, u.id)
        this
 
 
 
# delay.srp -- feedback delay unit generator
#
# Roger B. Dannenberg
# June 2023

class Delay(Ugen):
    def init(chans, input, dur, fb, maxdur):
        super.init(create_ugen_id(), "Delay", chans, 'a', "UUUf",
	           'input', input, 'dur', dur, 'fb', fb, 'maxdur', maxdur)


def delay(input, dur, fb, maxdur, optional chans = 1):
    Delay(chans, input, dur, fb, maxdur)  # delay as a function


 
 
 
# allpass.srp -- feedback all-pass filter unit generator
#
# Roger B. Dannenberg
# June 2023

class Allpass (Ugen):
    def init(chans, input, dur, fb, maxdur):
        super.init(create_ugen_id(), "Allpass", chans, 'a', "UUUf",
	           'input', input, 'dur', dur, 'fb', fb, 'maxdur', maxdur)


def allpass(input, dur, fb, maxdur, optional chans = 1):
    Allpass(chans, input, dur, fb, maxdur)  # allpass as a function


 
 
 
# olapitchshift.srp -- overlap add pitch shift unit generator
#
# Roger B. Dannenberg
# June 2023

class Ola_pitch_shift (Ugen):
    def init(chans, input, ratio, xfade, windur):
        super.init(create_ugen_id(), "olaps", chans, 'a', "Ufff",
	           'input', input, 'ratio', ratio, 'xfade', xfade,
                   'windur', windur)
    
    def set_ratio(value):
        o2_send_cmd("/arco/olaps/ratio", 0, "Uf", id, value)
        this
        

def ola_pitch_shift(input, ratio, xfade, windur, optional chans = 1):
    Ola_pitch_shift(chans, input, ratio, xfade, windur)
 
 
 
# feedback.srp -- mix input with most recent output of some Ugen
#
# Roger B. Dannenberg
# June 2023
#
# This unit generator scales "from" by gain and adds to input to form output.
#
# The "from" update method is not called until *after* computing output, which
# allows for "from" to depend on our output without causing infinite recursion,
# but at the cost of using "stale" samples from the "from" source, which will
# normally be the previous 32 samples, creating feedback with a 32-sample delay.

class Feedback (Ugen):
    def init(chans, input, from, gain):
        super.init(create_ugen_id(), "feedback", chans, 'a', "UUU",
	           'input', input, 'from', from, 'gain', gain)

def feedback(input, from, gain, optional chans = 1):
    Feedback(chans, input, from, gain)
 
 
 
# granstream.srp -- granular synthesis from input stream unit generator
#
# Roger B. Dannenberg
# June 2023

class Granstream (Ugen):
    def init(chans, input, polyphony, dur, enable):
        super.init(create_ugen_id(), "Granstream", chans, 'a', "UifB",
	           'input', input, 'polyphony', polyphony, 'dur', dur,
                   'enable', enable)

    def set_gain(gain)
        o2_send_cmd("/arco/granstream/gain", 0, "Uf", id, gain)
        this

    def set_polyphony(p):
        o2_send_cmd("/arco/granstream/polyphony", 0, "Uf", id, p)
        this

    def set_ratio(low, high)
        o2_send_cmd("/arco/granstream/ratio", 0, "Uff", id, low, high)
        this

    def set_graindur(lowdur, highdur)
        o2_send_cmd("/arco/granstream/graindur", 0, "Uff", id, lowdur, highdur)
        this

    def set_density(density)
        o2_send_cmd("/arco/granstream/density", 0, "Uf", id, density)
        this

    def set_env(attack, release)
        o2_send_cmd("/arco/granstream/env", 0, "Uff", id, attack, release)
        this
    
    def set_enable(enable)
        o2_send_cmd("/arco/granstream/enable", 0, "UB", id, enable)
        this
        
    def set_dur(dur)
        o2_send_cmd("/arco/granstream/dur", 0, "Uf", id, dur)
        this

    def set_delay(d)
        o2_send_cmd("/arco/granstream/delay", 0, "Uf", id, d)
        this

    def set_feedback(fb)
        o2_send_cmd("/arco/granstream/feedback", 0, "Uf", id, fb)
        this


def granstream(input, polyphony, dur, enable, optional chans = 1):
    Granstream(chans, input, polyphony, dur, enable)  # granstream as a function


 
 
 
# flsyn.srp - fluid synth interface
#
# Roger B. Dannenberg
# Jul, 2023

class Flsyn (Ugen):
    def init(path):
        super.init(create_ugen_id(), "Flsyn", nil, 'a', "s", 'path', path,
                   omit_chans = t) // always created with 2 channel output

    def alloff(chan):
        o2_send_cmd("/arco/flsyn/off", 0, "Ui", id, chan)
        this

    def control_change(chan, num, val):
        o2_send_cmd("/arco/flsyn/cc", 0, "Uiii", id, chan, num, val)
        this

    def channel_pressure(chan, val):
        o2_send_cmd("/arco/flsyn/cp", 0, "Uii", id, chan, val)
        this

    def key_pressure(chan, key, val):
        o2_send_cmd("/arco/flsyn/kp", 0, "Uiii", id, chan, key, val)
        this

    def noteoff(chan, key):
        o2_send_cmd("/arco/flsyn/noteoff", 0, "Uii" , id, chan, key)
        this

    def noteon(chan, key, vel):
        o2_send_cmd("/arco/flsyn/noteon", 0, "Uiii", id, chan, key, vel)
        this

    def pitch_bend(chan, bend):
        o2_send_cmd("/arco/flsyn/pbend", 0, "Uif", id, chan, bend)
        this

    def pitch_sens(chan, val):
        o2_send_cmd("/arco/flsyn/psens", 0, "Uii", id, chan, val)
        this

    def program_change(chan, program):
        o2_send_cmd("/arco/flsyn/prog", 0, "Uii", id, chan, program)
        this



def flsyn(path): Flsyn(path)
 
 
 
# pv.srp -- overlap add pitch shift unit generator
#
# Roger B. Dannenberg
# June 2023

class Pv(Ugen):
    def init(chans, input, ratio, fftsize, hopsize, points, mode):
        super.init(create_ugen_id(), "pv", chans, 'a', "Ufiiii",
	           'input', input, 'ratio', ratio, 'fftsize', fftsize,
                   'hopsize', hopsize, 'points', points, 'mode', mode)
    
    def set_ratio(value):
        o2_send_cmd("/arco/pv/ratio", 0, "Uf", id, value)
        this

    def set_stretch(value):
        o2_send_cmd("/arco/pv/stretch", 0, "Uf", id, value)
        this


def pv(input, ratio, fftsize, hopsize, points, mode, optional chans = 1):
    Pv(chans, input, ratio, fftsize, hopsize, points, mode)
 
 
 
# yin.srp -- yin pitch estimation unit generator
#
# Roger B. Dannenberg
# August 2023

class Yin(Ugen):
    def init(chans, input, minstep, maxstep, hopsize, address):
        super.init(create_ugen_id(), "Yin", chans, 'a', "Uiiis", 'inpur', input,
                   'minstep', minstep, 'maxstep', maxstep, 'hopsize', hopsize,
                   'address', address)


def yin(input, minstep, maxstep, hopsize, address, optional chans = 1):
    Yin(chans, input, minstep, maxstep, hopsize, address)  # yin as a function
 
 
 
# trig.srp -- sound event detection
#
# Roger B. Dannenberg
# August 2023

class Trig(Ugen):
    def init(input, reply_addr, window, threshold, pause):
        super.init(create_ugen_id(), "Trig", 0, 'a', "Usiff", omit_chans = t,
                   'input', input, 'reply_addr', reply_addr, 'window', window,
                   'threshold', threshold, 'pause', pause)

    def set_window(window):
        o2_send_cmd("/arco/trig/window", 0, "Ui", id, window)
        this

    def set_threshold(threshold):
        o2_send_cmd("/arco/trig/threshold", 0, "Uf", id, threshold)
        this

    def set_pause(pause):
        o2_send_cmd("/arco/trig/pause", 0, "Uf", id, pause)
        this

    def onoff(reply_addr, threshold, runlen):
        o2_send_cmd("/arco/trig/onoff", 0, "Usff",
                    id, reply_addr, threshold, runlen)
        this


def trig(input, reply_addr, window, threshold, pause):
    Trig(input, reply_addr, window, threshold, pause)  # trig as a function
 
 
 
# route.srp -- route input channels to output channels
#
# Roger B. Dannenberg
# Oct 2023

class Route (Ugen):
    def init(chans):
        super.init(create_ugen_id(), "Route", chans, A_RATE, "")

    def ins(input, rest routes):
        send_ins_rem(input, routes, "/arco/route/ins")
        this

    def rem(input, rest routes):
        send_ins_rem(input, routes, "/arco/route/rem")
        this

    def send_ins_rem(input, routes, address):
        o2_send_start()
        o2_add_int32(arco_ugen_id(id))
        o2_add_int32(arco_ugen_id(input.id))
        for src_dst in routes:
            o2_add_int32(src_dst)
        o2_send_finish(0, address, true)
        this

    def reminput(input):
        o2_send_cmd("/arco/route/reminput", 0, "UU", id, input)
        this



def route(chans):
    return Route(chans)
 
 
 
def chorddetect(reply_addr):
    return Chorddetect(reply_addr)


class Chorddetect (Ugen):
    def init(reply_addr)
        super.init(create_ugen_id(), "Chorddetect", 0, '', "s",
        omit_chans = 1, 'reply_addr', reply_addr)

    def start(reply_addr):
        o2_send_cmd("/arco/chorddetect/start", 0, "Us", id, reply_addr)
        this

    def set(input, value):  // patterned after Ugen.set()
        // Note that the only thing you can set is 'input'
        inputs['input'] = value
        display "Chorddetect set", id, value.id
        o2_send_cmd("/arco/chorddetect/repl_input", 0, "UU", id, value.id)
        this

 
 
 
# trig.srp -- sound event detection
#
# Roger B. Dannenberg
# August 2023

class Onset(Ugen):
    def init(input, reply_addr):
        super.init(create_ugen_id(), "Onset", 0, 'a', "Usiff", omit_chans = t,
                   'input', input, 'reply_addr', reply_addr)


def onset(input, reply_addr):
    Onset(input, reply_addr)  # onset as a function
 
 
 
def spectralcentroid(reply_addr):
    return SpectralCentroid(reply_addr)


class SpectralCentroid (Ugen):
    def init(reply_addr)
        super.init(create_ugen_id(), "SpectralCentroid", 0, '', "s",
                   omit_chans = 1, 'reply_addr', reply_addr)

    def start(reply_addr):
        o2_send_cmd("/arco/spectralcentroid/start", 0, "Us", id, reply_addr)
        this

    def set(input, value):  // patterned after Ugen.set()
        // Note that the only thing you can set is 'input'
        inputs['input'] = value
        display "SpectralCentroid set", id, value.id
        o2_send_cmd("/arco/spectralcentroid/repl_input", 0, "UU", id, value.id)
        this


 
 
 
def spectralrolloff(reply_addr, threshold):
    return SpectralRolloff(reply_addr, threshold)


class SpectralRolloff (Ugen):
    def init(reply_addr, threshold)
        super.init(create_ugen_id(), "SpectralRolloff", 0, '', "sf",
        omit_chans = 1, 'reply_addr', reply_addr, 'threshold_', threshold)

    def start(reply_addr):
        o2_send_cmd("/arco/spectralrolloff/start", 0, "Us", id, reply_addr)
        this

    def set(input, value):  // patterned after Ugen.set()
        // Note that the only thing you can set is 'input'
        inputs['input'] = value
        display "SpectralRolloff set", id, value.id
        o2_send_cmd("/arco/spectralrolloff/repl_input", 0, "UU", id, value.id)
        this



 
 
 
# o2audioio.srp -- overlap add pitch shift unit generator
#
# Roger B. Dannenberg
# June 2023

class O2audioio(Ugen):
    def init(input, destaddr, destchans, recvchans, buffsize,
             sampletype, msgsize):
        super.init(create_ugen_id(), "o2aud", recvchans, 'a', "Usiiii",
	           'input', input, 'destaddr', destaddr,
                   'destchans', destchans, 'buffsize', buffsize,
                   'sampletype', sampletype, 'msgsize', msgsize)
    
    def enable(value):
        if value == true:
            value = 1
        elif value == false:
            value = 0
        o2_send_cmd("/arco/o2aud/enab", 0, "Ui", id, value)
        this


def o2audioio(input, destaddr, destchans, recvchans, buffsize,
              sampletype, msgsize)
    O2audioio(input, destaddr, destchans, recvchans, buffsize,
              sampletype, msgsize)
 
 
 
# zitarev.srp - constructor implementation
#
# (machine generated by u2f.py)

def zitarev(snd, wetdry, gain, t60m):
    if snd.rate != 'a':
        print "ERROR: 'snd' input to Ugen 'zitarev' must be audio rate"
        return nil
    if not isnumber(wetdry) and wetdry.rate == 'a':
        print "ERROR: 'wetdry' input to Ugen 'zitarev' must be block rate"
        return nil
    if not isnumber(gain) and gain.rate == 'a':
        print "ERROR: 'gain' input to Ugen 'zitarev' must be block rate"
        return nil
    if not isnumber(t60m) and t60m.rate == 'a':
        print "ERROR: 't60m' input to Ugen 'zitarev' must be block rate"
        return nil
    if snd.chans != 1 and snd.chans != 2:
        print "ERROR: 'snd' input to Ugen 'zitarev' must have 1 or 2 channels"
        return nil
    if not isnumber(wetdry) and wetdry.chans != 1:
        print "ERROR: 'wetdry' input to Ugen '{c}' must be single channel"
        return nil
    if not isnumber(gain) and gain.chans != 1:
        print "ERROR: 'gain' input to Ugen '{c}' must be single channel"
        return nil
    if not isnumber(t60m) and t60m.chans != 1:
        print "ERROR: 't60m' input to Ugen '{c}' must be single channel"
        return nil

    Ugen(create_ugen_id(), "zitarev", 2, 'a', "UUUU", omit_chans = true, 'snd',
         snd, 'wetdry', wetdry, 'gain', gain, 't60m', t60m)

 
 
 
# overdrive.srp - constructor implementation
#
# (machine generated by u2f.py)

def overdrive(snd, gain, tone, volume):
    if snd.rate != 'a':
        print "ERROR: 'snd' input to Ugen 'overdrive' must be audio rate"
        return nil
    if not isnumber(gain) and gain.rate == 'a':
        print "ERROR: 'gain' input to Ugen 'overdrive' must be block rate"
        return nil
    if not isnumber(tone) and tone.rate == 'a':
        print "ERROR: 'tone' input to Ugen 'overdrive' must be block rate"
        return nil
    if not isnumber(volume) and volume.rate == 'a':
        print "ERROR: 'volume' input to Ugen 'overdrive' must be block rate"
        return nil
    if snd.chans != 1 and snd.chans != 2:
        print "ERROR: 'snd' input to Ugen 'overdrive' must have 1 or 2 channels"
        return nil
    if not isnumber(gain) and gain.chans != 1:
        print "ERROR: 'gain' input to Ugen '{c}' must be single channel"
        return nil
    if not isnumber(tone) and tone.chans != 1:
        print "ERROR: 'tone' input to Ugen '{c}' must be single channel"
        return nil
    if not isnumber(volume) and volume.chans != 1:
        print "ERROR: 'volume' input to Ugen '{c}' must be single channel"
        return nil

    Ugen(create_ugen_id(), "overdrive", 2, 'a', "UUUU", omit_chans = true,
         'snd', snd, 'gain', gain, 'tone', tone, 'volume', volume)

 
 
 
# thru.srp -- audio pass-through
#
# Roger B. Dannenberg
# May 2023

class Thru (Ugen):

    def init(input, optional chans = 1, id_num):
        super.init(arco_ugen_new_id(id_num) if id_num else create_ugen_id(), 
                   "Thru", chans, 'a', "U", 'input', input)

    def set_alternate(alt):
        o2_send_cmd("/arco/thru/alt", 0, "UU", id, alt.id)
        this

def thru(input, optional chans = 1):
    Thru(input, chans)


def fanout(input, chans)
# When thru is used for fanout, the preferred constructor is "fanout",
# which requires the number of channels you are expanding to. You should
# only use this if input is mono.
    Thru(input, chans)
 
 
 
# zero.srp -- audio zero
#
# Roger B. Dannenberg
# May 2023

class Zero (Ugen):

    def init(optional id_num):
        super.init(arco_ugen_new_id(id_num) if id_num else create_ugen_id(), 
                   "Zero", 1, 'a', "", omit_chans = true)


# DO NOT DEFINE zero() -- SEE arco.srp, WHICH DEFINES zero() TO RETURN zero_ugen
# def zero(): purposefully not defined here!


class Zerob (Ugen)

    def init(optional id_num):
        super.init(arco_ugen_new_id(id_num) if id_num else create_ugen_id(), 
                   "Zerob", 1, 'b', "", omit_chans = true)

# DO NOT DEFINE zerob() -- SEE arco.srp, WHICH DEFINES zerob() TO RETURN zerob_ugen
# def zerob(): purposefully not defined here!
 
 
 
# fader.srp - constructor implementation
#
# Roger B. Dannenberg
# Nov 2023

# Support for fade_in: In the simple case, where we faded in ugen,
# we could just swap in the ugen and swap out the fader using a
# scheduled call. But what if the user says to fade() before the
# fade_in() is complete? What we need to do is cancel the pending
# end-of-fade-in, and use the fader to fade to zero. We'll use a
# dictionary for keeping track of everything fading in, mapping
# the ugen being faded in to the fader. Either fade_in_complete
# will remove the fader, or fade() will remove the fader from
# the dictionary.

print "INCLUDING fader.srp"

fade_in_lookup = {}  // maps ugen to its fader


def fader(input, current, optional dur, goal, chans):
# Create a Fader, with optional intialization. Example:
#     fader(input, 0, 0.3, 1) -- fade input from 0 to 1 over 0.3 sec
#     fader(input, 0, 0.3, 1, 0) -- same, but use linear fade
    var fader = Fader(input, current, chans)
    if dur:
        fader.set_dur(dur)
    if goal:
        fader.set_goal(goal)
    fader


class Fader (Ugen):
    def init(input, current, chans):
        if not chans:
            chans = max_chans(1, input)
        super.init(create_ugen_id(), "fader", chans, 'a', "Ufi",
                   'input', input, 'current', current)


    def set_current(current, optional chan):
        if chan:
            o2_send_cmd("/arco/fader/cur", 0, "Uif", id, chan, current)
        for i = 0 to chans:
            o2_send_cmd("/arco/fader/cur", 0, "Uif", id, i,
                        current if isnumber(current) else current[i])
        this


    def set_dur(dur):
        o2_send_cmd("/arco/fader/dur", 0, "Uf", id, dur)
        this


    def set_mode(mode):
        o2_send_cmd("/arco/fader/mode", 0, "Ui", id, mode)
        this


    def set_goal(goal, optional chan):
        if chan:
            o2_send_cmd("/arco/fader/goal", 0, "Uif", id, chan, goal)
        for i = 0 to chans:
            o2_send_cmd("/arco/fader/goal", 0, "Uif", id, i,
                        goal if isnumber(goal) else goal[i])
        this


    def fade_in_complete(ugen):
        var fader = fade_in_lookup.get(ugen)
        if fader:  // fade in was not cancelled, so end it now
            output_ugen.swap(this, ugen)  // remove fader from ugen
            fade_in_lookup.remove(ugen)
        // otherwise, fade_in was cancelled by a fade()
 
 
 
# sum.srp -- sum and sumb unit generators
#
# Roger B. Dannenberg
# June 2023

class Sum(Ugen):
    def init(chans, wrap, optional id_num):
        super.init(arco_ugen_new_id(id_num) if id_num else create_ugen_id(),
                   "Sum", chans, A_RATE, "i", 'wrap', 1 if wrap else 0)
        register_action(this, ACTION_REM, this, 'action_rem')

    def action_rem(status, uid, parameters):
        // find input with uid if any -- similar to mix but inputs
        // directly map to ugens:
        display "Sum.action_rem", status, uid, parameters
        for ugen in inputs.values():
            if arco_ugen_id(ugen.id) == uid:
                inputs.remove(uid)

    def ins(rest ugens):
        for ugen in ugens:
            // for sum, use integer Arco id as input name in dictionary:
            inputs[arco_ugen_id(ugen.id)] = ugen
            o2_send_cmd("/arco/sum/ins", 0, "UU", id, ugen.id)
        this

    def rem(rest ugens):
        for ugen in ugens:
            var name = arco_ugen_id(ugen.id)
            if inputs.has_key(name):
                inputs.remove(name)
                o2_send_cmd("/arco/sum/rem", 0, "UU", id, ugen.id)
        this

    def swap(ugen, replacement):
        var name = arco_ugen_id(ugen.id)
        if inputs.has_key(name):
            // locally, act as if ugen is removed and replacement is inserted
            inputs.remove(name)
            inputs[arco_ugen_id(replacement.id)] = replacement
            o2_send_cmd("/arco/sum/swap", 0, "UUU", id, ugen.id, replacement.id)
        this


def sum(optional chans = 1, keyword wrap = true): Sum(chans, wrap)


class Sumb(Ugen):
    def init(chans, wrap, optional id_num):
        super.init(arco_ugen_new_id(id_num) if id_num else create_ugen_id(),
                   "Sumb", chans, B_RATE, "i", 'wrap', 1 if wrap else 0)
        register_action(this, ACTION_REM, this, 'action_rem')

    def action_rem(status, uid, parameters):
        // find input with uid if any -- similar to mix but inputs
        // directly map to ugens:
        display "Sum.action_rem", status, uid, parameters
        for ugen in inputs.values():
            if arco_ugen_id(ugen.id) == uid:
                inputs.remove(uid)

    def ins(rest ugens):
        for ugen in ugens:
            inputs[arco_ugen_id(ugen.id)] = ugen
            o2_send_cmd("/arco/sumb/ins", 0, "UU", id, ugen.id)
        this

    def rem(rest ugens):
        for ugen in ugens:
            var name = arco_ugen_id(ugen.id)
            if inputs.has_key(name):
                inputs.remove(name)
                o2_send_cmd("/arco/sumb/rem", 0, "UU", id, ugen.id)
        this

    def swap(ugen, replacement):
        var name = arco_ugen_id(ugen.id)
        if inputs.has_key(name):
            // locally, act as if ugen is removed and replacement is inserted
            inputs.remove(name)
            inputs[arco_ugen_id(replacement.id)] = replacement
            o2_send_cmd("/arco/sumb/swap", 0, "UUU",
                        id, ugen.id, replacement.id)
        this


def sumb(optional chans = 1, keyword wrap = true): Sumb(chans, wrap)
 
