# supersaw.srp - bass instrument based on sawtooths and phasing
#
# Roger B. Dannenberg
# Oct 2024
# based on supersaw.sal by Hanrui (Henry) Deng

require "steps"
require "velocity"
require "synth"

sawtooth_waveforms = nil

class Sawtooth_waveforms:
# manager for a tableosc with precomputed sawtooth waveforms
# there should be only one instance
    var tables   // a tableosc ugen holding shared waveforms
    var created  // array of index or nil - does waveform exist and
                 // at what index?
    var next_index // where to put next waveform

    def init():
        created = array(36)  // cached waveforms for full 2048-point
                             // sawtooth at 0, then steps 4, 8, ... 136
        tables = tableosc(1, 1)
        next_index = 0
        assert(not sawtooth_waveforms)  // this is a singleton class
        sawtooth_waveforms = this
    
    def get_index(step, optional antialias = t):
        var i, f0, n, tlen, ampspec
        if antialias:
            i = max(min(int(step / 4), len(created) - 1), 1)
        else:
            i = 0
        if created[i]:
            return created[i]
        created[i] = next_index

        if antialias:
            f0 = step_to_hz(step)
            n = max(1, int(AR  * 2 / (5 * f0)))
            // note that n * f0 is about (sample-rate / 2) * 4 / 5
            // table len should be 8x oversampled, so 16 * n
            tlen = max(16 * n, 512)
            ampspec = [1 / i for i = 1 to n + 1]
            tables.create_tas(next_index, tlen, ampspec)
        else:  // for the aliasing version, just make a 256-point
               // table. It will be an exact sawtooth due to linear
               // interpolation except for the last 1/256 of the period
               // where linear interpolation will make it ramp down.
            ampspec = [i / 256 for i = 0 to 256]
            tables.create_ttd(next_index, 256, ampspec)
        next_index = next_index + 1
        return next_index - 1



class Supersaw (Instrument):
    var decay
    var amp

    def init(step, fmod, n, detune, width, mono, antialias, rolloff,
             animate, attack, amp_, decay_, cutoff):
        instr_begin()
        decay = decay_  // save it for noteoff()
        amp = amp_      // save it for noteoff()
        if not sawtooth_waveforms:
            Sawtooth_waveforms()  // need singleton
        var table_index = sawtooth_waveforms.get_index(step, antialias)
        var mixer = mix(1 if mono else 2)
        var power = 0
        for i = 0 to n:
            var ro = supersaw_component(i, step, fmod, n, detune, width,
                                mono, sawtooth_waveforms.tables, table_index,
                                rolloff, animate, mixer)
            power = power + ro * ro  // sum of squares of amplitudes
        var env = pwlb(attack, amp)
        var out = mult(lowpass(mixer, cutoff), env)
        env.start()
        super.init("Supersaw", out)

    def noteoff():
        display "supersaw.noteoff"
        // replace pwlb with pweb for decay. This has a problem in that
        // if we get a noteoff during attack, there will be a discontinuity
        var decay_env = pweb(decay, init=amp)
        output.set('x2', decay_env)
        decay_env.term()


    def supersaw_component(i, step, fmod, n, detune, width, 
            mono, table_ugen, table_index, rolloff, animate, mixer):
    # each component is one sawtooth wave. i is in the range 0 to n-1
    # where n is the total number of sawtooths added together by
    # supersaw.
        var comp  // the component (before panning)
        if animate:
            var rate = animate if isnumber(animate) else 1
            // convert from detune Hz to detune signal in Hz
            detune = ugen_rlib(rate, step_to_hz(step + detune) -
                               step_to_hz(step))
            rolloff = 1
            comp = tableosc(addb(fmod, addb(step_to_hz(step), detune)), 0.1)
        else:  // spread frequencies from -detune to +detune in steps
            detune = 0 if n <= 1 else detune * (i * 2) / (n - 1) - detune
            // rolloff is a scale factor that is smallest at i=0 and i=n-1
            rolloff = rolloff ** abs(i - (n - 1) / 2)
            comp = tableosc(addb(fmod, step_to_hz(step + detune)), rolloff)
        comp.borrow(table_ugen)
        comp.select(table_index)
        if mono:
            mixer.ins(mix_name(i), comp, 1.0)
        else:
            var posn = 0.5 if n <= 1 else 0.5 + (width * i / (n - 1) - 0.5)
            mixer.ins(mix_name(i), comp, pan_45(pan))
        return rolloff


def supersaw(instr_spec, pitch, vel, params):
    var fmod = params.get('fmod') or instr_spec.get('fmod', 0)
    var n = params.get('n') or instr_spec.get('n', 8)
    var detune = params.get('detune') or instr_spec.get('detune', 0.1)
    var width = params.get('width') or instr_spec.get('width', 1.0)
    var mono = params.get('mono') or instr_spec.get('mono', t)
    var antialias = params.get('antialias') or 
                    instr_spec.get('antialias', t)
    var rolloff = params.get('rolloff') or instr_spec.get('rolloff', 1)
    var animate = params.get('animate') or instr_spec.get('animate')
    var attack = params.get('attack') or instr_spec.get('attack', 0.4)
    var amp = vel_to_linear(vel)
    var decay = params.get('decay') or instr_spec.get('decay', 0.5)
    // cutoff frequency is specified in instr_spec as steps above pitch
    // and defaults to 12, but it is specified in params as Hz:
    var cutoff = params.get('cutoff') or
                 step_to_hz(pitch + instr_spec.get('cutoff', 12))

    Supersaw(pitch, fmod, n, detune, width, mono, antialias, rolloff,
             animate, attack, amp, decay, cutoff)


SUPERSAW1 = {'instrument': 'supersaw', 'rolloff': 0.5, 'animate': t, 'n': 16}

def supersaw_example_start()
    sssynth = Synth()
    sssynth.play()
    sspitch = 48
    sssynth.note(SUPERSAW1, sspitch, 80, cutoff = 500.0)

def supersaw_example_stop():
    sssynth.noteoff(sspitch)
    sssynth = nil  // so GC can free it
