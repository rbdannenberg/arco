# arco.srp -- Serpent library for controlling Arco
#
# Roger B. Dannenberg
# Jan 2022

# call arco_init(ensemble) to start
# call arco_run() after setting up UI and or scheduling things
# arco_ready is set to true when arco is ready for action

require "debug"
require "wxserpent"
require "prob"
require "arco"

class Atone (Instrument):
    def init(freq, dur, nharm):
        display "Atone", dur
        instr_begin()
        var env = member(pwlb(dur * 0.2, 0.01, dur * 0.8), 'env')
        env.atend(MUTE, this)
        var mix = mix(1)
        for i = 1 to nharm:
            mix.ins(sine(freq * i, 0.8 ** i), env)
        if pr_coin(0.5):
            // reson filter center frequency envelope:
            var renv = member(pwlb(random(), pr_unif(4, 10) * freq, 
                                   5.0, 200.0, max(5.0, dur * 2)), 'renv')
            var q = pr_unif(0.5, 2.0)
            mix = reson(mix, renv, q)
        super.init("Atone", mix)

    def start():
        get('env').start()
        var renv = get('renv')
        if renv:  // start the reson filter envelope too if it exists
            renv.start()
        this


def arco_ready():
    # called when arco is intialized and ready to make sound
    print "**** arco ready! ****"
    var win = default_window

    Button(win, "Simple test", 10, 10, 170, 20, 'stbutton')
    stbutton.add_target_method(nil, 'play_simple_test')

    Button(win, "Mixer test", 'S', 'D', 'S', 'S', 'mtbutton')
    mtbutton.add_target_method(nil, 'play_mixer_test')

    Button(win, "Atonal sequence", 'S', 'D', 'S', 'S', 'atbutton')
    atbutton.add_target_method(nil, 'play_atone_test')

    Button(win, "Atonal sequence stop", 'S', 'D', 'S', 'S', 'atsbutton')
    atsbutton.add_target_method(nil, 'stop_atone_test')

    Button(win, "Play sound file", 'S', 'D', 'S', 'S', 'psfbutton')
    psfbutton.add_target_method(nil, 'play_sound_file')

        
def atone_sequence():
    var step = 40 + irandom(40)
    var freq = 440.0 * (2.0 ** (1/12)) ** (step - 69)
    var dur = pr_unif(0.5, 10)
    var nharm = irandom(15) + 2
    display "atone_sequence", freq, dur, nharm
    var atone = Atone(freq, dur, nharm).play().start()
    // sched_cause(dur + 0.2, atone, 'mute')
    var ioi = pr_unif(0.25, 2.0) ** 2
    if atone_running:
        sched_cause(ioi, nil, 'atone_sequence')


// handler for /host/openaggr messages with param info (a string)
def host_openaggr(timestamp, address, types, info)
    var LATENCY_MS = 50
    print info
    if find(info, "Aggregate") >= 0 or find(info, "default") >= 0:
        var id = int(info)
        print "  --> opening this device, id", id
        o2_send_cmd("/arco/open", 0, "iiiiiis", id, id, 2, 2, LATENCY_MS, 32, 
                    "actl");
        o2_send_cmd("/arco/prtree", o2_time_get() + 1, "");
        

def host_openaggr_init()
    o2_service_new("host")
    o2_method_new("/host/openaggr", "s", 'host_openaggr', t)


######### Synthesis Tests ##############

// handler for stbutton: play some sine tones
def play_simple_test(rest ignore):
    sine(440.0, 0.01).play()
    sine(880.0, 0.01).play()
    sine(1320.0, 0.007).play()
    sine(1760.0, 0.005).play()
    

// handler for mtbutton: play some sine tones
def play_mixer_test(rest ignore):
    m1 = mix(1)
    m1.ins(sine(440.0, 0.01), 1)
    m1.ins(sine(880.0, 0.01), 1)
    m1.ins(sine(1320.0, 0.007), 1)
    m1.ins(sine(1760.0, 0.005), 1)
    m1.play()


// handler for atbutton: play an algorithmic composition
def play_atone_test(rest ignore):
    atone_running = true
    atone_sequence()

// handler for atbutton: play an algorithmic composition
def stop_atone_test(rest ignore):
    atone_running = false


sound_file_path = "/Users/rbd/Music/soundscape1/digichoir1.wav"

// handler for psfbutton: play the sound file 
def play_sound_file(rest ignore):
# We could simply play the Strplay Ugen, but we're using a
# Mix(er) to provide an (unused) gain control and also to
# show how the Mix and Strplay can be freed when the sound
# finishes.
    var m1 = mix(2)
    var sp = strplay(sound_file_path, 2)
    m1.ins(sp, 1)  // sp reference handed off to m1
    m1.play()  // connect mixer to output
    sp.atend(MUTE, m1)  // "when the sound file finishes, mute m1"
    // The mute method will delete m1. If it were not a local var,
    // we would call m1.ref() here.
    sp.go()     // play the sound file. Technically, we do not have
    // a reference because we gave it to m1, but this is non-preemptive
    // and our local m1 shadow holds the reference.
    o2_send_cmd("/arco/prtree", 0, "")  // this tells Arco to print the Ugen
    // tree -- it can be useful for debugging.
    sched_select(rtsched)
    // To confirm the objects are deleted, we can schedule the printing of
    // all unit generators in the ugen_table. You can compare Ugen numbers
    // to the tree printout earlier.
    sched_cause(10, nil, 'o2_send_cmd', "/arco/prugens", 0, "")
    // Not all unit generators are necessarily in the ugen_table. The
    // table is needed for clients to address individual unit generators,
    // but unit generators can be accessed by other unit generators and
    // they can be rooted in the Audioio output list, so let's print
    // the tree again after things should be cleaned up.
    sched_cause(10.01, nil, 'o2_send_cmd', "/arco/prtree", 0, "")


########## Main Initialization ################

def main():
    o2_debug_flags("") // ("SsBl")
    arco_init(network = false, title = "Arco Test")
    // this should be replaced by a preference and menu system to select
    // and open audio device(s):
    host_openaggr_init()
    arco_run()

main()
