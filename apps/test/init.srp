# arco.srp -- Serpent library for controlling Arco
#
# Roger B. Dannenberg
# Jan 2022

# call arco_init(ensemble) to start
# call arco_run() after setting up UI and or scheduling things
# arco_ready is set to true when arco is ready for action

require "debug"
require "wxserpent"
require "prob"
require "arco"
require "allugens"

SIMPLE = false

class Atone (Instrument):
    def init(freq, dur, nharm):
        display "Atone", dur
        instr_begin()
        var env = member(pwlb(dur * 0.2, 0.01, dur * 0.8), 'env')
        display "In Atone", env, env.id, id(env.id)
        env.atend(MUTE, this)  # target to mute is this, not env!
        var mix = mix(1)
        for i = 0 to nharm:
            mix.ins(sine(freq * i, 0.8 ** i), env)
        if not SIMPLE and pr_coin(0.5):
            // reson filter center frequency envelope:
            var renv = member(pwlb(random(), pr_unif(4, 10) * freq, 
                                   5.0, 200.0, max(5.0, dur * 2)), 'renv')
            var q = pr_unif(0.5, 2.0)
            mix = reson(mix, renv, q)
        super.init("Atone", mix)


    def start():
        get('env').start()
        var renv = get('renv')
        if renv:  // start the reson filter envelope too if it exists
            renv.start()
        this


ui_initialized = false

def arco_ready():
    # called when arco is intialized and ready to make sound or when
    # arco audio stream has been reopened
    print "**** arco audio is running! ****"
    var win = default_window
    if ui_initialized:
        returnn

    Checkbox(win, "Simple test", 5, 5, 170, 'H', 'stcheckbox')
    stcheckbox.add_target_method(nil, 'play_simple_test')

    Checkbox(win, "Mixer test", 'S', 'D', 'S', 'S', 'mtcheckbox')
    mtcheckbox.add_target_method(nil, 'play_mixer_test')

    Checkbox(win, "Atonal sequence", 'S', 'D', 'S', 'S', 'atcheckbox')
    atcheckbox.add_target_method(nil, 'play_atone_test')

    Button(win, "Play sound file", 'S', 'D', 'S', 'S', 'psfbutton')
    psfbutton.add_target_method(nil, 'play_sound_file')

    Checkbox(win, "Record Output", 'S', 'D', 'S', 'S', 'rocheckbox')
    rocheckbox.add_target_method(nil, 'record_output')

    Checkbox(win, "Play Recorded Output", 'S', 'D', 'S', 'S', 'procheckbox')
    procheckbox.add_target_method(nil, 'play_recorded_output')

    ui_initialized = true



def atone_sequence():
    var step = 40 + irandom(40)
    var freq = 440.0 * (2.0 ** (1/12)) ** (step - 69)
    var dur = pr_unif(0.5, 10)
    var nharm = 1 if SIMPLE else irandom(15) + 2 
    display "atone_sequence", freq, dur, nharm, sched_current, 
    display     vtsched, sched_vtime
    var atone = Atone(freq, dur, nharm).play().start()
    // sched_cause(dur + 0.2, atone, 'mute')
    var ioi = pr_unif(0.25, 2.0) ** 2
    if atone_running:
        sched_cause(ioi, nil, 'atone_sequence')


// handler for /host/openaggr messages with param info (a string)
def host_openaggr(timestamp, address, types, info)
    var LATENCY_MS = 50
    print info
    if find(info, "Aggregate") >= 0 or find(info, "default") >= 0:
        var id = int(info)
        print "  --> opening this device, id", id
        arco_open(id, id, 2, 2, LATENCY_MS, 32)
        o2_send_cmd("/arco/open", 0, "iiiiiis", id, id, 2, 2, LATENCY_MS, 32, 
                    "actl");
        o2_send_cmd("/arco/prtree", o2_time_get() + 1, "");
        

def host_openaggr_init()
    o2_service_new("host")
    o2_method_new("/host/openaggr", "s", 'host_openaggr', t)


######### Synthesis Tests ##############

// handler for stcheckbox: play/stop some sine tones
def play_simple_test(obj, event, x, y):
    display "play_simple_test", x
    if x:
        sin1 = sine(440.0, 0.01).play()
        sin2 = sine(880.0, 0.01).play()
        sin3 = sine(1320.0, 0.007).play()
        sin4 = sine(1760.0, 0.005).play()
    else:
        sin1.mute()
        sin1 = nil  // delete reference for garbage collection
        sin2.mute()
        sin2 = nil
        sin3.mute()
        sin3 = nil
        sin4.mute()
        sin4 = nil

// handler for mtcheckbox: play/stop some sine tones
def play_mixer_test(obj, event, x, y):
    if x:
        m1 = mix(1)
        m1.ins(sine(440.0, 0.01), 1)
        m1.ins(sine(880.0, 0.01), 1)
        m1.ins(sine(1320.0, 0.007), 1)
        m1.ins(sine(1760.0, 0.005), 1)
        m1.play()
    else
        m1.mute()
        m1 = nil  // delete reference

########## PLAYREC TESTS ##################

recplay1 = nil

def record_output(obj, event, x, y):
    display "record_output", x
    if x:
        if not recplay1:  // long fade time to test this feature
            recplay1 = recplay(prev_output_ugen, 2, 0.5, 3.0, false)
        recplay1.run()  # needs be in run set to make active
        recplay1.record(true)
    elif not recplay1:
        print "WARNING: There is no recplay1 Ugen!"
    else:
        recplay1.record(false)
        recplay1.unrun()  # does not need to be active now


def play_recorded_output(obj, event, x, y):
    display "play_recorded_output", x
    if x and recplay1:
        // note that Recplay might end playback immediately upon starting,
        // so we need to set up the atend action before sending 'start':
        recplay1.play().atend(MUTE)
        recplay1.start(0.0)
    elif (not x) and recplay1:
        recplay1.stop()  // atend is already set up to mute when finished


############ ATONE: INSTRUMENT AND NOTE SEQUENCE ##############

// handler for atcheckbox: play/stop an algorithmic composition
def play_atone_test(obj, event, x, y)
    atone_running = x
    if x:
        sched_select(vtsched)  // vtsched stops when audio stops
        atone_sequence()

############ PLAY SOUND FILE ##############

sound_file_path = "/Users/rbd/Music/soundscape1/digichoir1.wav"

// handler for psfbutton: play the sound file 
def play_sound_file(rest ignore):
# We could simply play the Fileplay Ugen, but we're using a
# Mix(er) to provide an (unused) gain control and also to
# show how the Mix and Fileplay can be freed when the sound
# finishes.
    var m1 = mix(2)
    var sp = fileplay(sound_file_path, 2)
    m1.ins(sp, 1)  // sp reference handed off to m1
    m1.play()  // connect mixer to output
    sp.atend(MUTE, m1)  // "when the sound file finishes, mute m1"
    // The mute method will delete m1. If it were not a local var,
    // we would call m1.ref() here.
    sp.go()     // play the sound file. Technically, we do not have
    // a reference because we gave it to m1, but this is non-preemptive
    // and our local m1 shadow holds the reference.



########## Main Initialization ################

def arco_prugens_handler(rest ignore):
    // this tells Arco to print the Ugen tree -- it can be useful for
    //     debugging.
    o2_send_cmd("/arco/prtree", 0, "")
    // also print the list of Ugens accessible by integer ID:
    o2_send_cmd("/arco/prugens", 0, "")


def arco_ugen_gc_info_handler(rest ignore):
    arco_ugen_gc_info()


def main():
    o2_debug_flags("") // ("SsBl")
    arco_init(latency = 60, network = false, title = "Arco Test")
    // this should be replaced by a preference and menu system to select
    // and open audio device(s):
    arco_run()
    sched_select(rtsched)
    display "####### main.srp GETTING File MENU FROM", default_window
    var file_menu = default_window.get_menu("File")
    file_menu.item("Print Ugen Info", "print Ugen tree and table",
                   nil, nil, 'arco_prugens_handler')
    file_menu.item("Arco Ugen GC Info", "print info about Ugen IDs",
                   nil, nil, 'arco_ugen_gc_info_handler')


main()
