# arco.srp -- Serpent library for controlling Arco
#
# Roger B. Dannenberg
# Jan 2022

# call arco_init(ensemble) to start
# call arco_run() after setting up UI and or scheduling things
# arco_ready is set to true when arco is ready for action

require "debug"
require "wxserpent"
require "prob"
require "arco"
require "allugens"
require "reverb"
require "soundfont"

SIMPLE = false

class Atone (Instrument):
    def init(freq, dur, nharm):
        display "Atone", dur
        instr_begin()
        var env = member(pwlb(dur * 0.2, 0.01, dur * 0.8), 'env')
        display "In Atone", env, env.id, id(env.id)
        env.atend(MUTE, this)  # target to mute is this, not env!
        var mix = mix(1)
        for i = 0 to nharm:
            // we need a symbol for each mixer input but since the
            // number of inputs is controlled by nharm, we have to
            // manufacture symbols:
            var name = intern("i" + str(i))
            mix.ins(name, sine(freq * i, 0.8 ** i), env)
        if not SIMPLE and pr_coin(0.5):
            // reson filter center frequency envelope:
            var renv = member(pwlb(random(), pr_unif(4, 10) * freq, 
                                   5.0, 200.0, max(5.0, dur * 2)), 'renv')
            var q = pr_unif(0.5, 2.0)
            mix = reson(mix, renv, q)
        super.init("Atone", mix)


    def start():
        get('env').start()
        var renv = get('renv')
        if renv:  // start the reson filter envelope too if it exists
            renv.start()
        this


ui_initialized = false
ready_count = 0

def arco_ready():
# called when arco is intialized and ready to make sound or when
# arco audio stream has been reopened
    display "**** arco audio is running! ****", ready_count
    ready_count = ready_count + 1
    if ready_count > 1:
        display "arco_ready called again", ready_count
        breakpoint()
    var win = default_window
    if ui_initialized:
        return

    display "arco_ready", wxs_h, wxs_space,
    display WXS_DEFAULT_HEIGHT, WXS_DEFAULT_SPACE

    Checkbox(win, "Simple test", 5, 5, 170, 20, 'stcheckbox')
    stcheckbox.add_target_method(nil, 'play_simple_test')

    Checkbox(win, "Mixer test", 'S', 'D', 'S', 'S', 'mtcheckbox')
    mtcheckbox.add_target_method(nil, 'play_mixer_test')

    Checkbox(win, "Atonal sequence", 'S', 'D', 'S', 'S', 'atcheckbox')
    atcheckbox.add_target_method(nil, 'play_atone_test')

    Button(win, "Play sound file", 'S', 'D', 'S', 'S', 'psfbutton')
    psfbutton.add_target_method(nil, 'play_sound_file')

    Checkbox(win, "Record Output", 'S', 'D', 'S', 'S', 'rocheckbox')
    rocheckbox.add_target_method(nil, 'record_output')

    Checkbox(win, "Record Output Stereo", 'S', 'D', 'S', 'S', 'ro2checkbox')
    ro2checkbox.add_target_method(nil, 'record_output_2')

    Checkbox(win, "Play Recorded Output", 'S', 'D', 'S', 'S', 'procheckbox')
    procheckbox.add_target_method(nil, 'play_recorded_output')

    Checkbox(win, "Play Recorded Up", 'S', 'D', 'S', 'S', 'proucheckbox')
    proucheckbox.add_target_method(nil, 'play_recorded_output_up')

    Checkbox(win, "Play Recorded Down", 'S', 'D', 'S', 'S', 'prodncheckbox')
    prodncheckbox.add_target_method(nil, 'play_recorded_output_down')

    Checkbox(win, "Delay Test", 'S', 'D', 'S', 'S', 'dlycheckbox')
    dlycheckbox.add_target_method(nil, 'delay_test')

    Checkbox(win, "Pitch Shift Test", 'S', 'D', 'S', 'S', 'pscheckbox')
    pscheckbox.add_target_method(nil, 'pstest')

    Checkbox(win, "Feedback Test", 'S', 'D', 'S', 'S', 'fbcheckbox')
    fbcheckbox.add_target_method(nil, 'fbtest')

    Checkbox(win, "Granstream Test", 'S', 'D', 'S', 'S', 'gscheckbox')
    gscheckbox.add_target_method(nil, 'gstest')

    Checkbox(win, "Gran. with Feedback", 'S', 'D', 'S', 'S',
             'gsfbcheckbox')
    gsfbcheckbox.add_target_method(nil, 'gsfbtest')

    # start a 2nd column
    COLUMN_TWO = 200
    wxs_x = COLUMN_TWO
    wxs_y = 5 - wxs_h  // 'D' will get y = wxs_y + wxs_h = 5

    Button(win, "Pwl/Pwe Test", 'S', 'D', 'S', 'S', 'pwecheckbox')
    pwecheckbox.add_target_method(nil, 'pwetest')                

    Button(win, "Alpass Test", 'S', 'D', 'S', 'S', 'alpcheckbox')
    alpcheckbox.add_target_method(nil, 'alptest')

    Button(win, "Flsyn Test", 'S', 'D', 'S', 'S', 'flscheckbox')
    flscheckbox.add_target_method(nil, 'flstest')

    Checkbox(win, "Phase vocoder", 'S', 'D', 'S', 'S', 'pvcheckbox')
    pvcheckbox.add_target_method(nil, 'pvtest')
    
    Button(win, "File Play/Record", 'S', 'D', 'S', 'S', 'fprbutton')
    fprbutton.add_target_method(nil, 'file_play_record')

    Checkbox(win, "Yin", 'S', 'D', 55, 'S', 'yincheckbox')
    yincheckbox.add_target_method(nil, 'yintest')

    Statictext(win, "", 'R', wxs_y + 2, 100, wxs_h - 2, 'yintext')
    
    wxs_x = COLUMN_TWO
    Checkbox(win, "Trig", 'S', 'D', 55, 'S', 'trigcheckbox')
    trigcheckbox.add_target_method(nil, 'trigtest')

    TRIG_ON_TEXT = "◼ Trig"
    TRIG_OFF_TEXT = "◻ Trig"
    Statictext(win, TRIG_OFF_TEXT, 'R', wxs_y + 2, 50, 'S', 'trigtext')

    ONOFF_ON_TEXT = "◼ On/Off"
    ONOFF_OFF_TEXT = "◻ On/Off"
    Statictext(win, ONOFF_OFF_TEXT, 'R', 'S', 'S', 'S', 'onofftext')

    ui_initialized = true
    default_window.fit_to_children()


def atone_sequence():
    var step = 40 + irandom(40)
    var freq = 440.0 * (2.0 ** (1/12)) ** (step - 69)
    var dur = pr_unif(0.5, 10)
    var nharm = 1 if SIMPLE else irandom(15) + 2 
    display "atone_sequence", freq, dur, nharm, sched_current, 
    display     vtsched, sched_vtime
    var atone = Atone(freq, dur, nharm).play().start()
    // sched_cause(dur + 0.2, atone, 'mute')
    var ioi = pr_unif(0.25, 2.0) ** 2
    if atone_running:
        sched_cause(ioi, nil, 'atone_sequence')


// handler for /host/openaggr messages with param info (a string)
def host_openaggr(timestamp, address, types, info)
    var LATENCY_MS = 50
    print info
    if find(info, "Aggregate") >= 0 or find(info, "default") >= 0:
        var id = int(info)
        print "  --> opening this device, id", id
        arco_open(id, id, 2, 2, LATENCY_MS, 32)
        o2_send_cmd("/arco/open", 0, "iiiiiis", id, id, 2, 2, LATENCY_MS, 32, 
                    "actl");
        o2_send_cmd("/arco/prtree", o2_time_get() + 1, "");
        

def host_openaggr_init()
    o2_service_new("host")
    o2_method_new("/host/openaggr", "s", 'host_openaggr', t)



######### Synthesis Tests ##############

// handler for stcheckbox: play/stop some sine tones
def play_simple_test(obj, event, x, y):
    display "play_simple_test", x
    if x:
        sin1 = sine(440.0, 0.01).play()
        sin2 = sine(880.0, 0.01).play()
        sin3 = sine(1320.0, 0.007).play()
        sin4 = sine(1760.0, 0.005).play()
    else:
        sin1.mute()
        sin1 = nil  // delete reference for garbage collection
        sin2.mute()
        sin2 = nil
        sin3.mute()
        sin3 = nil
        sin4.mute()
        sin4 = nil

// handler for mtcheckbox: play/stop some sine tones
def play_mixer_test(obj, event, x, y):
    if x:
        m1 = mix(2)

        ms1 = sine(440.0, 0.01)
        m1.ins('inp1', ms1, [1, 0])

        ms2 = sine(880.0, 0.01)
        m1.ins('inp2', ms2, [0, 1])

        m1.ins('inp3', sine(1320.0, 0.007), 1)

        m1.ins('inp4', sine(1760.0, 0.005), 1)

        m1.play()

        sched_select(rtsched)
        sched_cause(1.0, nil, 'mixer_gain_change_1')
        sched_cause(2.0, nil, 'mixer_gain_change_2')
    else:
        m1.fade(1) // test for stereo fade output to silence:
        m1 = nil  // delete references
        ms1 = nil
        ms2 = nil

def mixer_gain_change_1():
    if m1:  // user has not stopped test yet
        m1.set_gain('inp1', 10, 0)  // left channel

def mixer_gain_change_2():
    if m1:  // user has not stopped test yet
        m1.set_gain('inp2', 10, 1)  // right channel


########## RECPLAY TESTS ##################

recplay1 = nil

def record_output(obj, event, x, y, optional chans = 1):
    display "record_output", x, chans
    if x:
        if not recplay1 or recplay1.chans != chans:
            if recplay1:
                print "shutting down recplay1 because it has", recplay1.chans,
                print     "channels and we want", chans
                recplay1.record(false)
                recplay1.unrun()
            // long fade time to test this feature
            recplay1 = recplay(prev_output_ugen, chans, 0.5, 3.0, false)
        recplay1.run()  # needs be in run set to make active
        recplay1.record(true)
    elif not recplay1:
        print "WARNING: There is no recplay1 Ugen!"
    else:
        recplay1.record(false)
        recplay1.unrun()  # does not need to be active now


def record_output_2(obj, event, x, y):
    display "record_output_2", x
    record_output(obj, event, x, y, 2)


def play_recorded_output(obj, event, x, y, optional speed = 1):
    display "play_recorded_output", x, speed
    if x and recplay1:
        // note that Recplay might end playback immediately upon starting,
        // so we need to set up the atend action before sending 'start':
        recplay1.play().atend(MUTE)
        recplay1.set_speed(speed)
        recplay1.start(0.056)  // tests for non-zero start time
    elif (not x) and recplay1:
        recplay1.stop()  // atend is already set up to mute when finished


def play_recorded_output_up(obj, event, x, y):
    display "play_recorded_output_up", x
    play_recorded_output(obj, event, x, y, 1.2)


def play_recorded_output_down(obj, event, x, y):
    display "play_recorded_output_up", x
    play_recorded_output(obj, event, x, y, 0.8)


############ ATONE: INSTRUMENT AND NOTE SEQUENCE ##############

// handler for atcheckbox: play/stop an algorithmic composition
def play_atone_test(obj, event, x, y)
    atone_running = x
    if x:
        sched_select(vtsched)  // vtsched stops when audio stops
        atone_sequence()

############ PLAY SOUND FILE ##############

sound_file_path = "/Users/rbd/Music/soundscape1/digichoir1.wav"

// handler for psfbutton: play the sound file 
def play_sound_file(rest ignore):
# We could simply play the Fileplay Ugen, but we're using a
# Mix(er) to provide an (unused) gain control and also to
# show how the Mix and Fileplay can be freed when the sound
# finishes.
    var m1 = mix(2)
    var sp = fileplay(sound_file_path, 2)
    m1.ins('sndfile', sp, 1)  // sp reference handed off to m1
    m1.play()  // connect mixer to output
    sp.atend(MUTE, m1)  // "when the sound file finishes, mute m1"
    // The mute method will delete m1. If it were not a local var,
    // we would call m1.ref() here.
    sp.go()     // play the sound file


########## DELAY TEST ################

def delay_test(obj, event, x, y):
    display "delay_test", x
    if x:
        dly1 = delay(input_ugen, 1.0, 0.1, 2.0, 2)
        dly1.play()
    else:
        dly1.mute()  // immediate stop
        dly1 = nil   // eventual cleanup when GC frees it

########## PITCH SHIFT TEST #############

def pstest(obj, event, x, y):
    display "pstest - pitch shift", x
    if x:
        ps1 = ola_pitch_shift(input_ugen, 1.25, 0.01, 0.05)
        ps1.play()
    else:
        ps1.mute()  // immediate stop
        ps1 = nil   // eventual cleanup when GC frees it

########## FEEDBACK TEST #############

def fbtest(obj, event, x, y):
# create a delay with no internal feedback and use a feedback ugen to
# produce feedback. The delay test used 0.1 gain on feedback so we do
# the same here, and set delay to 1 second as with delay test.
    display "fbtest - feedback", x
    if x:
        // initially "from" is zero; then we replace it with delay
        fb1 = feedback(input_ugen, zero_ugen, 0.5)
        fb2 = delay(fb1, 1.0, 0.0, 2.0)
        fb1.set('from', fb2)  // feedback from delay output
        fb2.play()
    else:
        fb2.mute()  // immediate stop
        fb1.set('from', zero_ugen)  // break the cycle to allow GC
        fb1 = nil   // eventual cleanup when GC frees it
        fb2 = nil


########## GRANSTREAM TEST #############

def gstest(obj, event, x, y):
# create a granstream to granulate microphone input
    display "gstest - granstream applied microphone input ", x
    if x:
        gs1 = granstream(input_ugen, 20, 3.0, true, 2)  // 2 channel
        gs1.set_density(5.0)
        // gs1 = granstream(input_ugen, 1, 3.0, true, 2)  // 2 channel
        // gs1 = granstream(input_ugen, 1, 3.0, true, 1)  // 1 channel
        // gs1 = granstream(input_ugen, 20, 1.0, true, 1)  // 1 channel
        gs1.play()
        grfr = filerec("./groutput.wav", gs1, 2)
        grfr.run()
        grfr.go()
    else:
        gs1.mute()  // immediate stop
        gs1 = nil   // eventual cleanup
        grfr.stop()
        grfr.unrun()
        grfr = nil


########## GRANSTREAM WITH FEEDBACK TEST #############
// uses a very short duration so input gets "smeared" by only 0.3s
// allowing us to clearly hear the feedback that comes 2s later.

def gsfbtest(obj, event, x, y):
# create a granstream to granulate microphone input
    display "gstest - granstream applied microphone input ", x
    if x:
        gs1 = granstream(input_ugen, 20, 1.0, true, 2)  // 2 channel
        gs1.set_density(5.0)
        // gs1 = granstream(input_ugen, 1, 3.0, true, 2)  // 2 channel
        // gs1 = granstream(input_ugen, 1, 3.0, true, 1)  // 1 channel
        // gs1 = granstream(input_ugen, 20, 1.0, true, 1)  // 1 channel
        gs1.set_delay(2)
        gs1.set_feedback(0.9)
        gs1.play()
        grffr = filerec("./grfoutput.wav", gs1, 2)
        grffr.run()
        grffr.go()
    else:
        gs1.mute()  // immediate stop
        gs1 = nil   // eventual cleanup
        grffr.stop()
        grffr.unrun()
        grffr = nil


########## PWE TEST #############

def pwetest(obj, event, x, y):
# create a tone with pwe envelope
    display "pwetest - tones with pwl and pwe envelopes"
    pwlnote()
    sched_select(rtsched)
    sched_cause(1.3, nil, 'pwenote')
    
def pwlnote()
    print "pwlnote starting to play"
    var env = pwlb(0.2, 0.5, 1.0)
    var note = mult(sine(880.0, 1.0), env)
    env.atend(MUTE, note)
    note.play()

def pwenote()
    print "pwenote starting to play"
    var env = pweb(0.2, 0.5, 1.0)
    var note = mult(sine(880.0, 1.0), env)
    env.atend(MUTE, note)
    note.play()


########## ALPASS TEST #############

def alptest(obj, event, x, y):
# This test performs a sequence of sounds:
# 1. create and apply an alpass filter to a frequency sweep
# 2. same test, but use a comb filter instead
# 3. apply reverb with 1s reverb time to frequency sweep
# 4. change the reverb time on the same reverb object to 5s and
#       switch input to a new frequency sweep generator
# 5. remove the reverb object and clean up
    display "alptest - tones with and without alpass filter"
    sweep()
    sched_select(rtsched)
    sched_cause(2.0, nil, 'alpsweep')
    sched_cause(4.0, nil, 'cmbsweep')
    sched_cause(6.0, nil, 'rvbsweep')
    sched_cause(8.0, nil, 'rvbsweep2')

def sweeper():
# make a sine tone sweep with amp that goes to zero at 0.4s
    var swpwl = pwlb(0.0, 440.0, 0.4, 1760.0, 10.0)
    var swsine = sine(swpwl, 1.0)
    sched_select(rtsched)
    sched_cause(0.4, swsine, 'set', 'amp', 0.0)
    return swsine

def sweep()
    var swsine = sweeper()
    swsine.play()
    sched_cause(0.5, swsine, 'mute')

def alpsweep()
    var swsine = sweeper()
    var alp = alpass(swsine, 0.04, 0.9, 0.041)
    alp.play()
    sched_cause(2, alp, 'mute')

def cmbsweep()
    var swsine = sweeper()
    var cmb = delay(swsine, 0.04, 0.9, 0.041)
    cmb.play()
    sched_cause(2, cmb, 'mute')

def rvbsweep()
# create reverb and send in a sine sweep
    var swsine = sweeper()
    rvb = reverb(swsine, 1.0)  // GLOBAL
    rvb.play()

def rvbsweep2()
# set reverb time to 5s and send in another sine sweep
    var swsine = sweeper()
    rvb.set_rt60(5.0)
    rvb.set_inp(swsine)
    sched_cause(6, nil, 'rvbfinish')

def rvbfinish():
    rvb.mute()
    rvb = nil  // allow GC


########## FLSYN TEST #############

flsyn_ugen = nil

def flstest(obj, event, x, y):
    if not flsyn_ugen:
        flsyn_ugen = Flsyn(SOUNDFONT)
        print "Created Flsyn unit generator with sound font"
        print "    ", SOUNDFONT
        flsyn_ugen.play()
        return
    sched_select(rtsched)
    flsyn_ugen.program_change(0, 0)
    fls_sequence(0, 50)

def fls_sequence(program, pitch):
    var delay = 0.2
    flsyn_ugen.noteon(0, pitch, 100)
    sched_cause(1.0, flsyn_ugen, 'noteoff', 0, pitch)
    pitch = pitch + 5
    if pitch > 70:
        pitch = 50
        program = program + 1
        if program > 20:
            return
        flsyn_ugen.program_change(0, program)
        delay = 1.0
    sched_cause(delay, nil, 'fls_sequence', program, pitch)


########## PHASE VOCODER TEST #############

// handler for pvcheckbox: play/stop phase vocoder test
def pvtest(obj, event, x, y):
    display "pvtest", x
    if x:
        pv = pv(input_ugen, 0.5, 2048, 512, 8, 1)
        display "pvtest made pv", pv
        pv.play()
//        pvfr = filerec("./pvoutput.wav", pv, 1)
//        pvfr.run()
//        pvfr.go()
    else:
        pv.mute()
//        pvfr.stop()
//        pvfr.unrun()
//        pvfr = nil
        pv = nil



########## YIN TEST #############

yin_handler_installed = false

def actl_yin(timestamp, address, types, pitch, harmonicity, rms)
    print "YIN OUTPUT:", pitch, harmonicity, rms
    var text = ""
    if harmonicity < 0.1 and rms > 0.01:
        text = str(pitch)
    yintext.set_string(text)

    
// handler for yincheckbox: play/stop yin analysis of input
def yintest(obj, event, x, y):
    display "yintest", x
    if x:
        if not yin_handler_installed:
            o2_method_new("/actl/yin", "fff", 'actl_yin', t)
            print "installed yin handler"
            yin_handler_installed = true
        yininp = input_ugen

        yin = yin(yininp, 36, 72, 882, "/actl/yin")
        yin.run()
    else:
        yin.unrun()
        yin = nil
        yininp = nil



########## TRIG TEST #############

trig_handler_installed = false

def actl_trig(timestamp, address, types, idnum, rms)
    display "TRIG ONSET DETECTED:", idnum, rms
    trigtext.set_string(TRIG_ON_TEXT)
    sched_select(rtsched)
    sched_cause(0.1, trigtext, 'set_string', TRIG_OFF_TEXT)

    
def actl_onoff(timestamp, address, types, idnum, onoff)
    display "TRIG ONOFF OUTPUT:", idnum, onoff
    onofftext.set_string(ONOFF_ON_TEXT if onoff == 1 else ONOFF_OFF_TEXT)

    
// handler for trigcheckbox: play/stop trig analysis of input
def trigtest(obj, event, x, y):
    display "trigtest", x
    if x:
        if not trig_handler_installed:
            o2_method_new("/actl/trig", "if", 'actl_trig', t)
            o2_method_new("/actl/onoff", "ii", 'actl_onoff', t)
            print "installed trig handler"
            trig_handler_installed = true
        trig = trig(input_ugen, "/actl/trig", 128, 0.05, 0.2)
        trig.onoff("/actl/onoff", 0.03, 0.1)
        trig.run()
    else:
        trig.unrun()
        trig = nil



########## File Play/Record TEST #############

class File_play_record:
    var fply, frec

    def init():
        fply = fileplay("./testinput.wav", 1)
        frec = filerec("./testoutput.wav", fply, 1)
        fply.atend(FINISH, this)
        fply.go()
        frec.run()
        frec.go()

    def finish(optional status):  // stop recording and clean up
        frec.stop()
        frec.unrun()
        frec = nil
        fply = nil


// handler for fprbutton: play file and record it
def file_play_record(obj, event, x, y):
    display "file_play_record", x
    File_play_record()



########## Main Initialization ################

def arco_prugens_handler(rest ignore):
    // this tells Arco to print the Ugen tree -- it can be useful for
    //     debugging.
    o2_send_cmd("/arco/prtree", 0, "")
    // also print the list of Ugens accessible by integer ID:
    o2_send_cmd("/arco/prugens", 0, "")


def arco_ugen_gc_info_handler(rest ignore):
    arco_ugen_gc_info()


def main():
    o2_debug_flags("") // ("SsBl")
    arco_set_input_files([sound_file_path])
    arco_init(latency = 60, network = false, title = "Arco Test")
    arco_run()
    sched_select(rtsched)
    var file_menu = default_window.get_menu("File")
    file_menu.item("Print Ugen Info", "print Ugen tree and table",
                   nil, nil, 'arco_prugens_handler')
    file_menu.item("Arco Ugen GC Info", "print info about Ugen IDs",
                   nil, nil, 'arco_ugen_gc_info_handler')


main()
