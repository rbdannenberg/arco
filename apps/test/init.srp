# init.srp -- Serpent library for controlling Arco
#
# Roger B. Dannenberg
# Jan 2022

# call arco_init(ensemble) to start
# call arco_run() after setting up UI and or scheduling things
# arco_ready is set to true when arco is ready for action

print "apps/daserpent/init.srp is loading, getcwd() ->", getcwd()

require "debug"
require "wxserpent"
require "prob"
require "arco"
require "allugens"
require "reverb"
require "soundfont"
require "pan"
require "instr"
require "synth"
require "supersaw"
require "supersawdemo"

SIMPLE = false

class Atone (Instrument):
    var env, renv

    def init(freq, dur, nharm):
        display "Atone", dur
        instr_begin()
        env = pwlb(dur * 0.2, 0.01, dur * 0.8)
        display "In Atone", env, env.id, id(env.id)
        env.term()  // allow envelope to terminate; termination
        // will propagate all the way to the output, which will
        // remove and free the instrument (assuming there are no
        // other references to it, which we will avoid).
        var mix = mix(1).term()
        for i = 0 to nharm:
            // we need a symbol for each mixer input but since the
            // number of inputs is controlled by nharm, we have to
            // manufacture symbols:
            var name = intern("i" + str(i))
            mix.ins(name, sine(freq * i, 0.8 ** i), env)
        if not SIMPLE and pr_coin(0.5):
            // reson filter center frequency envelope:
            renv = pwlb(random(), pr_unif(4, 10) * freq,
                        5.0, 200.0, max(5.0, dur * 2))
            var q = pr_unif(0.5, 2.0)
            mix = reson(mix, renv, q)
        super.init("Atone", mix)


    def start():
        env.start()
        if renv:  // start the reson filter envelope too if it exists
            renv.start()
        this


ui_initialized = false
ready_count = 0

def arco_ready():
# called when arco is intialized and ready to make sound or when
# arco audio stream has been reopened
    display "**** arco audio is running! ****", ready_count
    ready_count = ready_count + 1
    if ready_count > 1:
        display "arco_ready called again", ready_count
        breakpoint()
    var win = default_window
    if ui_initialized:
        return

    display "arco_ready", wxs_h, wxs_space,
    display WXS_DEFAULT_HEIGHT, WXS_DEFAULT_SPACE
    var WIDTH = 170
    var COLUMN_X = 5  // changes to 200 for Column 2
    var COLUMN_TWO = 200

    Checkbox(win, "Simple test", COLUMN_X, 5, WIDTH, 20, 'stcheckbox')
    stcheckbox.add_target_method(nil, 'play_simple_test')

    Checkbox(win, "Cleanup test", 'S', 'D', WIDTH, 20, 'simtoncheckbox')
    simtoncheckbox.add_target_method(nil, 'play_simple_tone')

    Checkbox(win, "Finish test", 'S', 'D', WIDTH, 20, 'finishcheckbox')
    finishcheckbox.add_target_method(nil, 'play_finish_test')

    Checkbox(win, "Mixer test", 'S', 'D', idiv(WIDTH, 2), 'S', 'mtcheckbox')
    mtcheckbox.add_target_method(nil, 'play_mixer_test')

    Choice(win, 'R', 'S', 'S', 'S', 'mixmodechoice')
    mixmodechoice.append("a. linear")
    mixmodechoice.append("b. exponential")
    mixmodechoice.append("c. lowpass")
    mixmodechoice.append("d. smooth")

    wxs_x = COLUMN_X
    Checkbox(win, "Atonal sequence", 'S', 'D', WIDTH, 'S', 'atcheckbox')
    atcheckbox.add_target_method(nil, 'play_atone_test')

    Button(win, "Play sound file", 'S', 'D', 'S', 'S', 'psfbutton')
    psfbutton.add_target_method(nil, 'play_sound_file')

    Checkbox(win, "Record Output", 'S', 'D', 'S', 'S', 'rocheckbox')
    rocheckbox.add_target_method(nil, 'record_output')

    Checkbox(win, "Record Output Stereo", 'S', 'D', 'S', 'S', 'ro2checkbox')
    ro2checkbox.add_target_method(nil, 'record_output_2')

    Checkbox(win, "Play Recorded Output", 'S', 'D', 'S', 'S', 'procheckbox')
    procheckbox.add_target_method(nil, 'play_recorded_output')

    Checkbox(win, "Play Recorded Up", 'S', 'D', 'S', 'S', 'proucheckbox')
    proucheckbox.add_target_method(nil, 'play_recorded_output_up')

    Checkbox(win, "Play Recorded Down", 'S', 'D', 'S', 'S', 'prodncheckbox')
    prodncheckbox.add_target_method(nil, 'play_recorded_output_down')

    Checkbox(win, "Delay Test", 'S', 'D', 'S', 'S', 'dlycheckbox')
    dlycheckbox.add_target_method(nil, 'delay_test')

    Checkbox(win, "Pitch Shift Test", 'S', 'D', 'S', 'S', 'pscheckbox')
    pscheckbox.add_target_method(nil, 'pstest')

    Checkbox(win, "Feedback Test", 'S', 'D', 'S', 'S', 'fbcheckbox')
    fbcheckbox.add_target_method(nil, 'fbtest')

    Checkbox(win, "Granstream Test", 'S', 'D', 'S', 'S', 'gscheckbox')
    gscheckbox.add_target_method(nil, 'gstest')

    Checkbox(win, "Gran. with Feedback", 'S', 'D', 'S', 'S',
             'gsfbcheckbox')
    gsfbcheckbox.add_target_method(nil, 'gsfbtest')

    Checkbox(win, "Reverb", 'S', 'D', 'S', 'S',
             'rvbcheckbox')
    rvbcheckbox.add_target_method(nil, 'rvbtest')

    Checkbox(win, "PWE Update", 'S', 'D', 'S', 'S',
             'pweucheckbox')
    pweucheckbox.add_target_method(nil, 'pweutest')

    Checkbox(win, "PWL Update", 'S', 'D', 'S', 'S',
             'pwlucheckbox')
    pwlucheckbox.add_target_method(nil, 'pwlutest')


    Button(win, "Pwl/Pwe Test", 'S', 'D', 'S', 'S', 'pwecheckbox')
    pwecheckbox.add_target_method(nil, 'pwetest')

    Button(win, "Allpass Test", 'S', 'D', 'S', 'S', 'alpcheckbox')
    alpcheckbox.add_target_method(nil, 'alptest')

    Button(win, "Flsyn Test", 'S', 'D', 'S', 'S', 'flscheckbox')
    flscheckbox.add_target_method(nil, 'flstest')

    Checkbox(win, "Phase vocoder", 'S', 'D', 'S', 'S', 'pvcheckbox')
    pvcheckbox.add_target_method(nil, 'pvtest')
    
    Button(win, "File Play/Record", 'S', 'D', 'S', 'S', 'fprbutton')
    fprbutton.add_target_method(nil, 'file_play_record')

    Checkbox(win, "Yin", 'S', 'D', 55, 'S', 'yincheckbox')
    yincheckbox.add_target_method(nil, 'yintest')

    Statictext(win, "", 'R', wxs_y + 2, 100, wxs_h - 2, 'yintext')
    
    wxs_x = COLUMN_X
    Checkbox(win, "Trig", 'S', 'D', 55, 'S', 'trigcheckbox')
    trigcheckbox.add_target_method(nil, 'trigtest')

    TRIG_ON_TEXT = "◼ Trig"
    TRIG_OFF_TEXT = "◻ Trig"
    Statictext(win, TRIG_OFF_TEXT, 'R', wxs_y + 2, 50, 'S', 'trigtext')

    ONOFF_ON_TEXT = "◼ On/Off"
    ONOFF_OFF_TEXT = "◻ On/Off"
    Statictext(win, ONOFF_OFF_TEXT, 'R', 'S', 'S', 'S', 'onofftext')

    wxs_x = COLUMN_X
    Checkbox(win, "Fade", 'S', 'D', 60, 'S', 'fadecheckbox')
    fadecheckbox.add_target_method(nil, 'fadetest')

    Choice(win, COLUMN_X + 10, 'D', WIDTH, 'S', 'fadechoice')
    fadechoice.append("a. 1.000 sec, linear")
    fadechoice.append("b. 1.000 sec, exponential")
    fadechoice.append("c. 1.000 sec, lowpass")
    fadechoice.append("d. 1.000 sec, smooth")
    fadechoice.append("e. 0.009 sec, linear")
    fadechoice.append("f. 0.009 sec, exponential")
    fadechoice.append("g. 0.009 sec, lowpass")
    fadechoice.append("h. 0.009 sec, smooth")
// These send in an audio signal where every sample is 1 so if
// you print the result during fade, you'll see exactly the
// fade curve.
//    fadechoice.append("i. 0.009 sec, linear step")
//    fadechoice.append("j. 0.009 sec, exponential step")
//    fadechoice.append("k. 0.009 sec, lowpass step")
//    fadechoice.append("l. 0.009 sec, smooth step")

    # start a 2nd column
    COLUMN_X = COLUMN_TWO
    wxs_x = COLUMN_TWO

    wxs_y = 5 - wxs_h  // 'D' will get y = wxs_y + wxs_h = 5

    wxs_x = COLUMN_X
    Checkbox(win, "Add Test", 'S', 'D', 'S', 'S', 'addcheckbox')
    addcheckbox.add_target_method(nil, 'addtest')

    Checkbox(win, "Sub Test", 'S', 'D', 'S', 'S', 'subcheckbox')
    subcheckbox.add_target_method(nil, 'subtest')

    Checkbox(win, "Div Test", 'S', 'D', 'S', 'S', 'divcheckbox')
    divcheckbox.add_target_method(nil, 'divtest')

    Checkbox(win, "Max Test", 'S', 'D', 'S', 'S', 'maxcheckbox')
    maxcheckbox.add_target_method(nil, 'maxtest')

    Checkbox(win, "Min Test", 'S', 'D', 'S', 'S', 'mincheckbox')
    mincheckbox.add_target_method(nil, 'mintest')

    Checkbox(win, "Clip Test", 'S', 'D', 'S', 'S', 'clpcheckbox')
    clpcheckbox.add_target_method(nil, 'clptest')

    Checkbox(win, "Pow Test", 'S', 'D', 'S', 'S', 'powcheckbox')
    powcheckbox.add_target_method(nil, 'powtest')

    Checkbox(win, "Lessthan Test", 'S', 'D', 'S', 'S', 'ltcheckbox')
    ltcheckbox.add_target_method(nil, 'lttest')

    Checkbox(win, "Greaterthan Test", 'S', 'D', 'S', 'S', 'gtcheckbox')
    gtcheckbox.add_target_method(nil, 'gttest')

    Checkbox(win, "Soft Clip Test", 'S', 'D', 'S', 'S', 'scpcheckbox')
    scpcheckbox.add_target_method(nil, 'scptest')

    Checkbox(win, "Integer Power Test", 'S', 'D', 'S', 'S', 'pwicheckbox')
    pwicheckbox.add_target_method(nil, 'pwitest')

    Checkbox(win, "Random Test", 'S', 'D', 'S', 'S', 'rndcheckbox')
    rndcheckbox.add_target_method(nil, 'rndtest')

    Checkbox(win, "Sample Hold Test", 'S', 'D', 'S', 'S', 'shcheckbox')
    shcheckbox.add_target_method(nil, 'shtest')

    Checkbox(win, "Quantization Test", 'S', 'D', 'S', 'S', 'qntcheckbox')
    qntcheckbox.add_target_method(nil, 'qnttest')
    
    Checkbox(win, "RandLinInterp Test", 'S', 'D', 'S', 'S', 'rlicheckbox')
    rlicheckbox.add_target_method(nil, 'rlitest')
    
    
    Checkbox(win, "Chorddetect Test", 'S', 'D', 'S', 'S', 'chorddetectcheckbox')
    chorddetectcheckbox.add_target_method(nil, 'chorddetecttest')
    Statictext(win, "----", 'R', 'S', 'S', 'S', 'chorddetecttext')
    Statictext(win, "----", 'S', 'D', 'S', 'S', 'chorddetectintdata')
    
    wxs_x = COLUMN_X
    Checkbox(win, "Spectral Centroid Test", 'S', 'D', 'S', 'S', 'spectralcentroidcheckbox')
    spectralcentroidcheckbox.add_target_method(nil, 'spectralcentroidtest')
    Statictext(win, "----", 'R', 'S', 'S', 'S', 'spectralcentroidtext')
    
    wxs_x = COLUMN_X
    Checkbox(win, "Spectral Rolloff Test", 'S', 'D', 'S', 'S', 'spectralrolloffcheckbox')
    spectralrolloffcheckbox.add_target_method(nil, 'spectralrollofftest')
    Statictext(win, "----", 'R', 'S', 'S', 'S', 'spectralrollofftext')

    wxs_x = COLUMN_X
    Checkbox(win, "Onset", 'S', 'D', 55, 'S', 'onsetcheckbox')
    onsetcheckbox.add_target_method(nil, 'onsettest')
    
    ONSET_ON_TEXT = "◼ Onset"
    ONSET_OFF_TEXT = "◻ Onset"
    Statictext(win, ONSET_OFF_TEXT, 'R', wxs_y + 2, 55, 'S', 'onsettext')

    wxs_x = COLUMN_X
    Checkbox(win, "O2audioio Test", 'S', 'D', WIDTH, 'S', 'o2audioiocheckbox')
    o2audioiocheckbox.add_target_method(nil, 'o2audioiotest')
    
    Checkbox(win, "Zitarev Test", 'S', 'D', WIDTH, 'S', 'zitarevcheckbox')
    zitarevcheckbox.add_target_method(nil, 'zitarevtest')

    Checkbox(win, "sttest", 'S', 'D', WIDTH, 'S', 'sttestcheckbox')
    sttestcheckbox.add_target_method(nil, 'sttesttest')

    Checkbox(win, "tableosc", 'S', 'D', WIDTH, 'S', 'tableosccheckbox')
    tableosccheckbox.add_target_method(nil, 'tableosctest')

    Checkbox(win, "supersaw", 'S', 'D', WIDTH, 'S', 'supersawcheckbox')
    supersawcheckbox.add_target_method(nil, 'supersawtest')

    Checkbox(win, "Overdrive Test", 'S', 'D', WIDTH, 'S', 'overdrivecheckbox')
    overdrivecheckbox.add_target_method(nil, 'overdrivetest')

    ui_initialized = true
    default_window.fit_to_children()


def atone_sequence():
    var step = 40 + irandom(40)
    var freq = 440.0 * (2.0 ** (1/12)) ** (step - 69)
    var dur = pr_unif(0.5, 10)
    var nharm = 1 if SIMPLE else irandom(15) + 2
    display "atone_sequence", freq, dur, nharm, sched_current,
    display     vtsched, sched_vtime
    // careful here: start() is a method of Atone, but we must "play"
    // the Ugen returned by stereoize. (We could have put stereoize
    // inside Atone, but we didn't.)  There's no race condition where
    // envelopes could start before we're connected to output because
    // until we are connected to some sink (like audio output), there
    // will be no calls to compute samples, so envelopes will sit and
    // wait even if we get connected to output long after .start().
    stereoize(Atone(freq, dur, nharm).start()).play()
    var ioi = pr_unif(0.25, 2.0) ** 2
    if atone_running:
        sched_cause(ioi, nil, 'atone_sequence')


// handler for /host/openaggr messages with param info (a string)
def host_openaggr(timestamp, address, types, info)
    var LATENCY_MS = 50
    print info
    if find(info, "Aggregate") >= 0 or find(info, "default") >= 0:
        var id = int(info)
        print "  --> opening this device, id", id
        arco_open(id, id, 2, 2, LATENCY_MS, 32)
        o2_send_cmd("/arco/open", 0, "iiiiiis", id, id, 2, 2, LATENCY_MS, 32,
                    "actl");
        o2_send_cmd("/arco/prtree", o2_time_get() + 1, "");
        

def host_openaggr_init()
    o2_service_new("host")
    o2_method_new("/host/openaggr", "s", 'host_openaggr', t)



######### Synthesis Tests ##############

// handler for stcheckbox: play/stop some sine tones
def play_simple_test(obj, event, x, y):
    display "play_simple_test", x
    if x:
        sin1 = sine(440.0, 0.01).play()
        sin2 = sine(880.0, 0.01).play()
        sin3 = sine(1320.0, 0.007).play()
        sin4 = sine(1760.0, 0.005).play()
    else:
        sin1.mute()
        sin1 = nil  // delete reference for garbage collection
        sin2.mute()
        sin2 = nil
        sin3.mute()
        sin3 = nil
        sin4.mute()
        sin4 = nil


// handler for simtoncheckbox: play/stop some sine tones
def play_simple_tone(obj, event, x, y):
# this is a cleanup test: in this version, env termination propagates
# through mult to the output sum, which releases the calculation tree
# after unchecking the box releases simton_out.
    display "play_simple_tone", x
    if x:
        var env = pweb(start = true, lin = true, 0.5, 1, 3, 1, 4)
        env.term()
        var sin1 = sine(440.0, 0.01)
        var sin2 = sine(880.0, 0.01)
        var sin3 = sine(1320.0, 0.007)
        var sin4 = sine(1760.0, 0.005)
        var sum = sum().ins(sin1, sin2, sin3, sin4)
        simton_out = mult(sum, env).play()
    else:
        simton_out = nil


class Finishtest:
# This is not a good example of how to do anything "right", but it 
# exercises some code for atend, FINISH, and cleanup. When created,
# global finish_test gets the object holding `out`, so the calculation
# tree has a reference and is retained, but when box is unchecked,
# finish_test is cleared and envelope ramps down. When it ends, 
# finish should mute the output and everything is garbage collected.
    var out  // output ugen
    var env  // envelope (need reference for noteoff)


    def init():
        env = pweb(start = true, lin = true, 0.5, 1)
        env.atend(FINISH, this)
        var sin1 = sine(440.0, 0.01)
        var sin2 = sine(880.0, 0.01)
        var sin3 = sine(1320.0, 0.007)
        var sin4 = sine(1760.0, 0.005)
        var sum = sum().ins(sin1, sin2, sin3, sin4)
        out = mult(sum, env).play()        

    def noteoff():
        env.decay(2).term()
        print "started 2 sec decay"

    def finish(status, finisher, parameters):
        display "Finishtest.finish", status, status & ACTION_END, finisher,
        display     parameters
        if (status & ACTION_END) == 0:
            print "**** WARNING: finish called but not on ACTION_END"
        out.mute()


// handler for finishcheckbox: play/stop some sine tones
def play_finish_test(obj, event, x, y):
# this is a test for atend(FINISH, this): when box is unchecked, noteoff
# sends ending to envelope, which sends finish() to instrument, which 

    display "play_simple_tone", x
    if x:
        finish_test = Finishtest()  // make finish_test
    else:
        finish_test.noteoff()
        finish_test = nil
        


// handler for mtcheckbox: play/stop some sine tones
def play_mixer_test(obj, event, x, y):
    var which = mixmodechoice.value()
    var mode = ord(which) - ord("a")
    if x:
        m1 = mix(2)

        ms1 = sine(440.0, 0.01)
        m1.ins('inp1', ms1, [1, 0], 0.1, mode)

        ms2 = sine(880.0, 0.01)
        ms3 = sine(1320.0, 0.007)
        sched_select(rtsched)
        sched_cause(0.2, m1, 'ins', 'inp2', ms2, [0, 1], 0.1, mode)

        sched_cause(0.4, m1, 'ins', 'inp3', ms3, 1, 0.1, mode)

        sched_cause(0.6, m1, 'ins', 'inp4', sine(1760.0, 0.005), 1, 0.1, mode)

        m1.play()

        sched_select(rtsched)
        sched_cause(1.6, nil, 'mixer_gain_change_1')
        sched_cause(2.6, nil, 'mixer_gain_change_2')
    else:
        // There is a bug here: if you stop before all sines are created
        // and inserted, a .rem() call will fail, and later the sine will
        // be inserted, so that sine will play forever. A fix would be to
        // schedule a smarter insert operation that checks to make sure
        // we haven't turned this mix test off before doing an .ins().
        m1.rem('inp1', 1.0, mode) // test for stereo fade output to silence
        m1.rem('inp2', 1.0, mode)
        m1.rem('inp3', 1.0, mode)
        m1.rem('inp4', 1.0, mode)

        m1 = nil  // delete references
        ms1 = nil
        ms2 = nil
        ms3 = nil


def mixer_gain_change_1():
    if m1:  // user has not stopped test yet
        m1.set_gain('inp1', 5, 0)  // left channel

def mixer_gain_change_2():
    if m1:  // user has not stopped test yet
        m1.set_gain('inp2', 5, 1)  // right channel


########## RECPLAY TESTS ##################

recplay1 = nil

def record_output(obj, event, x, y, optional chans = 1):
    display "record_output", x, chans
    if x:
        if not recplay1 or recplay1.chans != chans:
            if recplay1:
                print "shutting down recplay1 because it has", recplay1.chans,
                print     "channels and we want", chans
                recplay1.record(false)
                recplay1.unrun()
            // long fade time to test this feature
            recplay1 = recplay(output_ugen, chans, 0.5, 3.0, false)
        recplay1.run()  # needs be in run set to make active
        recplay1.record(true)
    elif not recplay1:
        print "WARNING: There is no recplay1 Ugen!"
    else:
        recplay1.record(false)
        recplay1.unrun()  # does not need to be active now


def record_output_2(obj, event, x, y):
    display "record_output_2", x
    record_output(obj, event, x, y, 2)


def play_recorded_output(obj, event, x, y, optional speed = 1):
    display "play_recorded_output", x, speed
    if x and recplay1:
        // note that Recplay might end playback immediately upon starting,
        // so we need to set up the atend action before sending 'start':
        recplay1.play().atend(MUTE)
        recplay1.set_speed(speed)
        recplay1.start(0.056)  // tests for non-zero start time
    elif (not x) and recplay1:
        recplay1.stop()  // atend is already set up to mute when finished


def play_recorded_output_up(obj, event, x, y):
    display "play_recorded_output_up", x
    play_recorded_output(obj, event, x, y, 1.2)


def play_recorded_output_down(obj, event, x, y):
    display "play_recorded_output_up", x
    play_recorded_output(obj, event, x, y, 0.8)


############ ATONE: INSTRUMENT AND NOTE SEQUENCE ##############

// handler for atcheckbox: play/stop an algorithmic composition
def play_atone_test(obj, event, x, y)
    atone_running = x
    if x:
        sched_select(vtsched)  // vtsched stops when audio stops
        atone_sequence()

############ PLAY SOUND FILE ##############

sound_file_path = "/Users/rbd/Music/soundscape1/digichoir1.wav"

// handler for psfbutton: play the sound file
def play_sound_file(rest ignore):
# We could simply play the Fileplay Ugen, but we're using a
# Mix(er) to provide an (unused) gain control and also to
# show how the Mix and Fileplay can be freed when the sound
# finishes.
    var m1 = mix(2)
    var sp = fileplay(sound_file_path, 2)
    m1.ins('sndfile', sp, 1)  // sp reference handed off to m1
    m1.play()  // connect mixer to output
    sp.atend(MUTE, m1)  // "when the sound file finishes, mute m1"
    // The mute method will delete m1. If it were not a local var,
    // we would call m1.ref() here.
    sp.go()     // play the sound file


########## DELAY TEST ################

def delay_test(obj, event, x, y):
    display "delay_test", x
    if x:
        dly1 = delay(input_ugen, 1.0, 0.1, 2.0, 2)
        dly1.play()
    else:
        dly1.mute()  // immediate stop
        dly1 = nil   // eventual cleanup when GC frees it

########## PITCH SHIFT TEST #############

def pstest(obj, event, x, y):
    display "pstest - pitch shift", x
    if x:
        ps1 = ola_pitch_shift(input_ugen, 1.25, 0.01, 0.05)
        ps1.play()
    else:
        ps1.mute()  // immediate stop
        ps1 = nil   // eventual cleanup when GC frees it

########## FEEDBACK TEST #############

def fbtest(obj, event, x, y):
# create a delay with no internal feedback and use a feedback ugen to
# produce feedback. The delay test used 0.1 gain on feedback so we do
# the same here, and set delay to 1 second as with delay test.
    display "fbtest - feedback", x
    if x:
        // initially "from" is zero; then we replace it with delay
        fb1 = feedback(input_ugen, zero_ugen, 0.5)
        fb2 = delay(fb1, 1.0, 0.0, 2.0)
        fb1.set('from', fb2)  // feedback from delay output
        fb2.play()
    else:
        fb2.mute()  // immediate stop
        fb1.set('from', zero_ugen)  // break the cycle to allow GC
        fb1 = nil   // eventual cleanup when GC frees it
        fb2 = nil


########## GRANSTREAM TEST #############

def gstest(obj, event, x, y):
# create a granstream to granulate microphone input
    display "gstest - granstream applied microphone input ", x
    if x:
        gs1 = granstream(input_ugen, 20, 3.0, true, 2)  // 2 channel
        gs1.set_density(5.0)
        // gs1 = granstream(input_ugen, 1, 3.0, true, 2)  // 2 channel
        // gs1 = granstream(input_ugen, 1, 3.0, true, 1)  // 1 channel
        // gs1 = granstream(input_ugen, 20, 1.0, true, 1)  // 1 channel
        gs1.play()
        grfr = filerec("./groutput.wav", gs1, 2)
        grfr.run()
        grfr.go()
    else:
        gs1.mute()  // immediate stop
        gs1 = nil   // eventual cleanup
        grfr.stop()
        grfr.unrun()
        grfr = nil


########## GRANSTREAM WITH FEEDBACK TEST #############
// uses a very short duration so input gets "smeared" by only 0.3s
// allowing us to clearly hear the feedback that comes 2s later.

def gsfbtest(obj, event, x, y):
# create a granstream to granulate microphone input
    display "gstest - granstream applied microphone input ", x
    if x:
        gs1 = granstream(input_ugen, 20, 1.0, true, 2)  // 2 channel
        gs1.set_density(5.0)
        // gs1 = granstream(input_ugen, 1, 3.0, true, 2)  // 2 channel
        // gs1 = granstream(input_ugen, 1, 3.0, true, 1)  // 1 channel
        // gs1 = granstream(input_ugen, 20, 1.0, true, 1)  // 1 channel
        gs1.set_delay(2)
        gs1.set_feedback(0.9)
        gs1.play()
        grffr = filerec("./grfoutput.wav", gs1, 2)
        grffr.run()
        grffr.go()
    else:
        gs1.mute()  // immediate stop
        gs1 = nil   // eventual cleanup
        grffr.stop()
        grffr.unrun()
        grffr = nil


########## REVERB TEST #############
// Creates a reverb and puts noise into reverb while checked.

def rvbtest(obj, event, x, y):
    display "rvbtest - test a reverb with noise input"
    if x:
        var noise = ugen_rand(-0.1, 0.1)
        rvb1 = multi_reverb(noise, 4, 0.2, 10000, 2)
        rvb1.play()
    else:
        rvb1.set_input(zero_ugen)
        sched_select(rtsched)
        sched_cause(6, rvb1, 'mute')
        rvb1 = nil  // rvb1 and noise should be freed in 6 sec


########## PWE UPDATE TEST #############
// Creates a long PWE, but when you uncheck, it decays to zero

def pweutest(obj, event, x, y):
    display "pweutest - test pweb noise envelope", x
    if x:
        var noise = ugen_rand(-0.5, 0.5)
        pweu1 = pweb(0.1, 0.05, 10, 1, 11, 0)
        var prod = mult(noise, pweu1)
        prod.play()
    else:
        pweu1.stop()
        pweu1.set_points(1.0, 0).term().trace()
        pweu1.start()
        pweu1 = nil  // all should be freed in 6 sec

print "defined pweutest"

########## PWL UPDATE TEST #############
// Creates a long PWL, but when you uncheck, it decays to zero

def pwlutest(obj, event, x, y):
    display "pwlutest - test a reverb with noise input"
    if x:
        var noise = ugen_rand(-0.5, 0.5)
        pwlu1 = pwlb(0.1, 0.05, 10, 1)
        var prod = mult(noise, pwlu1).trace()
        prod.play()
    else:
        pwlu1.stop()
        pwlu1.set_points(1.0, 0).term().trace()
        pwlu1.start()
        pwlu1 = nil  // all should be freed in 6 sec


########## PWE TEST #############

def pwetest(obj, event, x, y):
# create a tone with pwe envelope
    display "pwetest - tones with pwl and pwe envelopes"
    pwlnote()
    sched_select(rtsched)
    sched_cause(1.3, nil, 'pwenote')
    
def pwlnote()
    print "pwlnote starting to play"
    var env = pwlb(0.2, 0.5, 1.0)
    var note = mult(sine(880.0, 1.0), env)
    env.atend(MUTE, note)
    note.play()

def pwenote()
    print "pwenote starting to play"
    var env = pweb(0.2, 0.5, 1.0)
    var note = mult(sine(880.0, 1.0), env)
    env.atend(MUTE, note)
    note.play()


########## ALLPASS TEST #############

def alptest(obj, event, x, y):
# This test performs a sequence of sounds:
# 1. create and apply an allpass filter to a frequency sweep
# 2. same test, but use a comb filter instead
# 3. apply reverb with 1s reverb time to frequency sweep
# 4. change the reverb time on the same reverb object to 5s and
#       switch input to a new frequency sweep generator
# 5. remove the reverb object and clean up
    display "alptest - tones with and without allpass filter"
    sweep()
    sched_select(rtsched)
    sched_cause(2.0, nil, 'alpsweep')
    sched_cause(4.0, nil, 'cmbsweep')
    sched_cause(6.0, nil, 'rvbsweep')
    sched_cause(8.0, nil, 'rvbsweep2')

def sweeper():
# make a sine tone sweep with amp that goes to zero at 0.4s
    var swpwl = pwlb(0.0, 440.0, 0.4, 1760.0, 10.0)
    var swsine = sine(swpwl, 1.0)
    sched_select(rtsched)
    sched_cause(0.4, swsine, 'set', 'amp', 0.0)
    return swsine

def sweep()
    var swsine = sweeper()
    swsine.play()
    sched_cause(0.5, swsine, 'mute')

def alpsweep()
    var swsine = sweeper()
    var alp = allpass(swsine, 0.04, 0.9, 0.041)
    alp.play()
    sched_cause(2, alp, 'mute')

def cmbsweep()
    var swsine = sweeper()
    var cmb = delay(swsine, 0.04, 0.9, 0.041)
    cmb.play()
    sched_cause(2, cmb, 'mute')

def rvbsweep()
# create reverb and send in a sine sweep
    var swsine = sweeper()
    rvb = reverb(swsine, 1.0)  // GLOBAL
    rvb.play()

def rvbsweep2()
# set reverb time to 5s and send in another sine sweep
    var swsine = sweeper()
    rvb.set_rt60(5.0)
    rvb.set_input(swsine)
    sched_cause(6, nil, 'rvbfinish')

def rvbfinish():
    rvb.mute()
    rvb = nil  // allow GC


########## FLSYN TEST #############

flsyn_ugen = nil

def flstest(obj, event, x, y):
    if not flsyn_ugen:
        flsyn_ugen = Flsyn(SOUNDFONT)
        print "Created Flsyn unit generator with sound font"
        print "    ", SOUNDFONT
        print "**** CLICK Flsyn Test BUTTON AGAIN TO PLAY *****"
        flsyn_ugen.play()
        return
    sched_select(rtsched)
    flsyn_ugen.program_change(0, 0)
    fls_sequence(0, 50)

def fls_sequence(program, pitch):
    var delay = 0.2
    flsyn_ugen.noteon(0, pitch, 100)
    sched_cause(1.0, flsyn_ugen, 'noteoff', 0, pitch)
    pitch = pitch + 5
    if pitch > 70:
        pitch = 50
        program = program + 1
        if program > 20:
            return
        flsyn_ugen.program_change(0, program)
        delay = 1.0
    sched_cause(delay, nil, 'fls_sequence', program, pitch)


########## PHASE VOCODER TEST #############

// handler for pvcheckbox: play/stop phase vocoder test
def pvtest(obj, event, x, y):
    display "pvtest", x
    if x:
        pv = pv(input_ugen, 0.5, 2048, 512, 8, 1)
        display "pvtest made pv", pv
        pv.play()
//        pvfr = filerec("./pvoutput.wav", pv, 1)
//        pvfr.run()
//        pvfr.go()
    else:
        pv.mute()
//        pvfr.stop()
//        pvfr.unrun()
//        pvfr = nil
        pv = nil



########## YIN TEST #############

yin_handler_installed = false

def actl_yin(timestamp, address, types, pitch, harmonicity, rms)
    print "YIN OUTPUT:", pitch, harmonicity, rms
    var text = ""
    if harmonicity < 0.1 and rms > 0.01:
        text = str(pitch)
    yintext.set_string(text)

    
// handler for yincheckbox: play/stop yin analysis of input
def yintest(obj, event, x, y):
    display "yintest", x
    if x:
        if not yin_handler_installed:
            o2_method_new("/actl/yin", "fff", 'actl_yin', t)
            print "installed yin handler"
            yin_handler_installed = true
        yininp = input_ugen

        yin = yin(yininp, 36, 72, 882, "/actl/yin")
        yin.run()
    else:
        yin.unrun()
        yin = nil
        yininp = nil


########## ONSET TEST #############

onset_handler_installed = false

def actl_onset(timestamp, address, types, idnum, channel) //idnum, rms are paremeters
    display "ONSET DETECTED:", idnum, channel
    onsettext.set_string(ONSET_ON_TEXT)
    sched_select(rtsched)
    sched_cause(0.1, onsettext, 'set_string', ONSET_OFF_TEXT)

    
// handler for onsetcheckbox: play/stop onset analysis of input
def onsettest(obj, event, x, y):
    display "onsettest", x
    if x:
        if not onset_handler_installed:
            o2_method_new("/actl/onset", "if", 'actl_onset', t)
            print "installed onset handler"
            onset_handler_installed = true
        onset = onset(input_ugen, "/actl/onset")
        onset.run()
    else:
        onset.unrun()
        onset = nil


########## CHORDDETECT TEST #############

chorddetect_handler_installed = false

def actl_chorddetect(timestamp, address, types, root_note_str, quality, interval,
                    confidence, root_note_int, pitches):
    # display root_note, quality, interval, confidence
    result = root_note_str + " " + quality + " " + str(interval) + ", " + str(confidence)
    int_result = str(root_note_int) + " " + str(pitches)
    chorddetecttext.set_string(result)
    chorddetectintdata.set_string(int_result)

        
def chorddetecttest(obj, event, x, y):
    display "chorddetect", x
    if x:
        if not chorddetect_handler_installed:
            o2_method_new("/actl/chorddetect", "ssifii", 'actl_chorddetect', t)
            print "installed chorddetect handler"
            chorddetect_handler_installed = true
        CD = chorddetect("/actl/chorddetect")
        CD.set('input', input_ugen)
        CD.run()
    else:
        CD.unrun()
        CD = nil
        
########## SPECTRALCENTROID TEST #############

spectralcentroid_handler_installed = false

def actl_spectralcentroid(timestamp, address, types, centroid)
    spectralcentroidtext.set_string(str(centroid))

        
def spectralcentroidtest(obj, event, x, y):
    display "spectralcentroid", x
    if x:
        if not spectralcentroid_handler_installed:
            o2_method_new("/actl/spectralcentroid", "f", 'actl_spectralcentroid', t)
            print "installed spectralcentroid handler"
            spectralcentroid_handler_installed = true
        sc_ugen = spectralcentroid("/actl/spectralcentroid")
        sc_ugen.set('input', input_ugen)
        sc_ugen.run()
    else:
        sc_ugen.unrun()
        sc_ugen = nil
        
########## SPECTRALROLLOFF TEST #############

spectralrolloff_handler_installed = false

def actl_spectralrolloff(timestamp, address, types, rolloff_freq)
    spectralrollofftext.set_string(str(rolloff_freq))

        
def spectralrollofftest(obj, event, x, y):
    display "spectralrolloff", x
    if x:
        if not spectralrolloff_handler_installed:
            o2_method_new("/actl/spectralrolloff", "f", 'actl_spectralrolloff', t)
            print "installed spectralrolloff handler"
            spectralrolloff_handler_installed = true
        sr_ugen = spectralrolloff("/actl/spectralrolloff", 0.5)
        sr_ugen.set('input', input_ugen)
        sr_ugen.run()
    else:
        sr_ugen.unrun()
        sr_ugen = nil

########## TRIG TEST #############

trig_handler_installed = false

def actl_trig(timestamp, address, types, idnum, rms)
    display "TRIG ONSET DETECTED:", idnum, rms
    trigtext.set_string(TRIG_ON_TEXT)
    sched_select(rtsched)
    sched_cause(0.1, trigtext, 'set_string', TRIG_OFF_TEXT)

    
def actl_onoff(timestamp, address, types, idnum, onoff)
    display "TRIG ONOFF OUTPUT:", idnum, onoff
    onofftext.set_string(ONOFF_ON_TEXT if onoff == 1 else ONOFF_OFF_TEXT)

    
// handler for trigcheckbox: play/stop trig analysis of input
def trigtest(obj, event, x, y):
    display "trigtest", x
    if x:
        if not trig_handler_installed:
            o2_method_new("/actl/trig", "if", 'actl_trig', t)
            o2_method_new("/actl/onoff", "ii", 'actl_onoff', t)
            print "installed trig handler"
            trig_handler_installed = true
        trig = trig(input_ugen, "/actl/trig", 128, 0.05, 0.2)
        trig.onoff("/actl/onoff", 0.03, 0.1)
        trig.run()
    else:
        trig.unrun()
        trig = nil



########## File Play/Record TEST #############

class File_play_record:
    var fply, frec

    def init():
        fply = fileplay("./testinput.wav", 1)
        frec = filerec("./testoutput.wav", fply, 1)
        fply.atend(FINISH, this)
        fply.go()
        frec.run()
        frec.go()

    def finish(optional status):  // stop recording and clean up
        print "File_play_record.finish called via .atend() processing"
        frec.stop()
        frec.unrun()
        frec = nil
        fply = nil


// handler for fprbutton: play file and record it
def file_play_record(obj, event, x, y):
    display "file_play_record", x
    File_play_record()


########## Fade Test ################

to_be_faded = nil

def fadetest(obj, event, x, y):
    display "fadetest", x
    var which = fadechoice.value()
    which = ord(which) - ord("a")
    var dur = 1 if which < 4 else 0.009
    var mode = which % 4
    if x:
        if which < 8:
            to_be_faded = sine(880, [0.3, 0.3])
        else:
            to_be_faded = ugen_powi(zero_ugen, [0, 0])
        to_be_faded.fade_in(dur, mode = mode)  // starts playing
    else:
        to_be_faded.fade(dur, mode = mode)
        to_be_faded = nil


########## Add Test ################
# this test just adds a stereo sine to a mono sine and plays it

adder = nil

def addtest(obj, event, x, y):
    display "addtest", x
    if x:
        adder = add(sine(880, [0.3, 0.3]), sine(1000, 0.2)).play()
    else:
        adder.mute()
        adder = nil


########## Sub Test ################
# This test subtracts a linear ramp from 0 to 1 from 0.5, which
# is the gain of a sine, so the sound intensity should go to zero
# and back to 0.5 (actually -0.5, so signal will be inverted).

subout = nil

def subtest(obj, event, x, y):
    display "subtest", x
    if x:
        subout = sine(880, subb(0.5, pwlb(4, 1))).play()
    else:
        subout.mute()
        subout = nil


########## Div Test ################
# This test divides by a slow sinusoid offset so as not to cross zero.

divout = nil

def divtest(obj, event, x, y):
    display "divtest", x
    if x:  # gain should be from 1/1.9 to 1/0.1, or ~0.5 to 10:
        divout = ugen_div(sine(880, 0.1), addb(1, sineb(1, 0.9))).play()
    else:
        divout.mute()
        divout = nil


########## Max Test ################
# This test uses ugen max to clip a sinusoid - an lfo is biased to
# -0.4 to 0.2, so the clipping is to the "bottom" of the audio
# sine tone.

maxout = nil

def maxtest(obj, event, x, y):
    display "maxtest", x
    if x:
        maxout = ugen_max(sine(440, 0.3), addb(-0.1, sineb(0.5, 0.3))).play()
    else:
        maxout.mute()
        maxout = nil


########## Min Test ################
# This test uses ugen_min to clip a sinusoid - same test as max, but
# clipping is from above and tone is 1 octave lower.

minout = nil

def mintest(obj, event, x, y):
    display "mintest", x
    if x:
        minout = ugen_min(sine(220, 0.3), addb(0.1, sineb(0.5, 0.3))).play()
    else:
        minout.mute()
        minout = nil


########## Clip Test ################
# This test uses ugen_clip to clip a sinusoid that modulates in amplitude

clipout = nil

def clptest(obj, event, x, y):
    display "cliptest", x
    if x:
        clipout = ugen_clip(sine(220, sineb(0.2, 2)), 0.3).play()
    else:
        clipout.mute()
        clipout = nil


########## Pow Test ################
# This test uses pow to change a wave shape. Both signals are positive.

powout = nil

def powtest(obj, event, x, y):
    display "powtest", x
    if x:
        powout = add(ugen_pow(add( sine(220, 0.5), 0.5),
                              add(sineb(0.2, 0.5), 0.5)), -0.5).play()
    else:
        powout.mute()
        powout = nil


########## Lt Test ################
# This test uses lt to produce a pulse wave

ltout = nil

def lttest(obj, event, x, y):
    display "lttest", x
    if x:
        ltout = sub(ugen_less(sine(220, 0.5), sineb(0.2, 0.4)), 0.5).play()
    else:
        ltout.mute()
        ltout = nil


########## Gt Test ################
# This test uses gt to produce a square wave used as tone amplitude

gtout = nil

def gttest(obj, event, x, y):
    display "gttest", x
    if x:
        gtout = sine(880, ugen_greaterb(sineb(3, 1), 0)).play()
    else:
        gtout.mute()
        gtout = nil


########## Scp Test ################
# This test uses soft clipping on a variablel amplitude sine

scpout = nil

def scptest(obj, event, x, y):
    display "scptest", x
    if x:
        scpout = ugen_soft_clip(sine(220, addb(1, sineb(0.2, 1))), 0.3).play()
    else:
        scpout.mute()
        scpout = nil


########## Pwi Test ################
# This test uses ugen_powi to raise sine tone to powers from 1 to 5

pwiout = nil

def pwitest(obj, event, x, y):
    display "pwitest", x
    if x:
        pwiout = mult(0.3, ugen_powi(sine(220, 1),
                                     addb(3, sineb(0.2, 2)))).play()
    else:
        pwiout.mute()
        pwiout = nil


########## Rnd Test ################
# This test generates noise where the upper and lower ranges
# are controlled by different LFOs

rndout = nil

def rndtest(obj, event, x, y):
    display "rndtest", x
    if x:
        rndout = ugen_rand(addb(-0.5, sineb(0.3, 0.5)),
                           addb(0.5, sineb(0.4, 0.5))).play()
    else:
        rndout.mute()
        rndout = nil


########## Sample/Hold Test ################
# This test sample/holds noise to control frequency

shout = nil

def shtest(obj, event, x, y):
    display "shtest", x
    if x:
        shout = sine(sample_hold(ugen_rand(220.0, 880.0),
                                 sineb(8, 1)),
                     0.3).play()
    else:
        shout.mute()
        shout = nil


########## Qnt Test ################
# This test quantizes a sinusoid using an lfo to vary
# quantization. Amplitude range of LFO + offset gives
# from 3 to 16 quantization levels

qntout = nil

def qnttest(obj, event, x, y):
    display "qnttest", x
    var q = (13 / 0x10000) * 0.5
    if x:
        qntout = ugen_quantize(sine(440, 0.5),
                               addb(q + 3 / 0x10000, sineb(0.1, q))).play()
    else:
        qntout.mute()
        qntout = nil


########## RLI Test ################
# This test uses RLI for frequency modulation
# rate is 6hz and depth is 523.251Hz +/- 50Hz

rliout = nil

def rlitest(obj, event, x, y):
    display "rlitest", x
    if x:
        var freq = addb(523.251, ugen_rlib(6, 50))
        rliout = sine(freq, 0.2).play()
    else:
        rliout.mute()
        rliout = nil


########## O2audioio Test ##############

def o2audioiotest(obj, event, x, y):
    display "o2audioiotest", x
    if x:
       o2audioioout = o2audioio(sine(1000, 0.1), "/audtest", 1, 1,
                                2048, 0, 256)
       o2audioioout.play()
       o2audioioout.enable(true)
    else:
        o2audioioout.mute()
        o2audioioout = nil


########## Zitarev Test ##############

def zitarevtest(obj, event, x, y):
    display "zitarevtest", x
    if x:
        var noise = ugen_rand(-0.1, 0.1)
        zrev = zitarev(noise, 0.5, 0.5)  // snd, wet, gain
        zrev.play()
    else:
        zrev.set('input', zero_ugen)
        sched_select(rtsched)
        sched_cause(6, zrev, 'mute')
        zrev = nil  // rvb1 and noise should be freed in 6 sec


########## Sttest Test ##############

def sttesttest(obj, event, x, y):
    display "sttesttest", x
    if x:  # play unfiltered noise followed by stereo lowpass with
           # cutoffs of 200 and 4000
        var noise = ugen_rand(-0.1, 0.1)
        sttest_ugen = sttest(noise, 200, 4000)  // snd, wet, gain
        stlp = lowpass(noise, 200, 2)
        stlp.play()
        sched_select(rtsched)
        sched_cause(2, stlp, 'mute')
        sched_cause(2, sttest_ugen, 'play')
    else:  # after delay to make sure we're playing filtered noise
           # mute the filtered noise
        sched_select(rtsched)
        sched_cause(2, sttest_ugen, 'mute')
        sttest_ugen = nil  // free the muted ugens
        stlp = nil


########## Tableosc Test ##############

def tableosctest(obj, event, x, y):
    display "tableosctest", x
    if x:  # make/play tone with tableosc borrowing from another
        var tblosc0 = tableosc(1, 1)
        tblosc0.create_tas(0, 100,
                [0.5 * i ** -1.5 for i = 1 to 15])  // make a waveform
        tblosc = tableosc(100.0, 0.2)
        tblosc.borrow(tblosc0)
        // tblosc0 is now "owned" by tblosc, so it should be freed later
        tblosc.select(0)  // select waveform 0
        tblosc.play()
    else:
        tblosc.mute()
        tblosc = nil

########## Tableosc Test ##############

def ssnote():
    ssnote = Note(0, pC3, 80, 3, rolloff = 0.8, animate = 1, width = 0.5,
                  attack = 0.2, decay = 0.5, detune = 0.3, cutoff = 24)
    sssynth.play_note(ssnote)

def ssdemo():
    ssscore = supersaw_example()
    sssynth.play_score(ssscore)

def ssstatus():
    print time_get(),
    if sssynth:
        display "STATUS", sssynth.notes, sssynth.free_notes,
        display     sssynth.finishing_notes
    else:
        display "STATUS", sssynth

def supersawtest(obj, event, x, y):
    display "supersawtest", x
    if x:  # make/play tone with Supersaw
        sssynth = synth_create(SUPERSAW1, detune = 0.3, chans = 2).play()
        // ssnote()
        // return
        sched_select(rtsched)
        sched_cause(0, nil, 'ssnote')
        sched_cause(4, nil, 'ssdemo')
        // sched_cause(5, nil, 'ssstatus')

    else:
        sssynth.mute()
        sssynth = nil
        ssscore = nil
        return
        sss.mute()

########## Overdrive Test ##############

ovd = nil
def overdrivetest(obj, event, x, y):
    display "overdrivetest", x
    if x:
        var noise = sine(sample_hold(ugen_rand(220.0, 880.0),
                                 sineb(8, 1)),
                     0.3)
        ovd = monodistortion(noise, 0.85, 0.85, 0.8)  // snd, gain, tone, volume
        ovd.play()
    else:
        ovd.set('snd', zero_ugen)
        sched_select(rtsched)
        sched_cause(6, ovd, 'mute')
        ovd = nil

########## Main Initialization ################

def arco_prugens_handler(rest ignore):
    // this tells Arco to print the Ugen tree -- it can be useful for
    //     debugging.
    o2_send_cmd("/arco/prtree", 0, "")
    // also print the list of Ugens accessible by integer ID:
    o2_send_cmd("/arco/prugens", 0, "")


def arco_ugen_gc_info_handler(rest ignore):
    arco_ugen_gc_info()


def main():
    o2_debug_flags("aA") // ("SsBl")
    arco_set_input_files([sound_file_path])
    arco_init(latency = 60, network = false, title = "Arco Test")
    o2lite_initialize()
    arco_run()
    sched_select(rtsched)
    var file_menu = default_window.get_menu("File")
    file_menu.item("Print Ugen Info", "print Ugen tree and table",
                   nil, nil, 'arco_prugens_handler')
    file_menu.item("Arco Ugen GC Info", "print info about Ugen IDs",
                   nil, nil, 'arco_ugen_gc_info_handler')


main()
