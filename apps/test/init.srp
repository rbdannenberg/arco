# arco.srp -- Serpent library for controlling Arco
#
# Roger B. Dannenberg
# Jan 2022

# call arco_init(ensemble) to start
# call arco_run() after setting up UI and or scheduling things
# arco_ready is set to true when arco is ready for action

require "debug"
require "wxserpent"
require "prob"
require "arco"
require "allugens"
require "reverb"

SIMPLE = false

class Atone (Instrument):
    def init(freq, dur, nharm):
        display "Atone", dur
        instr_begin()
        var env = member(pwlb(dur * 0.2, 0.01, dur * 0.8), 'env')
        display "In Atone", env, env.id, id(env.id)
        env.atend(MUTE, this)  # target to mute is this, not env!
        var mix = mix(1)
        for i = 0 to nharm:
            // we need a symbol for each mixer input but since the
            // number of inputs is controlled by nharm, we have to
            // manufacture symbols:
            var name = intern("i" + str(i))
            mix.ins(name, sine(freq * i, 0.8 ** i), env)
        if not SIMPLE and pr_coin(0.5):
            // reson filter center frequency envelope:
            var renv = member(pwlb(random(), pr_unif(4, 10) * freq, 
                                   5.0, 200.0, max(5.0, dur * 2)), 'renv')
            var q = pr_unif(0.5, 2.0)
            mix = reson(mix, renv, q)
        super.init("Atone", mix)


    def start():
        get('env').start()
        var renv = get('renv')
        if renv:  // start the reson filter envelope too if it exists
            renv.start()
        this


ui_initialized = false

def arco_ready():
    # called when arco is intialized and ready to make sound or when
    # arco audio stream has been reopened
    print "**** arco audio is running! ****"
    var win = default_window
    if ui_initialized:
        return

    display "arco_ready", wxs_h, wxs_space,
    display WXS_DEFAULT_HEIGHT, WXS_DEFAULT_SPACE

    Checkbox(win, "Simple test", 5, 5, 170, 20, 'stcheckbox')
    stcheckbox.add_target_method(nil, 'play_simple_test')

    Checkbox(win, "Mixer test", 'S', 'D', 'S', 'S', 'mtcheckbox')
    mtcheckbox.add_target_method(nil, 'play_mixer_test')

    Checkbox(win, "Atonal sequence", 'S', 'D', 'S', 'S', 'atcheckbox')
    atcheckbox.add_target_method(nil, 'play_atone_test')

    Button(win, "Play sound file", 'S', 'D', 'S', 'S', 'psfbutton')
    psfbutton.add_target_method(nil, 'play_sound_file')

    Checkbox(win, "Record Output", 'S', 'D', 'S', 'S', 'rocheckbox')
    rocheckbox.add_target_method(nil, 'record_output')

    Checkbox(win, "Play Recorded Output", 'S', 'D', 'S', 'S', 'procheckbox')
    procheckbox.add_target_method(nil, 'play_recorded_output')

    Checkbox(win, "Delay Test", 'S', 'D', 'S', 'S', 'dlycheckbox')
    dlycheckbox.add_target_method(nil, 'delay_test')

    Checkbox(win, "Pitch Shift Test", 'S', 'D', 'S', 'S', 'pscheckbox')
    pscheckbox.add_target_method(nil, 'pstest')

    Checkbox(win, "Feedback Test", 'S', 'D', 'S', 'S', 'fbcheckbox')
    fbcheckbox.add_target_method(nil, 'fbtest')

    Checkbox(win, "Granstream Test", 'S', 'D', 'S', 'S', 'gscheckbox')
    gscheckbox.add_target_method(nil, 'gstest')

    Button(win, "Pwl/Pwe Test", 'S', 'D', 'S', 'S', 'pwecheckbox')
    pwecheckbox.add_target_method(nil, 'pwetest')                

    Button(win, "Alpass Test", 'S', 'D', 'S', 'S', 'alpcheckbox')
    alpcheckbox.add_target_method(nil, 'alptest')                

    ui_initialized = true


def atone_sequence():
    var step = 40 + irandom(40)
    var freq = 440.0 * (2.0 ** (1/12)) ** (step - 69)
    var dur = pr_unif(0.5, 10)
    var nharm = 1 if SIMPLE else irandom(15) + 2 
    display "atone_sequence", freq, dur, nharm, sched_current, 
    display     vtsched, sched_vtime
    var atone = Atone(freq, dur, nharm).play().start()
    // sched_cause(dur + 0.2, atone, 'mute')
    var ioi = pr_unif(0.25, 2.0) ** 2
    if atone_running:
        sched_cause(ioi, nil, 'atone_sequence')


// handler for /host/openaggr messages with param info (a string)
def host_openaggr(timestamp, address, types, info)
    var LATENCY_MS = 50
    print info
    if find(info, "Aggregate") >= 0 or find(info, "default") >= 0:
        var id = int(info)
        print "  --> opening this device, id", id
        arco_open(id, id, 2, 2, LATENCY_MS, 32)
        o2_send_cmd("/arco/open", 0, "iiiiiis", id, id, 2, 2, LATENCY_MS, 32, 
                    "actl");
        o2_send_cmd("/arco/prtree", o2_time_get() + 1, "");
        

def host_openaggr_init()
    o2_service_new("host")
    o2_method_new("/host/openaggr", "s", 'host_openaggr', t)


######### Synthesis Tests ##############

// handler for stcheckbox: play/stop some sine tones
def play_simple_test(obj, event, x, y):
    display "play_simple_test", x
    if x:
        sin1 = sine(440.0, 0.01).play()
        sin2 = sine(880.0, 0.01).play()
        sin3 = sine(1320.0, 0.007).play()
        sin4 = sine(1760.0, 0.005).play()
    else:
        sin1.mute()
        sin1 = nil  // delete reference for garbage collection
        sin2.mute()
        sin2 = nil
        sin3.mute()
        sin3 = nil
        sin4.mute()
        sin4 = nil

// handler for mtcheckbox: play/stop some sine tones
def play_mixer_test(obj, event, x, y):
    if x:
        m1 = mix(2)

        ms1 = sine(440.0, 0.01)
        m1.ins('inp1', ms1, [1, 0])

        ms2 = sine(880.0, 0.01)
        m1.ins('inp2', ms2, [0, 1])

        m1.ins('inp3', sine(1320.0, 0.007), 1)

        m1.ins('inp4', sine(1760.0, 0.005), 1)

        m1.play()

        sched_select(rtsched)
        sched_cause(1.0, nil, 'mixer_gain_change_1')
        sched_cause(2.0, nil, 'mixer_gain_change_2')
    else
        m1.mute()
        m1 = nil  // delete references
        ms1 = nil
        ms2 = nil

def mixer_gain_change_1():
    if m1:  // user has not stopped test yet
        m1.set_gain('inp1', 10, 0)  // left channel

def mixer_gain_change_2():
    if m1:  // user has not stopped test yet
        m1.set_gain('inp2', 10, 1)  // right channel


########## PLAYREC TESTS ##################

recplay1 = nil

def record_output(obj, event, x, y):
    display "record_output", x
    if x:
        if not recplay1:  // long fade time to test this feature
            recplay1 = recplay(prev_output_ugen, 2, 0.5, 3.0, false)
        recplay1.run()  # needs be in run set to make active
        recplay1.record(true)
    elif not recplay1:
        print "WARNING: There is no recplay1 Ugen!"
    else:
        recplay1.record(false)
        recplay1.unrun()  # does not need to be active now


def play_recorded_output(obj, event, x, y):
    display "play_recorded_output", x
    if x and recplay1:
        // note that Recplay might end playback immediately upon starting,
        // so we need to set up the atend action before sending 'start':
        recplay1.play().atend(MUTE)
        recplay1.start(0.0)
    elif (not x) and recplay1:
        recplay1.stop()  // atend is already set up to mute when finished


############ ATONE: INSTRUMENT AND NOTE SEQUENCE ##############

// handler for atcheckbox: play/stop an algorithmic composition
def play_atone_test(obj, event, x, y)
    atone_running = x
    if x:
        sched_select(vtsched)  // vtsched stops when audio stops
        atone_sequence()

############ PLAY SOUND FILE ##############

sound_file_path = "/Users/rbd/Music/soundscape1/digichoir1.wav"

// handler for psfbutton: play the sound file 
def play_sound_file(rest ignore):
# We could simply play the Fileplay Ugen, but we're using a
# Mix(er) to provide an (unused) gain control and also to
# show how the Mix and Fileplay can be freed when the sound
# finishes.
    var m1 = mix(2)
    var sp = fileplay(sound_file_path, 2)
    m1.ins('sndfile', sp, 1)  // sp reference handed off to m1
    m1.play()  // connect mixer to output
    sp.atend(MUTE, m1)  // "when the sound file finishes, mute m1"
    // The mute method will delete m1. If it were not a local var,
    // we would call m1.ref() here.
    sp.go()     // play the sound file. Technically, we do not have
    // a reference because we gave it to m1, but this is non-preemptive
    // and our local m1 shadow holds the reference.

########## DELAY TEST ################

def delay_test(obj, event, x, y):
    display "delay_test", x
    if x:
        dly1 = delay(input_ugen, 1.0, 0.1, 2.0, 2)
        dly1.play()
    else:
        dly1.mute()  // immediate stop
        dly1 = nil   // eventual cleanup when GC frees it

########## PITCH SHIFT TEST #############

def pstest(obj, event, x, y):
    display "pstest - pitch shift", x
    if x:
        ps1 = ola_pitch_shift(input_ugen, 1.25, 0.01, 0.05)
        ps1.play()
    else:
        ps1.mute()  // immediate stop
        ps1 = nil   // eventual cleanup when GC frees it

########## FEEDBACK TEST #############

def fbtest(obj, event, x, y):
# create a delay with no internal feedback and use a feedback ugen to
# produce feedback. The delay test used 0.1 gain on feedback so we do
# the same here, and set delay to 1 second as with delay test.
    display "fbtest - feedback", x
    if x:
        // initially "from" is zero; then we replace it with delay
        fb1 = feedback(input_ugen, zero_ugen, 0.5)
        fb2 = delay(fb1, 1.0, 0.0, 2.0)
        fb1.set('from', fb2)  // feedback from delay output
        fb2.play()
    else:
        fb2.mute()  // immediate stop
        fb1.set('from', zero_ugen)  // break the cycle to allow GC
        fb1 = nil   // eventual cleanup when GC frees it
        fb2 = nil


########## GRANSTREAM TEST #############

def gstest(obj, event, x, y):
# create a granstream to granulate microphone input
    display "gstest - granstream applied microphone input ", x
    if x:
        gs1 = granstream(input_ugen, 20, 3.0, true, 2)  // 2 channel
        // gs1 = granstream(input_ugen, 20, 1.0, true, 1)  // 1 channel
        gs1.play()
    else:
        gs1.mute()  // immediate stop
        gs1 = nil   // eventual cleanup


########## PWE TEST #############

def pwetest(obj, event, x, y):
# create a tone with pwe envelope
    display "pwetest - tones with pwl and pwe envelopes"
    pwlnote()
    sched_select(rtsched)
    sched_cause(1.3, nil, 'pwenote')
    
def pwlnote()
    print "pwlnote starting to play"
    var env = pwlb(0.2, 0.5, 1.0)
    var note = mult(sine(880.0, 1.0), env)
    env.atend(MUTE, note)
    note.play()

def pwenote()
    print "pwenote starting to play"
    var env = pweb(0.2, 0.5, 1.0)
    var note = mult(sine(880.0, 1.0), env)
    env.atend(MUTE, note)
    note.play()


########## ALPASS TEST #############

def alptest(obj, event, x, y):
# This test performs a sequence of sounds:
# 1. create and apply an alpass filter to a frequency sweep
# 2. same test, but use a comb filter instead
# 3. apply reverb with 1s reverb time to frequency sweep
# 4. change the reverb time on the same reverb object to 5s and
#       switch input to a new frequency sweep generator
# 5. remove the reverb object and clean up
    display "alptest - tones with and without alpass filter"
    sweep()
    sched_select(rtsched)
    sched_cause(2.0, nil, 'alpsweep')
    sched_cause(4.0, nil, 'cmbsweep')
    sched_cause(6.0, nil, 'rvbsweep')
    sched_cause(8.0, nil, 'rvbsweep2')

def sweeper():
# make a sine tone sweep with amp that goes to zero at 0.4s
    var swpwl = pwlb(0.0, 440.0, 0.4, 1760.0, 10.0)
    var swsine = sine(swpwl, 1.0)
    sched_select(rtsched)
    sched_cause(0.4, swsine, 'set', 'amp', 0.0)
    return swsine

def sweep()
    var swsine = sweeper()
    swsine.play()
    sched_cause(0.5, swsine, 'mute')

def alpsweep()
    var swsine = sweeper()
    var alp = alpass(swsine, 0.04, 0.9, 0.041)
    alp.play()
    sched_cause(2, alp, 'mute')

def cmbsweep()
    var swsine = sweeper()
    var cmb = delay(swsine, 0.04, 0.9, 0.041)
    cmb.play()
    sched_cause(2, cmb, 'mute')

def rvbsweep()
# create reverb and send in a sine sweep
    var swsine = sweeper()
    rvb = reverb(swsine, 1.0)  // GLOBAL
    rvb.play()

def rvbsweep2()
# set reverb time to 5s and send in another sine sweep
    var swsine = sweeper()
    rvb.set_rt60(5.0)
    rvb.set_inp(swsine)
    sched_cause(6, nil, 'rvbfinish')

def rvbfinish():
    rvb.mute()
    rvb = nil  // allow GC


########## Main Initialization ################

def arco_prugens_handler(rest ignore):
    // this tells Arco to print the Ugen tree -- it can be useful for
    //     debugging.
    o2_send_cmd("/arco/prtree", 0, "")
    // also print the list of Ugens accessible by integer ID:
    o2_send_cmd("/arco/prugens", 0, "")


def arco_ugen_gc_info_handler(rest ignore):
    arco_ugen_gc_info()


def main():
    o2_debug_flags("") // ("SsBl")
    arco_init(latency = 60, network = false, title = "Arco Test")
    // this should be replaced by a preference and menu system to select
    // and open audio device(s):
    arco_run()
    sched_select(rtsched)
    display "####### main.srp GETTING File MENU FROM", default_window
    var file_menu = default_window.get_menu("File")
    file_menu.item("Print Ugen Info", "print Ugen tree and table",
                   nil, nil, 'arco_prugens_handler')
    file_menu.item("Arco Ugen GC Info", "print info about Ugen IDs",
                   nil, nil, 'arco_ugen_gc_info_handler')


main()
