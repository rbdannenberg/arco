# arco.srp -- Serpent library for controlling Arco
#
# Roger B. Dannenberg
# Jan 2022

# call arco_init(ensemble) to start
# call arco_run() after setting up UI and or scheduling things
# arco_ready is set to true when arco is ready for action

require "debug"
require "wxserpent"
require "prob"
require "arco"

SIMPLE = false
gc_watch_set = false;

watching = {}

def watch(ugen, name):
    watching[arco_ugen_id(ugen.id)] = name
    watched_action(ugen, "Watching")

def watched_action(ugen, msg):
    var name = watching.get(arco_ugen_id(ugen.id))
    if name:
        display "Watched action", msg, ugen, ugen.id, name


class Atone (Instrument):
    def init(freq, dur, nharm):
        display "Atone", dur
        instr_begin()
        var env = member(pwlb(dur * 0.2, 0.01, dur * 0.8), 'env')
        display "In Atone", env, env.id, id(env.id)
        if not gc_watch_set:
            dbg_gc_watch(id(env.id))
            watch(env, "pwlb")
        env.atend(MUTE, this)
        var mix = mix(1)
        for i = 0 to nharm:
            mix.ins(sine(freq * i, 0.8 ** i), env)
        if not SIMPLE and pr_coin(0.5):
            // reson filter center frequency envelope:
            var renv = member(pwlb(random(), pr_unif(4, 10) * freq, 
                                   5.0, 200.0, max(5.0, dur * 2)), 'renv')
            var q = pr_unif(0.5, 2.0)
            mix = reson(mix, renv, q)
        super.init("Atone", mix)
        if not gc_watch_set:
            watch(this, "Atone")
        gc_watch_set = true

    def start():
        get('env').start()
        var renv = get('renv')
        if renv:  // start the reson filter envelope too if it exists
            renv.start()
        this


gccyclesst = nil // text boxes are created after Arco audio is started
cpuloadst = nil

def arco_ready():
    # called when arco is intialized and ready to make sound
    print "**** arco ready! ****"
    var win = default_window

    Button(win, "Print Ugen Tree", 10, 10, 170, 20, 'ptbutton')
    ptbutton.add_target_method(nil, 'print_ugen_tree')
    
    Checkbox(win, "Simple test", 'S', 'D', 'S', 'S', 'stcheckbox')
    stcheckbox.add_target_method(nil, 'play_simple_test')

    Checkbox(win, "Mixer test", 'S', 'D', 'S', 'S', 'mtcheckbox')
    mtcheckbox.add_target_method(nil, 'play_mixer_test')

    Checkbox(win, "Atonal sequence", 'S', 'D', 'S', 'S', 'atcheckbox')
    atcheckbox.add_target_method(nil, 'play_atone_test')

    Button(win, "Play sound file", 'S', 'D', 'S', 'S', 'psfbutton')
    psfbutton.add_target_method(nil, 'play_sound_file')

    Statictext(win, "GC cycles: 0", 'S', 'D', 'S', 'S', 'gccyclesst')
    Statictext(win, "CPU Load:", 'S', 'D', 'S', 'S', 'cpuloadst')
    Statictext(win, "Max Ugen ID: 0", 'S', 'D', 'S', 'S', 'maxugenidst')


def poll_for_status():
    if gccyclesst:
        gccyclesst.set_string("GC cycles: " + str(gc_cycles()))
        maxugenidst.set_string("Max Ugen ID: " + str(max_ugen_id_used))
        arco_get_cpu_load('show_cpu_load')
    sched_cause(1.0, nil, 'poll_for_status')


def show_cpu_load(cpu):
    cpuloadst.set_string("CPU Load: " + str(cpu))


def print_ugen_tree(rest ignore):
    arco_prtree()


def atone_sequence():
    var step = 40 + irandom(40)
    var freq = 440.0 * (2.0 ** (1/12)) ** (step - 69)
    var dur = pr_unif(0.5, 10)
    var nharm = 1 if SIMPLE else irandom(15) + 2 
    display "atone_sequence", freq, dur, nharm
    var atone = Atone(freq, dur, nharm).play().start()
    // sched_cause(dur + 0.2, atone, 'mute')
    var ioi = pr_unif(0.25, 2.0) ** 2
    if atone_running:
        sched_cause(ioi, nil, 'atone_sequence')


// handler for /host/openaggr messages with param info (a string)
def host_openaggr(timestamp, address, types, info)
    var LATENCY_MS = 50
    print info
    if find(info, "Aggregate") >= 0 or find(info, "default") >= 0:
        var id = int(info)
        print "  --> opening this device, id", id
        arco_open(id, id, 2, 2, LATENCY_MS, 32)
        o2_send_cmd("/arco/open", 0, "iiiiiis", id, id, 2, 2, LATENCY_MS, 32, 
                    "actl");
        o2_send_cmd("/arco/prtree", o2_time_get() + 1, "");
        

def host_openaggr_init()
    o2_service_new("host")
    o2_method_new("/host/openaggr", "s", 'host_openaggr', t)


######### Synthesis Tests ##############

// handler for stcheckbox: play/stop some sine tones
def play_simple_test(obj, event, x, y):
    display "play_simple_test", x
    if x:
        sin1 = sine(440.0, 0.01).play()
        sin2 = sine(880.0, 0.01).play()
        sin3 = sine(1320.0, 0.007).play()
        sin4 = sine(1760.0, 0.005).play()
    else:
        sin1.mute()
        sin1 = nil  // delete reference for garbage collection
        sin2.mute()
        sin2 = nil
        sin3.mute()
        sin3 = nil
        sin4.mute()
        sin4 = nil

// handler for mtcheckbox: play/stop some sine tones
def play_mixer_test(obj, event, x, y):
    if x:
        m1 = mix(1)
        m1.ins(sine(440.0, 0.01), 1)
        m1.ins(sine(880.0, 0.01), 1)
        m1.ins(sine(1320.0, 0.007), 1)
        m1.ins(sine(1760.0, 0.005), 1)
        m1.play()
    else
        m1.mute()
        m1 = nil  // delete reference


// handler for atcheckbox: play/stop an algorithmic composition
def play_atone_test(obj, event, x, y)
    atone_running = x
    if x:
        atone_sequence()


sound_file_path = "/Users/rbd/Music/soundscape1/digichoir1.wav"

// handler for psfbutton: play the sound file 
def play_sound_file(rest ignore):
# We could simply play the Strplay Ugen, but we're using a
# Mix(er) to provide an (unused) gain control and also to
# show how the Mix and Strplay can be freed when the sound
# finishes.
    var m1 = mix(2)
    var sp = strplay(sound_file_path, 2)
    m1.ins(sp, 1)  // sp reference handed off to m1
    m1.play()  // connect mixer to output
    sp.atend(MUTE, m1)  // "when the sound file finishes, mute m1"
    // The mute method will delete m1. If it were not a local var,
    // we would call m1.ref() here.
    sp.go()     // play the sound file. Technically, we do not have
    // a reference because we gave it to m1, but this is non-preemptive
    // and our local m1 shadow holds the reference.
    o2_send_cmd("/arco/prtree", 0, "")  // this tells Arco to print the Ugen
    // tree -- it can be useful for debugging.
    sched_select(rtsched)
    // To confirm the objects are deleted, we can schedule the printing of
    // all unit generators in the ugen_table. You can compare Ugen numbers
    // to the tree printout earlier.
    sched_cause(10, nil, 'o2_send_cmd', "/arco/prugens", 0, "")
    // Not all unit generators are necessarily in the ugen_table. The
    // table is needed for clients to address individual unit generators,
    // but unit generators can be accessed by other unit generators and
    // they can be rooted in the Audioio output list, so let's print
    // the tree again after things should be cleaned up.
    sched_cause(10.01, nil, 'o2_send_cmd', "/arco/prtree", 0, "")



########## Main Initialization ################

def main():
    o2_debug_flags("") // ("SsBl")
    arco_init(network = false, title = "Arco Test")
    // this should be replaced by a preference and menu system to select
    // and open audio device(s):
    host_openaggr_init()
    arco_run()
    sched_select(rtsched)
    poll_for_status()

main()
